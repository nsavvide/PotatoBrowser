#![allow(
    dead_code,
    improper_ctypes_definitions,
    non_camel_case_types,
    unused_variables,
    clippy::not_unsafe_ptr_arg_deref,
    clippy::too_many_arguments
)]
use crate::rc::{ConvertParam, ConvertReturnValue, Rc, RcImpl, RefGuard, WrapParamRef};
use cef_dll_sys::*;

/// Perform the conversion between CEF and Rust types in field initializers.
fn init_array_field<T, U, const N: usize>(mut value: [U; N]) -> [T; N]
where
    T: Sized,
    U: Sized + Into<T>,
{
    std::array::from_fn(move |i| {
        let mut elem = unsafe { std::mem::zeroed() };
        std::mem::swap(&mut value[i], &mut elem);
        elem.into()
    })
}

/// See [`cef_string_wide_t`] for more documentation.
pub use crate::string::CefStringUserfreeWide;

/// See [`cef_string_utf8_t`] for more documentation.
pub use crate::string::CefStringUserfreeUtf8;

/// See [`cef_string_utf16_t`] for more documentation.
pub use crate::string::CefStringUserfreeUtf16;

/// See [`char16_t`] for more documentation.
pub type Char = char16_t;

/// See [`cef_string_userfree_utf16_t`] for more documentation.
pub type CefStringUserfree = CefStringUserfreeUtf16;

/// See [`cef_string_utf16_t`] for more documentation.
pub type CefString = CefStringUtf16;

/// See [`u32`] for more documentation.
pub type Color = u32;

/// See [`_cef_string_wide_t`] for more documentation.
pub use crate::string::CefStringWide;

/// See [`_cef_string_utf8_t`] for more documentation.
pub use crate::string::CefStringUtf8;

/// See [`_cef_string_utf16_t`] for more documentation.
pub use crate::string::CefStringUtf16;

/// See [`_cef_string_list_t`] for more documentation.
pub use crate::string::CefStringList;

/// See [`_cef_string_map_t`] for more documentation.
pub use crate::string::CefStringMap;

/// See [`_cef_string_multimap_t`] for more documentation.
pub use crate::string::CefStringMultimap;

/// See [`_cef_basetime_t`] for more documentation.
#[derive(Clone)]
pub struct Basetime {
    pub val: i64,
}
impl From<_cef_basetime_t> for Basetime {
    fn from(value: _cef_basetime_t) -> Self {
        Self { val: value.val }
    }
}
impl From<Basetime> for _cef_basetime_t {
    fn from(value: Basetime) -> Self {
        Self { val: value.val }
    }
}
impl Default for Basetime {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_time_t`] for more documentation.
#[derive(Clone)]
pub struct Time {
    pub year: ::std::os::raw::c_int,
    pub month: ::std::os::raw::c_int,
    pub day_of_week: ::std::os::raw::c_int,
    pub day_of_month: ::std::os::raw::c_int,
    pub hour: ::std::os::raw::c_int,
    pub minute: ::std::os::raw::c_int,
    pub second: ::std::os::raw::c_int,
    pub millisecond: ::std::os::raw::c_int,
}
impl From<_cef_time_t> for Time {
    fn from(value: _cef_time_t) -> Self {
        Self {
            year: value.year,
            month: value.month,
            day_of_week: value.day_of_week,
            day_of_month: value.day_of_month,
            hour: value.hour,
            minute: value.minute,
            second: value.second,
            millisecond: value.millisecond,
        }
    }
}
impl From<Time> for _cef_time_t {
    fn from(value: Time) -> Self {
        Self {
            year: value.year,
            month: value.month,
            day_of_week: value.day_of_week,
            day_of_month: value.day_of_month,
            hour: value.hour,
            minute: value.minute,
            second: value.second,
            millisecond: value.millisecond,
        }
    }
}
impl Default for Time {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_point_t`] for more documentation.
#[derive(Clone)]
pub struct Point {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
impl From<_cef_point_t> for Point {
    fn from(value: _cef_point_t) -> Self {
        Self {
            x: value.x,
            y: value.y,
        }
    }
}
impl From<Point> for _cef_point_t {
    fn from(value: Point) -> Self {
        Self {
            x: value.x,
            y: value.y,
        }
    }
}
impl Default for Point {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_rect_t`] for more documentation.
#[derive(Clone)]
pub struct Rect {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
impl From<_cef_rect_t> for Rect {
    fn from(value: _cef_rect_t) -> Self {
        Self {
            x: value.x,
            y: value.y,
            width: value.width,
            height: value.height,
        }
    }
}
impl From<Rect> for _cef_rect_t {
    fn from(value: Rect) -> Self {
        Self {
            x: value.x,
            y: value.y,
            width: value.width,
            height: value.height,
        }
    }
}
impl Default for Rect {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_size_t`] for more documentation.
#[derive(Clone)]
pub struct Size {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
impl From<_cef_size_t> for Size {
    fn from(value: _cef_size_t) -> Self {
        Self {
            width: value.width,
            height: value.height,
        }
    }
}
impl From<Size> for _cef_size_t {
    fn from(value: Size) -> Self {
        Self {
            width: value.width,
            height: value.height,
        }
    }
}
impl Default for Size {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_insets_t`] for more documentation.
#[derive(Clone)]
pub struct Insets {
    pub top: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
}
impl From<_cef_insets_t> for Insets {
    fn from(value: _cef_insets_t) -> Self {
        Self {
            top: value.top,
            left: value.left,
            bottom: value.bottom,
            right: value.right,
        }
    }
}
impl From<Insets> for _cef_insets_t {
    fn from(value: Insets) -> Self {
        Self {
            top: value.top,
            left: value.left,
            bottom: value.bottom,
            right: value.right,
        }
    }
}
impl Default for Insets {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_accelerated_paint_info_common_t`] for more documentation.
#[derive(Clone)]
pub struct AcceleratedPaintInfoCommon {
    pub size: usize,
    pub timestamp: u64,
    pub coded_size: Size,
    pub visible_rect: Rect,
    pub content_rect: Rect,
    pub source_size: Size,
    pub capture_update_rect: Rect,
    pub region_capture_rect: Rect,
    pub capture_counter: u64,
    pub has_capture_update_rect: u8,
    pub has_region_capture_rect: u8,
    pub has_source_size: u8,
    pub has_capture_counter: u8,
}
impl From<_cef_accelerated_paint_info_common_t> for AcceleratedPaintInfoCommon {
    fn from(value: _cef_accelerated_paint_info_common_t) -> Self {
        Self {
            size: value.size,
            timestamp: value.timestamp,
            coded_size: value.coded_size.into(),
            visible_rect: value.visible_rect.into(),
            content_rect: value.content_rect.into(),
            source_size: value.source_size.into(),
            capture_update_rect: value.capture_update_rect.into(),
            region_capture_rect: value.region_capture_rect.into(),
            capture_counter: value.capture_counter,
            has_capture_update_rect: value.has_capture_update_rect,
            has_region_capture_rect: value.has_region_capture_rect,
            has_source_size: value.has_source_size,
            has_capture_counter: value.has_capture_counter,
        }
    }
}
impl From<AcceleratedPaintInfoCommon> for _cef_accelerated_paint_info_common_t {
    fn from(value: AcceleratedPaintInfoCommon) -> Self {
        Self {
            size: value.size,
            timestamp: value.timestamp,
            coded_size: value.coded_size.into(),
            visible_rect: value.visible_rect.into(),
            content_rect: value.content_rect.into(),
            source_size: value.source_size.into(),
            capture_update_rect: value.capture_update_rect.into(),
            region_capture_rect: value.region_capture_rect.into(),
            capture_counter: value.capture_counter,
            has_capture_update_rect: value.has_capture_update_rect,
            has_region_capture_rect: value.has_region_capture_rect,
            has_source_size: value.has_source_size,
            has_capture_counter: value.has_capture_counter,
        }
    }
}
impl Default for AcceleratedPaintInfoCommon {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_accelerated_paint_info_common_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_main_args_t`] for more documentation.
#[derive(Clone)]
pub struct MainArgs {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
}
impl From<_cef_main_args_t> for MainArgs {
    fn from(value: _cef_main_args_t) -> Self {
        Self {
            argc: value.argc,
            argv: value.argv,
        }
    }
}
impl From<MainArgs> for _cef_main_args_t {
    fn from(value: MainArgs) -> Self {
        Self {
            argc: value.argc,
            argv: value.argv,
        }
    }
}
impl Default for MainArgs {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_window_info_t`] for more documentation.
#[derive(Clone)]
pub struct WindowInfo {
    pub size: usize,
    pub window_name: CefString,
    pub bounds: Rect,
    pub hidden: ::std::os::raw::c_int,
    pub parent_view: *mut ::std::os::raw::c_void,
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    pub shared_texture_enabled: ::std::os::raw::c_int,
    pub external_begin_frame_enabled: ::std::os::raw::c_int,
    pub view: *mut ::std::os::raw::c_void,
    pub runtime_style: RuntimeStyle,
}
impl From<_cef_window_info_t> for WindowInfo {
    fn from(value: _cef_window_info_t) -> Self {
        Self {
            size: value.size,
            window_name: value.window_name.into(),
            bounds: value.bounds.into(),
            hidden: value.hidden,
            parent_view: value.parent_view,
            windowless_rendering_enabled: value.windowless_rendering_enabled,
            shared_texture_enabled: value.shared_texture_enabled,
            external_begin_frame_enabled: value.external_begin_frame_enabled,
            view: value.view,
            runtime_style: value.runtime_style.into(),
        }
    }
}
impl From<WindowInfo> for _cef_window_info_t {
    fn from(value: WindowInfo) -> Self {
        Self {
            size: value.size,
            window_name: value.window_name.into(),
            bounds: value.bounds.into(),
            hidden: value.hidden,
            parent_view: value.parent_view,
            windowless_rendering_enabled: value.windowless_rendering_enabled,
            shared_texture_enabled: value.shared_texture_enabled,
            external_begin_frame_enabled: value.external_begin_frame_enabled,
            view: value.view,
            runtime_style: value.runtime_style.into(),
        }
    }
}
impl Default for WindowInfo {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_window_info_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_accelerated_paint_info_t`] for more documentation.
#[derive(Clone)]
pub struct AcceleratedPaintInfo {
    pub size: usize,
    pub shared_texture_io_surface: *mut ::std::os::raw::c_void,
    pub format: ColorType,
    pub extra: AcceleratedPaintInfoCommon,
}
impl From<_cef_accelerated_paint_info_t> for AcceleratedPaintInfo {
    fn from(value: _cef_accelerated_paint_info_t) -> Self {
        Self {
            size: value.size,
            shared_texture_io_surface: value.shared_texture_io_surface,
            format: value.format.into(),
            extra: value.extra.into(),
        }
    }
}
impl From<AcceleratedPaintInfo> for _cef_accelerated_paint_info_t {
    fn from(value: AcceleratedPaintInfo) -> Self {
        Self {
            size: value.size,
            shared_texture_io_surface: value.shared_texture_io_surface,
            format: value.format.into(),
            extra: value.extra.into(),
        }
    }
}
impl Default for AcceleratedPaintInfo {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_accelerated_paint_info_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_settings_t`] for more documentation.
#[derive(Clone)]
pub struct Settings {
    pub size: usize,
    pub no_sandbox: ::std::os::raw::c_int,
    pub browser_subprocess_path: CefString,
    pub framework_dir_path: CefString,
    pub main_bundle_path: CefString,
    pub multi_threaded_message_loop: ::std::os::raw::c_int,
    pub external_message_pump: ::std::os::raw::c_int,
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    pub command_line_args_disabled: ::std::os::raw::c_int,
    pub cache_path: CefString,
    pub root_cache_path: CefString,
    pub persist_session_cookies: ::std::os::raw::c_int,
    pub user_agent: CefString,
    pub user_agent_product: CefString,
    pub locale: CefString,
    pub log_file: CefString,
    pub log_severity: LogSeverity,
    pub log_items: LogItems,
    pub javascript_flags: CefString,
    pub resources_dir_path: CefString,
    pub locales_dir_path: CefString,
    pub remote_debugging_port: ::std::os::raw::c_int,
    pub uncaught_exception_stack_size: ::std::os::raw::c_int,
    pub background_color: u32,
    pub accept_language_list: CefString,
    pub cookieable_schemes_list: CefString,
    pub cookieable_schemes_exclude_defaults: ::std::os::raw::c_int,
    pub chrome_policy_id: CefString,
    pub chrome_app_icon_id: ::std::os::raw::c_int,
    pub disable_signal_handlers: ::std::os::raw::c_int,
}
impl From<_cef_settings_t> for Settings {
    fn from(value: _cef_settings_t) -> Self {
        Self {
            size: value.size,
            no_sandbox: value.no_sandbox,
            browser_subprocess_path: value.browser_subprocess_path.into(),
            framework_dir_path: value.framework_dir_path.into(),
            main_bundle_path: value.main_bundle_path.into(),
            multi_threaded_message_loop: value.multi_threaded_message_loop,
            external_message_pump: value.external_message_pump,
            windowless_rendering_enabled: value.windowless_rendering_enabled,
            command_line_args_disabled: value.command_line_args_disabled,
            cache_path: value.cache_path.into(),
            root_cache_path: value.root_cache_path.into(),
            persist_session_cookies: value.persist_session_cookies,
            user_agent: value.user_agent.into(),
            user_agent_product: value.user_agent_product.into(),
            locale: value.locale.into(),
            log_file: value.log_file.into(),
            log_severity: value.log_severity.into(),
            log_items: value.log_items.into(),
            javascript_flags: value.javascript_flags.into(),
            resources_dir_path: value.resources_dir_path.into(),
            locales_dir_path: value.locales_dir_path.into(),
            remote_debugging_port: value.remote_debugging_port,
            uncaught_exception_stack_size: value.uncaught_exception_stack_size,
            background_color: value.background_color,
            accept_language_list: value.accept_language_list.into(),
            cookieable_schemes_list: value.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: value.cookieable_schemes_exclude_defaults,
            chrome_policy_id: value.chrome_policy_id.into(),
            chrome_app_icon_id: value.chrome_app_icon_id,
            disable_signal_handlers: value.disable_signal_handlers,
        }
    }
}
impl From<Settings> for _cef_settings_t {
    fn from(value: Settings) -> Self {
        Self {
            size: value.size,
            no_sandbox: value.no_sandbox,
            browser_subprocess_path: value.browser_subprocess_path.into(),
            framework_dir_path: value.framework_dir_path.into(),
            main_bundle_path: value.main_bundle_path.into(),
            multi_threaded_message_loop: value.multi_threaded_message_loop,
            external_message_pump: value.external_message_pump,
            windowless_rendering_enabled: value.windowless_rendering_enabled,
            command_line_args_disabled: value.command_line_args_disabled,
            cache_path: value.cache_path.into(),
            root_cache_path: value.root_cache_path.into(),
            persist_session_cookies: value.persist_session_cookies,
            user_agent: value.user_agent.into(),
            user_agent_product: value.user_agent_product.into(),
            locale: value.locale.into(),
            log_file: value.log_file.into(),
            log_severity: value.log_severity.into(),
            log_items: value.log_items.into(),
            javascript_flags: value.javascript_flags.into(),
            resources_dir_path: value.resources_dir_path.into(),
            locales_dir_path: value.locales_dir_path.into(),
            remote_debugging_port: value.remote_debugging_port,
            uncaught_exception_stack_size: value.uncaught_exception_stack_size,
            background_color: value.background_color,
            accept_language_list: value.accept_language_list.into(),
            cookieable_schemes_list: value.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: value.cookieable_schemes_exclude_defaults,
            chrome_policy_id: value.chrome_policy_id.into(),
            chrome_app_icon_id: value.chrome_app_icon_id,
            disable_signal_handlers: value.disable_signal_handlers,
        }
    }
}
impl Default for Settings {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_settings_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_request_context_settings_t`] for more documentation.
#[derive(Clone)]
pub struct RequestContextSettings {
    pub size: usize,
    pub cache_path: CefString,
    pub persist_session_cookies: ::std::os::raw::c_int,
    pub accept_language_list: CefString,
    pub cookieable_schemes_list: CefString,
    pub cookieable_schemes_exclude_defaults: ::std::os::raw::c_int,
}
impl From<_cef_request_context_settings_t> for RequestContextSettings {
    fn from(value: _cef_request_context_settings_t) -> Self {
        Self {
            size: value.size,
            cache_path: value.cache_path.into(),
            persist_session_cookies: value.persist_session_cookies,
            accept_language_list: value.accept_language_list.into(),
            cookieable_schemes_list: value.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: value.cookieable_schemes_exclude_defaults,
        }
    }
}
impl From<RequestContextSettings> for _cef_request_context_settings_t {
    fn from(value: RequestContextSettings) -> Self {
        Self {
            size: value.size,
            cache_path: value.cache_path.into(),
            persist_session_cookies: value.persist_session_cookies,
            accept_language_list: value.accept_language_list.into(),
            cookieable_schemes_list: value.cookieable_schemes_list.into(),
            cookieable_schemes_exclude_defaults: value.cookieable_schemes_exclude_defaults,
        }
    }
}
impl Default for RequestContextSettings {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_request_context_settings_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_browser_settings_t`] for more documentation.
#[derive(Clone)]
pub struct BrowserSettings {
    pub size: usize,
    pub windowless_frame_rate: ::std::os::raw::c_int,
    pub standard_font_family: CefString,
    pub fixed_font_family: CefString,
    pub serif_font_family: CefString,
    pub sans_serif_font_family: CefString,
    pub cursive_font_family: CefString,
    pub fantasy_font_family: CefString,
    pub default_font_size: ::std::os::raw::c_int,
    pub default_fixed_font_size: ::std::os::raw::c_int,
    pub minimum_font_size: ::std::os::raw::c_int,
    pub minimum_logical_font_size: ::std::os::raw::c_int,
    pub default_encoding: CefString,
    pub remote_fonts: State,
    pub javascript: State,
    pub javascript_close_windows: State,
    pub javascript_access_clipboard: State,
    pub javascript_dom_paste: State,
    pub image_loading: State,
    pub image_shrink_standalone_to_fit: State,
    pub text_area_resize: State,
    pub tab_to_links: State,
    pub local_storage: State,
    pub databases: State,
    pub webgl: State,
    pub background_color: u32,
    pub chrome_status_bubble: State,
    pub chrome_zoom_bubble: State,
}
impl From<_cef_browser_settings_t> for BrowserSettings {
    fn from(value: _cef_browser_settings_t) -> Self {
        Self {
            size: value.size,
            windowless_frame_rate: value.windowless_frame_rate,
            standard_font_family: value.standard_font_family.into(),
            fixed_font_family: value.fixed_font_family.into(),
            serif_font_family: value.serif_font_family.into(),
            sans_serif_font_family: value.sans_serif_font_family.into(),
            cursive_font_family: value.cursive_font_family.into(),
            fantasy_font_family: value.fantasy_font_family.into(),
            default_font_size: value.default_font_size,
            default_fixed_font_size: value.default_fixed_font_size,
            minimum_font_size: value.minimum_font_size,
            minimum_logical_font_size: value.minimum_logical_font_size,
            default_encoding: value.default_encoding.into(),
            remote_fonts: value.remote_fonts.into(),
            javascript: value.javascript.into(),
            javascript_close_windows: value.javascript_close_windows.into(),
            javascript_access_clipboard: value.javascript_access_clipboard.into(),
            javascript_dom_paste: value.javascript_dom_paste.into(),
            image_loading: value.image_loading.into(),
            image_shrink_standalone_to_fit: value.image_shrink_standalone_to_fit.into(),
            text_area_resize: value.text_area_resize.into(),
            tab_to_links: value.tab_to_links.into(),
            local_storage: value.local_storage.into(),
            databases: value.databases.into(),
            webgl: value.webgl.into(),
            background_color: value.background_color,
            chrome_status_bubble: value.chrome_status_bubble.into(),
            chrome_zoom_bubble: value.chrome_zoom_bubble.into(),
        }
    }
}
impl From<BrowserSettings> for _cef_browser_settings_t {
    fn from(value: BrowserSettings) -> Self {
        Self {
            size: value.size,
            windowless_frame_rate: value.windowless_frame_rate,
            standard_font_family: value.standard_font_family.into(),
            fixed_font_family: value.fixed_font_family.into(),
            serif_font_family: value.serif_font_family.into(),
            sans_serif_font_family: value.sans_serif_font_family.into(),
            cursive_font_family: value.cursive_font_family.into(),
            fantasy_font_family: value.fantasy_font_family.into(),
            default_font_size: value.default_font_size,
            default_fixed_font_size: value.default_fixed_font_size,
            minimum_font_size: value.minimum_font_size,
            minimum_logical_font_size: value.minimum_logical_font_size,
            default_encoding: value.default_encoding.into(),
            remote_fonts: value.remote_fonts.into(),
            javascript: value.javascript.into(),
            javascript_close_windows: value.javascript_close_windows.into(),
            javascript_access_clipboard: value.javascript_access_clipboard.into(),
            javascript_dom_paste: value.javascript_dom_paste.into(),
            image_loading: value.image_loading.into(),
            image_shrink_standalone_to_fit: value.image_shrink_standalone_to_fit.into(),
            text_area_resize: value.text_area_resize.into(),
            tab_to_links: value.tab_to_links.into(),
            local_storage: value.local_storage.into(),
            databases: value.databases.into(),
            webgl: value.webgl.into(),
            background_color: value.background_color,
            chrome_status_bubble: value.chrome_status_bubble.into(),
            chrome_zoom_bubble: value.chrome_zoom_bubble.into(),
        }
    }
}
impl Default for BrowserSettings {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_browser_settings_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_urlparts_t`] for more documentation.
#[derive(Clone)]
pub struct Urlparts {
    pub size: usize,
    pub spec: CefString,
    pub scheme: CefString,
    pub username: CefString,
    pub password: CefString,
    pub host: CefString,
    pub port: CefString,
    pub origin: CefString,
    pub path: CefString,
    pub query: CefString,
    pub fragment: CefString,
}
impl From<_cef_urlparts_t> for Urlparts {
    fn from(value: _cef_urlparts_t) -> Self {
        Self {
            size: value.size,
            spec: value.spec.into(),
            scheme: value.scheme.into(),
            username: value.username.into(),
            password: value.password.into(),
            host: value.host.into(),
            port: value.port.into(),
            origin: value.origin.into(),
            path: value.path.into(),
            query: value.query.into(),
            fragment: value.fragment.into(),
        }
    }
}
impl From<Urlparts> for _cef_urlparts_t {
    fn from(value: Urlparts) -> Self {
        Self {
            size: value.size,
            spec: value.spec.into(),
            scheme: value.scheme.into(),
            username: value.username.into(),
            password: value.password.into(),
            host: value.host.into(),
            port: value.port.into(),
            origin: value.origin.into(),
            path: value.path.into(),
            query: value.query.into(),
            fragment: value.fragment.into(),
        }
    }
}
impl Default for Urlparts {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_urlparts_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_cookie_t`] for more documentation.
#[derive(Clone)]
pub struct Cookie {
    pub size: usize,
    pub name: CefString,
    pub value: CefString,
    pub domain: CefString,
    pub path: CefString,
    pub secure: ::std::os::raw::c_int,
    pub httponly: ::std::os::raw::c_int,
    pub creation: Basetime,
    pub last_access: Basetime,
    pub has_expires: ::std::os::raw::c_int,
    pub expires: Basetime,
    pub same_site: CookieSameSite,
    pub priority: CookiePriority,
}
impl From<_cef_cookie_t> for Cookie {
    fn from(value: _cef_cookie_t) -> Self {
        Self {
            size: value.size,
            name: value.name.into(),
            value: value.value.into(),
            domain: value.domain.into(),
            path: value.path.into(),
            secure: value.secure,
            httponly: value.httponly,
            creation: value.creation.into(),
            last_access: value.last_access.into(),
            has_expires: value.has_expires,
            expires: value.expires.into(),
            same_site: value.same_site.into(),
            priority: value.priority.into(),
        }
    }
}
impl From<Cookie> for _cef_cookie_t {
    fn from(value: Cookie) -> Self {
        Self {
            size: value.size,
            name: value.name.into(),
            value: value.value.into(),
            domain: value.domain.into(),
            path: value.path.into(),
            secure: value.secure,
            httponly: value.httponly,
            creation: value.creation.into(),
            last_access: value.last_access.into(),
            has_expires: value.has_expires,
            expires: value.expires.into(),
            same_site: value.same_site.into(),
            priority: value.priority.into(),
        }
    }
}
impl Default for Cookie {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_cookie_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_draggable_region_t`] for more documentation.
#[derive(Clone)]
pub struct DraggableRegion {
    pub bounds: Rect,
    pub draggable: ::std::os::raw::c_int,
}
impl From<_cef_draggable_region_t> for DraggableRegion {
    fn from(value: _cef_draggable_region_t) -> Self {
        Self {
            bounds: value.bounds.into(),
            draggable: value.draggable,
        }
    }
}
impl From<DraggableRegion> for _cef_draggable_region_t {
    fn from(value: DraggableRegion) -> Self {
        Self {
            bounds: value.bounds.into(),
            draggable: value.draggable,
        }
    }
}
impl Default for DraggableRegion {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_screen_info_t`] for more documentation.
#[derive(Clone)]
pub struct ScreenInfo {
    pub size: usize,
    pub device_scale_factor: f32,
    pub depth: ::std::os::raw::c_int,
    pub depth_per_component: ::std::os::raw::c_int,
    pub is_monochrome: ::std::os::raw::c_int,
    pub rect: Rect,
    pub available_rect: Rect,
}
impl From<_cef_screen_info_t> for ScreenInfo {
    fn from(value: _cef_screen_info_t) -> Self {
        Self {
            size: value.size,
            device_scale_factor: value.device_scale_factor,
            depth: value.depth,
            depth_per_component: value.depth_per_component,
            is_monochrome: value.is_monochrome,
            rect: value.rect.into(),
            available_rect: value.available_rect.into(),
        }
    }
}
impl From<ScreenInfo> for _cef_screen_info_t {
    fn from(value: ScreenInfo) -> Self {
        Self {
            size: value.size,
            device_scale_factor: value.device_scale_factor,
            depth: value.depth,
            depth_per_component: value.depth_per_component,
            is_monochrome: value.is_monochrome,
            rect: value.rect.into(),
            available_rect: value.available_rect.into(),
        }
    }
}
impl Default for ScreenInfo {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_screen_info_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_linux_window_properties_t`] for more documentation.
#[derive(Clone)]
pub struct LinuxWindowProperties {
    pub size: usize,
    pub wayland_app_id: CefString,
    pub wm_class_class: CefString,
    pub wm_class_name: CefString,
    pub wm_role_name: CefString,
}
impl From<_cef_linux_window_properties_t> for LinuxWindowProperties {
    fn from(value: _cef_linux_window_properties_t) -> Self {
        Self {
            size: value.size,
            wayland_app_id: value.wayland_app_id.into(),
            wm_class_class: value.wm_class_class.into(),
            wm_class_name: value.wm_class_name.into(),
            wm_role_name: value.wm_role_name.into(),
        }
    }
}
impl From<LinuxWindowProperties> for _cef_linux_window_properties_t {
    fn from(value: LinuxWindowProperties) -> Self {
        Self {
            size: value.size,
            wayland_app_id: value.wayland_app_id.into(),
            wm_class_class: value.wm_class_class.into(),
            wm_class_name: value.wm_class_name.into(),
            wm_role_name: value.wm_role_name.into(),
        }
    }
}
impl Default for LinuxWindowProperties {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_linux_window_properties_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_mouse_event_t`] for more documentation.
#[derive(Clone)]
pub struct MouseEvent {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub modifiers: u32,
}
impl From<_cef_mouse_event_t> for MouseEvent {
    fn from(value: _cef_mouse_event_t) -> Self {
        Self {
            x: value.x,
            y: value.y,
            modifiers: value.modifiers,
        }
    }
}
impl From<MouseEvent> for _cef_mouse_event_t {
    fn from(value: MouseEvent) -> Self {
        Self {
            x: value.x,
            y: value.y,
            modifiers: value.modifiers,
        }
    }
}
impl Default for MouseEvent {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_touch_event_t`] for more documentation.
#[derive(Clone)]
pub struct TouchEvent {
    pub id: ::std::os::raw::c_int,
    pub x: f32,
    pub y: f32,
    pub radius_x: f32,
    pub radius_y: f32,
    pub rotation_angle: f32,
    pub pressure: f32,
    pub type_: TouchEventType,
    pub modifiers: u32,
    pub pointer_type: PointerType,
}
impl From<_cef_touch_event_t> for TouchEvent {
    fn from(value: _cef_touch_event_t) -> Self {
        Self {
            id: value.id,
            x: value.x,
            y: value.y,
            radius_x: value.radius_x,
            radius_y: value.radius_y,
            rotation_angle: value.rotation_angle,
            pressure: value.pressure,
            type_: value.type_.into(),
            modifiers: value.modifiers,
            pointer_type: value.pointer_type.into(),
        }
    }
}
impl From<TouchEvent> for _cef_touch_event_t {
    fn from(value: TouchEvent) -> Self {
        Self {
            id: value.id,
            x: value.x,
            y: value.y,
            radius_x: value.radius_x,
            radius_y: value.radius_y,
            rotation_angle: value.rotation_angle,
            pressure: value.pressure,
            type_: value.type_.into(),
            modifiers: value.modifiers,
            pointer_type: value.pointer_type.into(),
        }
    }
}
impl Default for TouchEvent {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_key_event_t`] for more documentation.
#[derive(Clone)]
pub struct KeyEvent {
    pub size: usize,
    pub type_: KeyEventType,
    pub modifiers: u32,
    pub windows_key_code: ::std::os::raw::c_int,
    pub native_key_code: ::std::os::raw::c_int,
    pub is_system_key: ::std::os::raw::c_int,
    pub character: char16_t,
    pub unmodified_character: char16_t,
    pub focus_on_editable_field: ::std::os::raw::c_int,
}
impl From<_cef_key_event_t> for KeyEvent {
    fn from(value: _cef_key_event_t) -> Self {
        Self {
            size: value.size,
            type_: value.type_.into(),
            modifiers: value.modifiers,
            windows_key_code: value.windows_key_code,
            native_key_code: value.native_key_code,
            is_system_key: value.is_system_key,
            character: value.character,
            unmodified_character: value.unmodified_character,
            focus_on_editable_field: value.focus_on_editable_field,
        }
    }
}
impl From<KeyEvent> for _cef_key_event_t {
    fn from(value: KeyEvent) -> Self {
        Self {
            size: value.size,
            type_: value.type_.into(),
            modifiers: value.modifiers,
            windows_key_code: value.windows_key_code,
            native_key_code: value.native_key_code,
            is_system_key: value.is_system_key,
            character: value.character,
            unmodified_character: value.unmodified_character,
            focus_on_editable_field: value.focus_on_editable_field,
        }
    }
}
impl Default for KeyEvent {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_key_event_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_popup_features_t`] for more documentation.
#[derive(Clone)]
pub struct PopupFeatures {
    pub size: usize,
    pub x: ::std::os::raw::c_int,
    pub x_set: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub y_set: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub width_set: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub height_set: ::std::os::raw::c_int,
    pub is_popup: ::std::os::raw::c_int,
}
impl From<_cef_popup_features_t> for PopupFeatures {
    fn from(value: _cef_popup_features_t) -> Self {
        Self {
            size: value.size,
            x: value.x,
            x_set: value.xSet,
            y: value.y,
            y_set: value.ySet,
            width: value.width,
            width_set: value.widthSet,
            height: value.height,
            height_set: value.heightSet,
            is_popup: value.isPopup,
        }
    }
}
impl From<PopupFeatures> for _cef_popup_features_t {
    fn from(value: PopupFeatures) -> Self {
        Self {
            size: value.size,
            x: value.x,
            xSet: value.x_set,
            y: value.y,
            ySet: value.y_set,
            width: value.width,
            widthSet: value.width_set,
            height: value.height,
            heightSet: value.height_set,
            isPopup: value.is_popup,
        }
    }
}
impl Default for PopupFeatures {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_popup_features_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_cursor_info_t`] for more documentation.
#[derive(Clone)]
pub struct CursorInfo {
    pub hotspot: Point,
    pub image_scale_factor: f32,
    pub buffer: *mut ::std::os::raw::c_void,
    pub size: Size,
}
impl From<_cef_cursor_info_t> for CursorInfo {
    fn from(value: _cef_cursor_info_t) -> Self {
        Self {
            hotspot: value.hotspot.into(),
            image_scale_factor: value.image_scale_factor,
            buffer: value.buffer,
            size: value.size.into(),
        }
    }
}
impl From<CursorInfo> for _cef_cursor_info_t {
    fn from(value: CursorInfo) -> Self {
        Self {
            hotspot: value.hotspot.into(),
            image_scale_factor: value.image_scale_factor,
            buffer: value.buffer,
            size: value.size.into(),
        }
    }
}
impl Default for CursorInfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_pdf_print_settings_t`] for more documentation.
#[derive(Clone)]
pub struct PdfPrintSettings {
    pub size: usize,
    pub landscape: ::std::os::raw::c_int,
    pub print_background: ::std::os::raw::c_int,
    pub scale: f64,
    pub paper_width: f64,
    pub paper_height: f64,
    pub prefer_css_page_size: ::std::os::raw::c_int,
    pub margin_type: PdfPrintMarginType,
    pub margin_top: f64,
    pub margin_right: f64,
    pub margin_bottom: f64,
    pub margin_left: f64,
    pub page_ranges: CefString,
    pub display_header_footer: ::std::os::raw::c_int,
    pub header_template: CefString,
    pub footer_template: CefString,
    pub generate_tagged_pdf: ::std::os::raw::c_int,
    pub generate_document_outline: ::std::os::raw::c_int,
}
impl From<_cef_pdf_print_settings_t> for PdfPrintSettings {
    fn from(value: _cef_pdf_print_settings_t) -> Self {
        Self {
            size: value.size,
            landscape: value.landscape,
            print_background: value.print_background,
            scale: value.scale,
            paper_width: value.paper_width,
            paper_height: value.paper_height,
            prefer_css_page_size: value.prefer_css_page_size,
            margin_type: value.margin_type.into(),
            margin_top: value.margin_top,
            margin_right: value.margin_right,
            margin_bottom: value.margin_bottom,
            margin_left: value.margin_left,
            page_ranges: value.page_ranges.into(),
            display_header_footer: value.display_header_footer,
            header_template: value.header_template.into(),
            footer_template: value.footer_template.into(),
            generate_tagged_pdf: value.generate_tagged_pdf,
            generate_document_outline: value.generate_document_outline,
        }
    }
}
impl From<PdfPrintSettings> for _cef_pdf_print_settings_t {
    fn from(value: PdfPrintSettings) -> Self {
        Self {
            size: value.size,
            landscape: value.landscape,
            print_background: value.print_background,
            scale: value.scale,
            paper_width: value.paper_width,
            paper_height: value.paper_height,
            prefer_css_page_size: value.prefer_css_page_size,
            margin_type: value.margin_type.into(),
            margin_top: value.margin_top,
            margin_right: value.margin_right,
            margin_bottom: value.margin_bottom,
            margin_left: value.margin_left,
            page_ranges: value.page_ranges.into(),
            display_header_footer: value.display_header_footer,
            header_template: value.header_template.into(),
            footer_template: value.footer_template.into(),
            generate_tagged_pdf: value.generate_tagged_pdf,
            generate_document_outline: value.generate_document_outline,
        }
    }
}
impl Default for PdfPrintSettings {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_pdf_print_settings_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_box_layout_settings_t`] for more documentation.
#[derive(Clone)]
pub struct BoxLayoutSettings {
    pub size: usize,
    pub horizontal: ::std::os::raw::c_int,
    pub inside_border_horizontal_spacing: ::std::os::raw::c_int,
    pub inside_border_vertical_spacing: ::std::os::raw::c_int,
    pub inside_border_insets: Insets,
    pub between_child_spacing: ::std::os::raw::c_int,
    pub main_axis_alignment: AxisAlignment,
    pub cross_axis_alignment: AxisAlignment,
    pub minimum_cross_axis_size: ::std::os::raw::c_int,
    pub default_flex: ::std::os::raw::c_int,
}
impl From<_cef_box_layout_settings_t> for BoxLayoutSettings {
    fn from(value: _cef_box_layout_settings_t) -> Self {
        Self {
            size: value.size,
            horizontal: value.horizontal,
            inside_border_horizontal_spacing: value.inside_border_horizontal_spacing,
            inside_border_vertical_spacing: value.inside_border_vertical_spacing,
            inside_border_insets: value.inside_border_insets.into(),
            between_child_spacing: value.between_child_spacing,
            main_axis_alignment: value.main_axis_alignment.into(),
            cross_axis_alignment: value.cross_axis_alignment.into(),
            minimum_cross_axis_size: value.minimum_cross_axis_size,
            default_flex: value.default_flex,
        }
    }
}
impl From<BoxLayoutSettings> for _cef_box_layout_settings_t {
    fn from(value: BoxLayoutSettings) -> Self {
        Self {
            size: value.size,
            horizontal: value.horizontal,
            inside_border_horizontal_spacing: value.inside_border_horizontal_spacing,
            inside_border_vertical_spacing: value.inside_border_vertical_spacing,
            inside_border_insets: value.inside_border_insets.into(),
            between_child_spacing: value.between_child_spacing,
            main_axis_alignment: value.main_axis_alignment.into(),
            cross_axis_alignment: value.cross_axis_alignment.into(),
            minimum_cross_axis_size: value.minimum_cross_axis_size,
            default_flex: value.default_flex,
        }
    }
}
impl Default for BoxLayoutSettings {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_box_layout_settings_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_range_t`] for more documentation.
#[derive(Clone)]
pub struct Range {
    pub from: u32,
    pub to: u32,
}
impl From<_cef_range_t> for Range {
    fn from(value: _cef_range_t) -> Self {
        Self {
            from: value.from,
            to: value.to,
        }
    }
}
impl From<Range> for _cef_range_t {
    fn from(value: Range) -> Self {
        Self {
            from: value.from,
            to: value.to,
        }
    }
}
impl Default for Range {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_composition_underline_t`] for more documentation.
#[derive(Clone)]
pub struct CompositionUnderline {
    pub size: usize,
    pub range: Range,
    pub color: u32,
    pub background_color: u32,
    pub thick: ::std::os::raw::c_int,
    pub style: CompositionUnderlineStyle,
}
impl From<_cef_composition_underline_t> for CompositionUnderline {
    fn from(value: _cef_composition_underline_t) -> Self {
        Self {
            size: value.size,
            range: value.range.into(),
            color: value.color,
            background_color: value.background_color,
            thick: value.thick,
            style: value.style.into(),
        }
    }
}
impl From<CompositionUnderline> for _cef_composition_underline_t {
    fn from(value: CompositionUnderline) -> Self {
        Self {
            size: value.size,
            range: value.range.into(),
            color: value.color,
            background_color: value.background_color,
            thick: value.thick,
            style: value.style.into(),
        }
    }
}
impl Default for CompositionUnderline {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_composition_underline_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_audio_parameters_t`] for more documentation.
#[derive(Clone)]
pub struct AudioParameters {
    pub size: usize,
    pub channel_layout: ChannelLayout,
    pub sample_rate: ::std::os::raw::c_int,
    pub frames_per_buffer: ::std::os::raw::c_int,
}
impl From<_cef_audio_parameters_t> for AudioParameters {
    fn from(value: _cef_audio_parameters_t) -> Self {
        Self {
            size: value.size,
            channel_layout: value.channel_layout.into(),
            sample_rate: value.sample_rate,
            frames_per_buffer: value.frames_per_buffer,
        }
    }
}
impl From<AudioParameters> for _cef_audio_parameters_t {
    fn from(value: AudioParameters) -> Self {
        Self {
            size: value.size,
            channel_layout: value.channel_layout.into(),
            sample_rate: value.sample_rate,
            frames_per_buffer: value.frames_per_buffer,
        }
    }
}
impl Default for AudioParameters {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_audio_parameters_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_media_sink_device_info_t`] for more documentation.
#[derive(Clone)]
pub struct MediaSinkDeviceInfo {
    pub size: usize,
    pub ip_address: CefString,
    pub port: ::std::os::raw::c_int,
    pub model_name: CefString,
}
impl From<_cef_media_sink_device_info_t> for MediaSinkDeviceInfo {
    fn from(value: _cef_media_sink_device_info_t) -> Self {
        Self {
            size: value.size,
            ip_address: value.ip_address.into(),
            port: value.port,
            model_name: value.model_name.into(),
        }
    }
}
impl From<MediaSinkDeviceInfo> for _cef_media_sink_device_info_t {
    fn from(value: MediaSinkDeviceInfo) -> Self {
        Self {
            size: value.size,
            ip_address: value.ip_address.into(),
            port: value.port,
            model_name: value.model_name.into(),
        }
    }
}
impl Default for MediaSinkDeviceInfo {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_media_sink_device_info_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_touch_handle_state_t`] for more documentation.
#[derive(Clone)]
pub struct TouchHandleState {
    pub size: usize,
    pub touch_handle_id: ::std::os::raw::c_int,
    pub flags: u32,
    pub enabled: ::std::os::raw::c_int,
    pub orientation: HorizontalAlignment,
    pub mirror_vertical: ::std::os::raw::c_int,
    pub mirror_horizontal: ::std::os::raw::c_int,
    pub origin: Point,
    pub alpha: f32,
}
impl From<_cef_touch_handle_state_t> for TouchHandleState {
    fn from(value: _cef_touch_handle_state_t) -> Self {
        Self {
            size: value.size,
            touch_handle_id: value.touch_handle_id,
            flags: value.flags,
            enabled: value.enabled,
            orientation: value.orientation.into(),
            mirror_vertical: value.mirror_vertical,
            mirror_horizontal: value.mirror_horizontal,
            origin: value.origin.into(),
            alpha: value.alpha,
        }
    }
}
impl From<TouchHandleState> for _cef_touch_handle_state_t {
    fn from(value: TouchHandleState) -> Self {
        Self {
            size: value.size,
            touch_handle_id: value.touch_handle_id,
            flags: value.flags,
            enabled: value.enabled,
            orientation: value.orientation.into(),
            mirror_vertical: value.mirror_vertical,
            mirror_horizontal: value.mirror_horizontal,
            origin: value.origin.into(),
            alpha: value.alpha,
        }
    }
}
impl Default for TouchHandleState {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_touch_handle_state_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_task_info_t`] for more documentation.
#[derive(Clone)]
pub struct TaskInfo {
    pub size: usize,
    pub id: i64,
    pub type_: TaskType,
    pub is_killable: ::std::os::raw::c_int,
    pub title: CefString,
    pub cpu_usage: f64,
    pub number_of_processors: ::std::os::raw::c_int,
    pub memory: i64,
    pub gpu_memory: i64,
    pub is_gpu_memory_inflated: ::std::os::raw::c_int,
}
impl From<_cef_task_info_t> for TaskInfo {
    fn from(value: _cef_task_info_t) -> Self {
        Self {
            size: value.size,
            id: value.id,
            type_: value.type_.into(),
            is_killable: value.is_killable,
            title: value.title.into(),
            cpu_usage: value.cpu_usage,
            number_of_processors: value.number_of_processors,
            memory: value.memory,
            gpu_memory: value.gpu_memory,
            is_gpu_memory_inflated: value.is_gpu_memory_inflated,
        }
    }
}
impl From<TaskInfo> for _cef_task_info_t {
    fn from(value: TaskInfo) -> Self {
        Self {
            size: value.size,
            id: value.id,
            type_: value.type_.into(),
            is_killable: value.is_killable,
            title: value.title.into(),
            cpu_usage: value.cpu_usage,
            number_of_processors: value.number_of_processors,
            memory: value.memory,
            gpu_memory: value.gpu_memory,
            is_gpu_memory_inflated: value.is_gpu_memory_inflated,
        }
    }
}
impl Default for TaskInfo {
    fn default() -> Self {
        Self {
            size: std::mem::size_of::<_cef_task_info_t>(),
            ..unsafe { std::mem::zeroed() }
        }
    }
}

/// See [`_cef_base_ref_counted_t`] for more documentation.
#[derive(Clone)]
pub struct BaseRefCounted(RefGuard<_cef_base_ref_counted_t>);
impl BaseRefCounted {
    fn get_raw(&self) -> *mut _cef_base_ref_counted_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for BaseRefCounted {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_base_ref_counted_t> for &BaseRefCounted {
    fn into_raw(self) -> *mut _cef_base_ref_counted_t {
        self.get_raw()
    }
}
impl ConvertParam<*mut _cef_base_ref_counted_t> for &mut BaseRefCounted {
    fn into_raw(self) -> *mut _cef_base_ref_counted_t {
        self.get_raw()
    }
}
impl ConvertReturnValue<BaseRefCounted> for *mut _cef_base_ref_counted_t {
    fn wrap_result(self) -> BaseRefCounted {
        BaseRefCounted(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<BaseRefCounted> for *mut _cef_base_ref_counted_t {
    fn from(value: BaseRefCounted) -> Self {
        let object = value.get_raw();
        std::mem::forget(value);
        object
    }
}
impl Default for BaseRefCounted {
    fn default() -> Self {
        Self(unsafe { RefGuard::from_raw(std::ptr::null_mut()) })
    }
}

/// See [`_cef_base_scoped_t`] for more documentation.
#[derive(Clone, Copy)]
pub struct BaseScoped(*mut _cef_base_scoped_t);
impl BaseScoped {
    fn get_raw(&self) -> *mut _cef_base_scoped_t {
        self.0
    }
}
impl ConvertParam<*mut _cef_base_scoped_t> for &BaseScoped {
    fn into_raw(self) -> *mut _cef_base_scoped_t {
        self.get_raw()
    }
}
impl ConvertParam<*mut _cef_base_scoped_t> for &mut BaseScoped {
    fn into_raw(self) -> *mut _cef_base_scoped_t {
        self.get_raw()
    }
}
impl ConvertReturnValue<BaseScoped> for *mut _cef_base_scoped_t {
    fn wrap_result(self) -> BaseScoped {
        BaseScoped(self)
    }
}
impl From<BaseScoped> for *mut _cef_base_scoped_t {
    fn from(value: BaseScoped) -> Self {
        value.get_raw()
    }
}
impl Default for BaseScoped {
    fn default() -> Self {
        Self(std::ptr::null_mut())
    }
}

/// See [`_cef_dev_tools_message_observer_t`] for more documentation.
#[derive(Clone)]
pub struct DevToolsMessageObserver(RefGuard<_cef_dev_tools_message_observer_t>);
impl DevToolsMessageObserver {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDevToolsMessageObserver,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDevToolsMessageObserver>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDevToolsMessageObserver>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_dev_tools_message_observer_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapDevToolsMessageObserver: ImplDevToolsMessageObserver {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_dev_tools_message_observer_t, Self>);
}
pub trait ImplDevToolsMessageObserver: Clone + Sized + Rc {
    #[doc = "See [`_cef_dev_tools_message_observer_t::on_dev_tools_message`] for more documentation."]
    fn on_dev_tools_message(
        &self,
        browser: Option<&mut Browser>,
        message: Option<&[u8]>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_dev_tools_message_observer_t::on_dev_tools_method_result`] for more documentation."]
    fn on_dev_tools_method_result(
        &self,
        browser: Option<&mut Browser>,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: Option<&[u8]>,
    ) {
    }
    #[doc = "See [`_cef_dev_tools_message_observer_t::on_dev_tools_event`] for more documentation."]
    fn on_dev_tools_event(
        &self,
        browser: Option<&mut Browser>,
        method: Option<&CefString>,
        params: Option<&[u8]>,
    ) {
    }
    #[doc = "See [`_cef_dev_tools_message_observer_t::on_dev_tools_agent_attached`] for more documentation."]
    fn on_dev_tools_agent_attached(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_dev_tools_message_observer_t::on_dev_tools_agent_detached`] for more documentation."]
    fn on_dev_tools_agent_detached(&self, browser: Option<&mut Browser>) {}
    fn init_methods(object: &mut _cef_dev_tools_message_observer_t) {
        impl_cef_dev_tools_message_observer_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_dev_tools_message_observer_t;
}
mod impl_cef_dev_tools_message_observer_t {
    use super::*;
    pub fn init_methods<I: ImplDevToolsMessageObserver>(
        object: &mut _cef_dev_tools_message_observer_t,
    ) {
        object.on_dev_tools_message = Some(on_dev_tools_message::<I>);
        object.on_dev_tools_method_result = Some(on_dev_tools_method_result::<I>);
        object.on_dev_tools_event = Some(on_dev_tools_event::<I>);
        object.on_dev_tools_agent_attached = Some(on_dev_tools_agent_attached::<I>);
        object.on_dev_tools_agent_detached = Some(on_dev_tools_agent_detached::<I>);
    }
    extern "C" fn on_dev_tools_message<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_message, arg_message_size) =
            (self_, browser, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_message = (!arg_message.is_null() && arg_message_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts(arg_message.cast(), arg_message_size) });
        ImplDevToolsMessageObserver::on_dev_tools_message(
            &arg_self_.interface,
            arg_browser,
            arg_message,
        )
    }
    extern "C" fn on_dev_tools_method_result<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: *const ::std::os::raw::c_void,
        result_size: usize,
    ) {
        let (arg_self_, arg_browser, arg_message_id, arg_success, arg_result, arg_result_size) =
            (self_, browser, message_id, success, result, result_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_message_id = arg_message_id.into_raw();
        let arg_success = arg_success.into_raw();
        let arg_result = (!arg_result.is_null() && arg_result_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts(arg_result.cast(), arg_result_size) });
        ImplDevToolsMessageObserver::on_dev_tools_method_result(
            &arg_self_.interface,
            arg_browser,
            arg_message_id,
            arg_success,
            arg_result,
        )
    }
    extern "C" fn on_dev_tools_event<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
        method: *const cef_string_t,
        params: *const ::std::os::raw::c_void,
        params_size: usize,
    ) {
        let (arg_self_, arg_browser, arg_method, arg_params, arg_params_size) =
            (self_, browser, method, params, params_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_method = if arg_method.is_null() {
            None
        } else {
            Some(arg_method.into())
        };
        let arg_method = arg_method.as_ref();
        let arg_params = (!arg_params.is_null() && arg_params_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts(arg_params.cast(), arg_params_size) });
        ImplDevToolsMessageObserver::on_dev_tools_event(
            &arg_self_.interface,
            arg_browser,
            arg_method,
            arg_params,
        )
    }
    extern "C" fn on_dev_tools_agent_attached<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplDevToolsMessageObserver::on_dev_tools_agent_attached(&arg_self_.interface, arg_browser)
    }
    extern "C" fn on_dev_tools_agent_detached<I: ImplDevToolsMessageObserver>(
        self_: *mut _cef_dev_tools_message_observer_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplDevToolsMessageObserver::on_dev_tools_agent_detached(&arg_self_.interface, arg_browser)
    }
}
impl ImplDevToolsMessageObserver for DevToolsMessageObserver {
    fn on_dev_tools_message(
        &self,
        browser: Option<&mut Browser>,
        message: Option<&[u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_dev_tools_message
                .map(|f| {
                    let (arg_browser, arg_message) = (browser, message);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_message_size = arg_message
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_message = arg_message
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_message, arg_message_size);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_dev_tools_method_result(
        &self,
        browser: Option<&mut Browser>,
        message_id: ::std::os::raw::c_int,
        success: ::std::os::raw::c_int,
        result: Option<&[u8]>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_dev_tools_method_result {
                let (arg_browser, arg_message_id, arg_success, arg_result) =
                    (browser, message_id, success, result);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_result_size = arg_result.as_ref().map(|arg| arg.len()).unwrap_or_default();
                let arg_result = arg_result
                    .and_then(|arg| {
                        if arg.is_empty() {
                            None
                        } else {
                            Some(arg.as_ptr().cast())
                        }
                    })
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_message_id,
                    arg_success,
                    arg_result,
                    arg_result_size,
                );
            }
        }
    }
    fn on_dev_tools_event(
        &self,
        browser: Option<&mut Browser>,
        method: Option<&CefString>,
        params: Option<&[u8]>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_dev_tools_event {
                let (arg_browser, arg_method, arg_params) = (browser, method, params);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_method = arg_method
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_params_size = arg_params.as_ref().map(|arg| arg.len()).unwrap_or_default();
                let arg_params = arg_params
                    .and_then(|arg| {
                        if arg.is_empty() {
                            None
                        } else {
                            Some(arg.as_ptr().cast())
                        }
                    })
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_method,
                    arg_params,
                    arg_params_size,
                );
            }
        }
    }
    fn on_dev_tools_agent_attached(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_dev_tools_agent_attached {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn on_dev_tools_agent_detached(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_dev_tools_agent_detached {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_dev_tools_message_observer_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_dev_tools_message_observer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DevToolsMessageObserver {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dev_tools_message_observer_t> for &DevToolsMessageObserver {
    fn into_raw(self) -> *mut _cef_dev_tools_message_observer_t {
        ImplDevToolsMessageObserver::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_dev_tools_message_observer_t> for &mut DevToolsMessageObserver {
    fn into_raw(self) -> *mut _cef_dev_tools_message_observer_t {
        ImplDevToolsMessageObserver::get_raw(self)
    }
}
impl ConvertReturnValue<DevToolsMessageObserver> for *mut _cef_dev_tools_message_observer_t {
    fn wrap_result(self) -> DevToolsMessageObserver {
        DevToolsMessageObserver(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DevToolsMessageObserver> for *mut _cef_dev_tools_message_observer_t {
    fn from(value: DevToolsMessageObserver) -> Self {
        let object = ImplDevToolsMessageObserver::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DevToolsMessageObserver {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_value_t`] for more documentation.
#[derive(Clone)]
pub struct Value(RefGuard<_cef_value_t>);
pub trait ImplValue: Clone + Sized + Rc {
    #[doc = "See [`_cef_value_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::is_owned`] for more documentation."]
    fn is_owned(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut Value>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::is_equal`] for more documentation."]
    fn is_equal(&self, that: Option<&mut Value>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::copy`] for more documentation."]
    fn copy(&self) -> Option<Value>;
    #[doc = "See [`_cef_value_t::get_type`] for more documentation."]
    fn get_type(&self) -> ValueType;
    #[doc = "See [`_cef_value_t::get_bool`] for more documentation."]
    fn bool(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::get_int`] for more documentation."]
    fn int(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::get_double`] for more documentation."]
    fn double(&self) -> f64;
    #[doc = "See [`_cef_value_t::get_string`] for more documentation."]
    fn string(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_value_t::get_binary`] for more documentation."]
    fn binary(&self) -> Option<BinaryValue>;
    #[doc = "See [`_cef_value_t::get_dictionary`] for more documentation."]
    fn dictionary(&self) -> Option<DictionaryValue>;
    #[doc = "See [`_cef_value_t::get_list`] for more documentation."]
    fn list(&self) -> Option<ListValue>;
    #[doc = "See [`_cef_value_t::set_null`] for more documentation."]
    fn set_null(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::set_bool`] for more documentation."]
    fn set_bool(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::set_int`] for more documentation."]
    fn set_int(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::set_double`] for more documentation."]
    fn set_double(&self, value: f64) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::set_string`] for more documentation."]
    fn set_string(&self, value: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::set_binary`] for more documentation."]
    fn set_binary(&self, value: Option<&mut BinaryValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::set_dictionary`] for more documentation."]
    fn set_dictionary(&self, value: Option<&mut DictionaryValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_value_t::set_list`] for more documentation."]
    fn set_list(&self, value: Option<&mut ListValue>) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_value_t;
}
impl ImplValue for Value {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut Value>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_equal(&self, that: Option<&mut Value>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<Value> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_type(&self) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn bool(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn int(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn double(&self) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn string(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn binary(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn dictionary(&self) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn list(&self) -> Option<ListValue> {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_null(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_bool(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_int(&self, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_double(&self, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_string(&self, value: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_binary(&self, value: Option<&mut BinaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_dictionary(&self, value: Option<&mut DictionaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_list(&self, value: Option<&mut ListValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_value_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Value {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_value_t> for &Value {
    fn into_raw(self) -> *mut _cef_value_t {
        ImplValue::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_value_t> for &mut Value {
    fn into_raw(self) -> *mut _cef_value_t {
        ImplValue::get_raw(self)
    }
}
impl ConvertReturnValue<Value> for *mut _cef_value_t {
    fn wrap_result(self) -> Value {
        Value(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Value> for *mut _cef_value_t {
    fn from(value: Value) -> Self {
        let object = ImplValue::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Value {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_binary_value_t`] for more documentation.
#[derive(Clone)]
pub struct BinaryValue(RefGuard<_cef_binary_value_t>);
pub trait ImplBinaryValue: Clone + Sized + Rc {
    #[doc = "See [`_cef_binary_value_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_binary_value_t::is_owned`] for more documentation."]
    fn is_owned(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_binary_value_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut BinaryValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_binary_value_t::is_equal`] for more documentation."]
    fn is_equal(&self, that: Option<&mut BinaryValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_binary_value_t::copy`] for more documentation."]
    fn copy(&self) -> Option<BinaryValue>;
    #[doc = "See [`_cef_binary_value_t::get_raw_data`] for more documentation."]
    fn raw_data(&self) -> *const ::std::os::raw::c_void;
    #[doc = "See [`_cef_binary_value_t::get_size`] for more documentation."]
    fn size(&self) -> usize;
    #[doc = "See [`_cef_binary_value_t::get_data`] for more documentation."]
    fn data(&self, buffer: Option<&mut Vec<u8>>, data_offset: usize) -> usize;
    fn get_raw(&self) -> *mut _cef_binary_value_t;
}
impl ImplBinaryValue for BinaryValue {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut BinaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_equal(&self, that: Option<&mut BinaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn raw_data(&self) -> *const ::std::os::raw::c_void {
        unsafe {
            self.0
                .get_raw_data
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn size(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn data(&self, buffer: Option<&mut Vec<u8>>, data_offset: usize) -> usize {
        unsafe {
            self.0
                .get_data
                .map(|f| {
                    let (arg_buffer, arg_data_offset) = (buffer, data_offset);
                    let arg_self_ = self.into_raw();
                    let arg_buffer_size =
                        arg_buffer.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let mut out_buffer = arg_buffer;
                    let arg_buffer = out_buffer
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_buffer, arg_buffer_size, arg_data_offset);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_binary_value_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_binary_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BinaryValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_binary_value_t> for &BinaryValue {
    fn into_raw(self) -> *mut _cef_binary_value_t {
        ImplBinaryValue::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_binary_value_t> for &mut BinaryValue {
    fn into_raw(self) -> *mut _cef_binary_value_t {
        ImplBinaryValue::get_raw(self)
    }
}
impl ConvertReturnValue<BinaryValue> for *mut _cef_binary_value_t {
    fn wrap_result(self) -> BinaryValue {
        BinaryValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<BinaryValue> for *mut _cef_binary_value_t {
    fn from(value: BinaryValue) -> Self {
        let object = ImplBinaryValue::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for BinaryValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_dictionary_value_t`] for more documentation.
#[derive(Clone)]
pub struct DictionaryValue(RefGuard<_cef_dictionary_value_t>);
pub trait ImplDictionaryValue: Clone + Sized + Rc {
    #[doc = "See [`_cef_dictionary_value_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::is_owned`] for more documentation."]
    fn is_owned(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut DictionaryValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::is_equal`] for more documentation."]
    fn is_equal(&self, that: Option<&mut DictionaryValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::copy`] for more documentation."]
    fn copy(&self, exclude_empty_children: ::std::os::raw::c_int) -> Option<DictionaryValue>;
    #[doc = "See [`_cef_dictionary_value_t::get_size`] for more documentation."]
    fn size(&self) -> usize;
    #[doc = "See [`_cef_dictionary_value_t::clear`] for more documentation."]
    fn clear(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::has_key`] for more documentation."]
    fn has_key(&self, key: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::get_keys`] for more documentation."]
    fn keys(&self, keys: Option<&mut CefStringList>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::remove`] for more documentation."]
    fn remove(&self, key: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::get_type`] for more documentation."]
    fn get_type(&self, key: Option<&CefString>) -> ValueType;
    #[doc = "See [`_cef_dictionary_value_t::get_value`] for more documentation."]
    fn value(&self, key: Option<&CefString>) -> Option<Value>;
    #[doc = "See [`_cef_dictionary_value_t::get_bool`] for more documentation."]
    fn bool(&self, key: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::get_int`] for more documentation."]
    fn int(&self, key: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::get_double`] for more documentation."]
    fn double(&self, key: Option<&CefString>) -> f64;
    #[doc = "See [`_cef_dictionary_value_t::get_string`] for more documentation."]
    fn string(&self, key: Option<&CefString>) -> CefStringUserfree;
    #[doc = "See [`_cef_dictionary_value_t::get_binary`] for more documentation."]
    fn binary(&self, key: Option<&CefString>) -> Option<BinaryValue>;
    #[doc = "See [`_cef_dictionary_value_t::get_dictionary`] for more documentation."]
    fn dictionary(&self, key: Option<&CefString>) -> Option<DictionaryValue>;
    #[doc = "See [`_cef_dictionary_value_t::get_list`] for more documentation."]
    fn list(&self, key: Option<&CefString>) -> Option<ListValue>;
    #[doc = "See [`_cef_dictionary_value_t::set_value`] for more documentation."]
    fn set_value(
        &self,
        key: Option<&CefString>,
        value: Option<&mut Value>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::set_null`] for more documentation."]
    fn set_null(&self, key: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::set_bool`] for more documentation."]
    fn set_bool(
        &self,
        key: Option<&CefString>,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::set_int`] for more documentation."]
    fn set_int(
        &self,
        key: Option<&CefString>,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::set_double`] for more documentation."]
    fn set_double(&self, key: Option<&CefString>, value: f64) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::set_string`] for more documentation."]
    fn set_string(
        &self,
        key: Option<&CefString>,
        value: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::set_binary`] for more documentation."]
    fn set_binary(
        &self,
        key: Option<&CefString>,
        value: Option<&mut BinaryValue>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::set_dictionary`] for more documentation."]
    fn set_dictionary(
        &self,
        key: Option<&CefString>,
        value: Option<&mut DictionaryValue>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_dictionary_value_t::set_list`] for more documentation."]
    fn set_list(
        &self,
        key: Option<&CefString>,
        value: Option<&mut ListValue>,
    ) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_dictionary_value_t;
}
impl ImplDictionaryValue for DictionaryValue {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut DictionaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_equal(&self, that: Option<&mut DictionaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self, exclude_empty_children: ::std::os::raw::c_int) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_exclude_empty_children = exclude_empty_children;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_exclude_empty_children);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn size(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_key(&self, key: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_key
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn keys(&self, keys: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_keys
                .map(|f| {
                    let arg_keys = keys;
                    let arg_self_ = self.into_raw();
                    let arg_keys = arg_keys
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_keys);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn remove(&self, key: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_type(&self, key: Option<&CefString>) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn value(&self, key: Option<&CefString>) -> Option<Value> {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn bool(&self, key: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn int(&self, key: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn double(&self, key: Option<&CefString>) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn string(&self, key: Option<&CefString>) -> CefStringUserfree {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn binary(&self, key: Option<&CefString>) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn dictionary(&self, key: Option<&CefString>) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn list(&self, key: Option<&CefString>) -> Option<ListValue> {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_value(
        &self,
        key: Option<&CefString>,
        value: Option<&mut Value>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_null(&self, key: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_bool(
        &self,
        key: Option<&CefString>,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_int(
        &self,
        key: Option<&CefString>,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_double(&self, key: Option<&CefString>, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_string(
        &self,
        key: Option<&CefString>,
        value: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_binary(
        &self,
        key: Option<&CefString>,
        value: Option<&mut BinaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_dictionary(
        &self,
        key: Option<&CefString>,
        value: Option<&mut DictionaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_list(
        &self,
        key: Option<&CefString>,
        value: Option<&mut ListValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let (arg_key, arg_value) = (key, value);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_key, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_dictionary_value_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_dictionary_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DictionaryValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dictionary_value_t> for &DictionaryValue {
    fn into_raw(self) -> *mut _cef_dictionary_value_t {
        ImplDictionaryValue::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_dictionary_value_t> for &mut DictionaryValue {
    fn into_raw(self) -> *mut _cef_dictionary_value_t {
        ImplDictionaryValue::get_raw(self)
    }
}
impl ConvertReturnValue<DictionaryValue> for *mut _cef_dictionary_value_t {
    fn wrap_result(self) -> DictionaryValue {
        DictionaryValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DictionaryValue> for *mut _cef_dictionary_value_t {
    fn from(value: DictionaryValue) -> Self {
        let object = ImplDictionaryValue::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DictionaryValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_list_value_t`] for more documentation.
#[derive(Clone)]
pub struct ListValue(RefGuard<_cef_list_value_t>);
pub trait ImplListValue: Clone + Sized + Rc {
    #[doc = "See [`_cef_list_value_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::is_owned`] for more documentation."]
    fn is_owned(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut ListValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::is_equal`] for more documentation."]
    fn is_equal(&self, that: Option<&mut ListValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::copy`] for more documentation."]
    fn copy(&self) -> Option<ListValue>;
    #[doc = "See [`_cef_list_value_t::set_size`] for more documentation."]
    fn set_size(&self, size: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::get_size`] for more documentation."]
    fn size(&self) -> usize;
    #[doc = "See [`_cef_list_value_t::clear`] for more documentation."]
    fn clear(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::remove`] for more documentation."]
    fn remove(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::get_type`] for more documentation."]
    fn get_type(&self, index: usize) -> ValueType;
    #[doc = "See [`_cef_list_value_t::get_value`] for more documentation."]
    fn value(&self, index: usize) -> Option<Value>;
    #[doc = "See [`_cef_list_value_t::get_bool`] for more documentation."]
    fn bool(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::get_int`] for more documentation."]
    fn int(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::get_double`] for more documentation."]
    fn double(&self, index: usize) -> f64;
    #[doc = "See [`_cef_list_value_t::get_string`] for more documentation."]
    fn string(&self, index: usize) -> CefStringUserfree;
    #[doc = "See [`_cef_list_value_t::get_binary`] for more documentation."]
    fn binary(&self, index: usize) -> Option<BinaryValue>;
    #[doc = "See [`_cef_list_value_t::get_dictionary`] for more documentation."]
    fn dictionary(&self, index: usize) -> Option<DictionaryValue>;
    #[doc = "See [`_cef_list_value_t::get_list`] for more documentation."]
    fn list(&self, index: usize) -> Option<ListValue>;
    #[doc = "See [`_cef_list_value_t::set_value`] for more documentation."]
    fn set_value(&self, index: usize, value: Option<&mut Value>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::set_null`] for more documentation."]
    fn set_null(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::set_bool`] for more documentation."]
    fn set_bool(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::set_int`] for more documentation."]
    fn set_int(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::set_double`] for more documentation."]
    fn set_double(&self, index: usize, value: f64) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::set_string`] for more documentation."]
    fn set_string(&self, index: usize, value: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::set_binary`] for more documentation."]
    fn set_binary(&self, index: usize, value: Option<&mut BinaryValue>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::set_dictionary`] for more documentation."]
    fn set_dictionary(
        &self,
        index: usize,
        value: Option<&mut DictionaryValue>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_list_value_t::set_list`] for more documentation."]
    fn set_list(&self, index: usize, value: Option<&mut ListValue>) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_list_value_t;
}
impl ImplListValue for ListValue {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_owned(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_owned
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut ListValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_equal(&self, that: Option<&mut ListValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_equal
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<ListValue> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_size(&self, size: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_size
                .map(|f| {
                    let arg_size = size;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_size);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn size(&self) -> usize {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn remove(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_type(&self, index: usize) -> ValueType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn value(&self, index: usize) -> Option<Value> {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn bool(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn int(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_int
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn double(&self, index: usize) -> f64 {
        unsafe {
            self.0
                .get_double
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn string(&self, index: usize) -> CefStringUserfree {
        unsafe {
            self.0
                .get_string
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn binary(&self, index: usize) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_binary
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn dictionary(&self, index: usize) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .get_dictionary
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn list(&self, index: usize) -> Option<ListValue> {
        unsafe {
            self.0
                .get_list
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_value(&self, index: usize, value: Option<&mut Value>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_null(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_null
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_bool(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_bool
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_int(&self, index: usize, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_int
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_double(&self, index: usize, value: f64) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_double
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_string(&self, index: usize, value: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_string
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_binary(&self, index: usize, value: Option<&mut BinaryValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_binary
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplBinaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_dictionary(
        &self,
        index: usize,
        value: Option<&mut DictionaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_dictionary
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_list(&self, index: usize, value: Option<&mut ListValue>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_list
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplListValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_list_value_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_list_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ListValue {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_list_value_t> for &ListValue {
    fn into_raw(self) -> *mut _cef_list_value_t {
        ImplListValue::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_list_value_t> for &mut ListValue {
    fn into_raw(self) -> *mut _cef_list_value_t {
        ImplListValue::get_raw(self)
    }
}
impl ConvertReturnValue<ListValue> for *mut _cef_list_value_t {
    fn wrap_result(self) -> ListValue {
        ListValue(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ListValue> for *mut _cef_list_value_t {
    fn from(value: ListValue) -> Self {
        let object = ImplListValue::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ListValue {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_image_t`] for more documentation.
#[derive(Clone)]
pub struct Image(RefGuard<_cef_image_t>);
pub trait ImplImage: Clone + Sized + Rc {
    #[doc = "See [`_cef_image_t::is_empty`] for more documentation."]
    fn is_empty(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_image_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut Image>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_image_t::add_bitmap`] for more documentation."]
    fn add_bitmap(
        &self,
        scale_factor: f32,
        pixel_width: ::std::os::raw::c_int,
        pixel_height: ::std::os::raw::c_int,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_data: Option<&[u8]>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_image_t::add_png`] for more documentation."]
    fn add_png(&self, scale_factor: f32, png_data: Option<&[u8]>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_image_t::add_jpeg`] for more documentation."]
    fn add_jpeg(&self, scale_factor: f32, jpeg_data: Option<&[u8]>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_image_t::get_width`] for more documentation."]
    fn width(&self) -> usize;
    #[doc = "See [`_cef_image_t::get_height`] for more documentation."]
    fn height(&self) -> usize;
    #[doc = "See [`_cef_image_t::has_representation`] for more documentation."]
    fn has_representation(&self, scale_factor: f32) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_image_t::remove_representation`] for more documentation."]
    fn remove_representation(&self, scale_factor: f32) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_image_t::get_representation_info`] for more documentation."]
    fn representation_info(
        &self,
        scale_factor: f32,
        actual_scale_factor: Option<&mut f32>,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_image_t::get_as_bitmap`] for more documentation."]
    fn as_bitmap(
        &self,
        scale_factor: f32,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue>;
    #[doc = "See [`_cef_image_t::get_as_png`] for more documentation."]
    fn as_png(
        &self,
        scale_factor: f32,
        with_transparency: ::std::os::raw::c_int,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue>;
    #[doc = "See [`_cef_image_t::get_as_jpeg`] for more documentation."]
    fn as_jpeg(
        &self,
        scale_factor: f32,
        quality: ::std::os::raw::c_int,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue>;
    fn get_raw(&self) -> *mut _cef_image_t;
}
impl ImplImage for Image {
    fn is_empty(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_empty
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut Image>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplImage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_bitmap(
        &self,
        scale_factor: f32,
        pixel_width: ::std::os::raw::c_int,
        pixel_height: ::std::os::raw::c_int,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_data: Option<&[u8]>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_bitmap
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_data,
                    ) = (
                        scale_factor,
                        pixel_width,
                        pixel_height,
                        color_type,
                        alpha_type,
                        pixel_data,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_color_type = arg_color_type.into_raw();
                    let arg_alpha_type = arg_alpha_type.into_raw();
                    let arg_pixel_data_size = arg_pixel_data
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_pixel_data = arg_pixel_data
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_data,
                        arg_pixel_data_size,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_png(&self, scale_factor: f32, png_data: Option<&[u8]>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_png
                .map(|f| {
                    let (arg_scale_factor, arg_png_data) = (scale_factor, png_data);
                    let arg_self_ = self.into_raw();
                    let arg_png_data_size = arg_png_data
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_png_data = arg_png_data
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_scale_factor, arg_png_data, arg_png_data_size);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_jpeg(&self, scale_factor: f32, jpeg_data: Option<&[u8]>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_jpeg
                .map(|f| {
                    let (arg_scale_factor, arg_jpeg_data) = (scale_factor, jpeg_data);
                    let arg_self_ = self.into_raw();
                    let arg_jpeg_data_size = arg_jpeg_data
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_jpeg_data = arg_jpeg_data
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_jpeg_data,
                        arg_jpeg_data_size,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn width(&self) -> usize {
        unsafe {
            self.0
                .get_width
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn height(&self) -> usize {
        unsafe {
            self.0
                .get_height
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_representation(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_representation
                .map(|f| {
                    let arg_scale_factor = scale_factor;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_scale_factor);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn remove_representation(&self, scale_factor: f32) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_representation
                .map(|f| {
                    let arg_scale_factor = scale_factor;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_scale_factor);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn representation_info(
        &self,
        scale_factor: f32,
        actual_scale_factor: Option<&mut f32>,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_representation_info
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_actual_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (scale_factor, actual_scale_factor, pixel_width, pixel_height);
                    let arg_self_ = self.into_raw();
                    let arg_actual_scale_factor = arg_actual_scale_factor
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_width = arg_pixel_width
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_height = arg_pixel_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_actual_scale_factor,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn as_bitmap(
        &self,
        scale_factor: f32,
        color_type: ColorType,
        alpha_type: AlphaType,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_as_bitmap
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (
                        scale_factor,
                        color_type,
                        alpha_type,
                        pixel_width,
                        pixel_height,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_color_type = arg_color_type.into_raw();
                    let arg_alpha_type = arg_alpha_type.into_raw();
                    let arg_pixel_width = arg_pixel_width
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_height = arg_pixel_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_color_type,
                        arg_alpha_type,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_png(
        &self,
        scale_factor: f32,
        with_transparency: ::std::os::raw::c_int,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_as_png
                .map(|f| {
                    let (
                        arg_scale_factor,
                        arg_with_transparency,
                        arg_pixel_width,
                        arg_pixel_height,
                    ) = (scale_factor, with_transparency, pixel_width, pixel_height);
                    let arg_self_ = self.into_raw();
                    let arg_pixel_width = arg_pixel_width
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_height = arg_pixel_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_with_transparency,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_jpeg(
        &self,
        scale_factor: f32,
        quality: ::std::os::raw::c_int,
        pixel_width: Option<&mut ::std::os::raw::c_int>,
        pixel_height: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_as_jpeg
                .map(|f| {
                    let (arg_scale_factor, arg_quality, arg_pixel_width, arg_pixel_height) =
                        (scale_factor, quality, pixel_width, pixel_height);
                    let arg_self_ = self.into_raw();
                    let arg_pixel_width = arg_pixel_width
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_pixel_height = arg_pixel_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_scale_factor,
                        arg_quality,
                        arg_pixel_width,
                        arg_pixel_height,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_image_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_image_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Image {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_image_t> for &Image {
    fn into_raw(self) -> *mut _cef_image_t {
        ImplImage::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_image_t> for &mut Image {
    fn into_raw(self) -> *mut _cef_image_t {
        ImplImage::get_raw(self)
    }
}
impl ConvertReturnValue<Image> for *mut _cef_image_t {
    fn wrap_result(self) -> Image {
        Image(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Image> for *mut _cef_image_t {
    fn from(value: Image) -> Self {
        let object = ImplImage::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Image {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_read_handler_t`] for more documentation.
#[derive(Clone)]
pub struct ReadHandler(RefGuard<_cef_read_handler_t>);
impl ReadHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapReadHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplReadHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapReadHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_read_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapReadHandler: ImplReadHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_read_handler_t, Self>);
}
pub trait ImplReadHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_read_handler_t::read`] for more documentation."]
    fn read(&self, ptr: *mut u8, size: usize, n: usize) -> usize {
        Default::default()
    }
    #[doc = "See [`_cef_read_handler_t::seek`] for more documentation."]
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_read_handler_t::tell`] for more documentation."]
    fn tell(&self) -> i64 {
        Default::default()
    }
    #[doc = "See [`_cef_read_handler_t::eof`] for more documentation."]
    fn eof(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_read_handler_t::may_block`] for more documentation."]
    fn may_block(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_read_handler_t) {
        impl_cef_read_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_read_handler_t;
}
mod impl_cef_read_handler_t {
    use super::*;
    pub fn init_methods<I: ImplReadHandler>(object: &mut _cef_read_handler_t) {
        object.read = Some(read::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.eof = Some(eof::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn read<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_ptr = arg_ptr.cast();
        let arg_size = arg_size.into_raw();
        let arg_n = arg_n.into_raw();
        ImplReadHandler::read(&arg_self_.interface, arg_ptr, arg_size, arg_n)
    }
    extern "C" fn seek<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.into_raw();
        let arg_whence = arg_whence.into_raw();
        ImplReadHandler::seek(&arg_self_.interface, arg_offset, arg_whence)
    }
    extern "C" fn tell<I: ImplReadHandler>(self_: *mut _cef_read_handler_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplReadHandler::tell(&arg_self_.interface)
    }
    extern "C" fn eof<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplReadHandler::eof(&arg_self_.interface)
    }
    extern "C" fn may_block<I: ImplReadHandler>(
        self_: *mut _cef_read_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplReadHandler::may_block(&arg_self_.interface)
    }
}
impl ImplReadHandler for ReadHandler {
    fn read(&self, ptr: *mut u8, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.into_raw();
                    let arg_ptr = arg_ptr.cast();
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn tell(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn eof(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eof
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_read_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_read_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ReadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_read_handler_t> for &ReadHandler {
    fn into_raw(self) -> *mut _cef_read_handler_t {
        ImplReadHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_read_handler_t> for &mut ReadHandler {
    fn into_raw(self) -> *mut _cef_read_handler_t {
        ImplReadHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ReadHandler> for *mut _cef_read_handler_t {
    fn wrap_result(self) -> ReadHandler {
        ReadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ReadHandler> for *mut _cef_read_handler_t {
    fn from(value: ReadHandler) -> Self {
        let object = ImplReadHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ReadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_stream_reader_t`] for more documentation.
#[derive(Clone)]
pub struct StreamReader(RefGuard<_cef_stream_reader_t>);
pub trait ImplStreamReader: Clone + Sized + Rc {
    #[doc = "See [`_cef_stream_reader_t::read`] for more documentation."]
    fn read(&self, ptr: *mut u8, size: usize, n: usize) -> usize;
    #[doc = "See [`_cef_stream_reader_t::seek`] for more documentation."]
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_stream_reader_t::tell`] for more documentation."]
    fn tell(&self) -> i64;
    #[doc = "See [`_cef_stream_reader_t::eof`] for more documentation."]
    fn eof(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_stream_reader_t::may_block`] for more documentation."]
    fn may_block(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_stream_reader_t;
}
impl ImplStreamReader for StreamReader {
    fn read(&self, ptr: *mut u8, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.into_raw();
                    let arg_ptr = arg_ptr.cast();
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn tell(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn eof(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eof
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_stream_reader_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_stream_reader_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for StreamReader {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_stream_reader_t> for &StreamReader {
    fn into_raw(self) -> *mut _cef_stream_reader_t {
        ImplStreamReader::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_stream_reader_t> for &mut StreamReader {
    fn into_raw(self) -> *mut _cef_stream_reader_t {
        ImplStreamReader::get_raw(self)
    }
}
impl ConvertReturnValue<StreamReader> for *mut _cef_stream_reader_t {
    fn wrap_result(self) -> StreamReader {
        StreamReader(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<StreamReader> for *mut _cef_stream_reader_t {
    fn from(value: StreamReader) -> Self {
        let object = ImplStreamReader::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for StreamReader {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_write_handler_t`] for more documentation.
#[derive(Clone)]
pub struct WriteHandler(RefGuard<_cef_write_handler_t>);
impl WriteHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapWriteHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplWriteHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapWriteHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_write_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapWriteHandler: ImplWriteHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_write_handler_t, Self>);
}
pub trait ImplWriteHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_write_handler_t::write`] for more documentation."]
    fn write(&self, ptr: *const u8, size: usize, n: usize) -> usize {
        Default::default()
    }
    #[doc = "See [`_cef_write_handler_t::seek`] for more documentation."]
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_write_handler_t::tell`] for more documentation."]
    fn tell(&self) -> i64 {
        Default::default()
    }
    #[doc = "See [`_cef_write_handler_t::flush`] for more documentation."]
    fn flush(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_write_handler_t::may_block`] for more documentation."]
    fn may_block(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_write_handler_t) {
        impl_cef_write_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_write_handler_t;
}
mod impl_cef_write_handler_t {
    use super::*;
    pub fn init_methods<I: ImplWriteHandler>(object: &mut _cef_write_handler_t) {
        object.write = Some(write::<I>);
        object.seek = Some(seek::<I>);
        object.tell = Some(tell::<I>);
        object.flush = Some(flush::<I>);
        object.may_block = Some(may_block::<I>);
    }
    extern "C" fn write<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        n: usize,
    ) -> usize {
        let (arg_self_, arg_ptr, arg_size, arg_n) = (self_, ptr, size, n);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_ptr = arg_ptr.cast();
        let arg_size = arg_size.into_raw();
        let arg_n = arg_n.into_raw();
        ImplWriteHandler::write(&arg_self_.interface, arg_ptr, arg_size, arg_n)
    }
    extern "C" fn seek<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_offset, arg_whence) = (self_, offset, whence);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_offset = arg_offset.into_raw();
        let arg_whence = arg_whence.into_raw();
        ImplWriteHandler::seek(&arg_self_.interface, arg_offset, arg_whence)
    }
    extern "C" fn tell<I: ImplWriteHandler>(self_: *mut _cef_write_handler_t) -> i64 {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplWriteHandler::tell(&arg_self_.interface)
    }
    extern "C" fn flush<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplWriteHandler::flush(&arg_self_.interface)
    }
    extern "C" fn may_block<I: ImplWriteHandler>(
        self_: *mut _cef_write_handler_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplWriteHandler::may_block(&arg_self_.interface)
    }
}
impl ImplWriteHandler for WriteHandler {
    fn write(&self, ptr: *const u8, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .write
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.into_raw();
                    let arg_ptr = arg_ptr.cast();
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn tell(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn flush(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_write_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_write_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for WriteHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_write_handler_t> for &WriteHandler {
    fn into_raw(self) -> *mut _cef_write_handler_t {
        ImplWriteHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_write_handler_t> for &mut WriteHandler {
    fn into_raw(self) -> *mut _cef_write_handler_t {
        ImplWriteHandler::get_raw(self)
    }
}
impl ConvertReturnValue<WriteHandler> for *mut _cef_write_handler_t {
    fn wrap_result(self) -> WriteHandler {
        WriteHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<WriteHandler> for *mut _cef_write_handler_t {
    fn from(value: WriteHandler) -> Self {
        let object = ImplWriteHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for WriteHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_stream_writer_t`] for more documentation.
#[derive(Clone)]
pub struct StreamWriter(RefGuard<_cef_stream_writer_t>);
pub trait ImplStreamWriter: Clone + Sized + Rc {
    #[doc = "See [`_cef_stream_writer_t::write`] for more documentation."]
    fn write(&self, ptr: *const u8, size: usize, n: usize) -> usize;
    #[doc = "See [`_cef_stream_writer_t::seek`] for more documentation."]
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_stream_writer_t::tell`] for more documentation."]
    fn tell(&self) -> i64;
    #[doc = "See [`_cef_stream_writer_t::flush`] for more documentation."]
    fn flush(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_stream_writer_t::may_block`] for more documentation."]
    fn may_block(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_stream_writer_t;
}
impl ImplStreamWriter for StreamWriter {
    fn write(&self, ptr: *const u8, size: usize, n: usize) -> usize {
        unsafe {
            self.0
                .write
                .map(|f| {
                    let (arg_ptr, arg_size, arg_n) = (ptr, size, n);
                    let arg_self_ = self.into_raw();
                    let arg_ptr = arg_ptr.cast();
                    let result = f(arg_self_, arg_ptr, arg_size, arg_n);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn seek(&self, offset: i64, whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .seek
                .map(|f| {
                    let (arg_offset, arg_whence) = (offset, whence);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_offset, arg_whence);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn tell(&self) -> i64 {
        unsafe {
            self.0
                .tell
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn flush(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn may_block(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .may_block
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_stream_writer_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_stream_writer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for StreamWriter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_stream_writer_t> for &StreamWriter {
    fn into_raw(self) -> *mut _cef_stream_writer_t {
        ImplStreamWriter::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_stream_writer_t> for &mut StreamWriter {
    fn into_raw(self) -> *mut _cef_stream_writer_t {
        ImplStreamWriter::get_raw(self)
    }
}
impl ConvertReturnValue<StreamWriter> for *mut _cef_stream_writer_t {
    fn wrap_result(self) -> StreamWriter {
        StreamWriter(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<StreamWriter> for *mut _cef_stream_writer_t {
    fn from(value: StreamWriter) -> Self {
        let object = ImplStreamWriter::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for StreamWriter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_drag_data_t`] for more documentation.
#[derive(Clone)]
pub struct DragData(RefGuard<_cef_drag_data_t>);
pub trait ImplDragData: Clone + Sized + Rc {
    #[doc = "See [`_cef_drag_data_t::clone`] for more documentation."]
    fn clone(&self) -> Option<DragData>;
    #[doc = "See [`_cef_drag_data_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_drag_data_t::is_link`] for more documentation."]
    fn is_link(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_drag_data_t::is_fragment`] for more documentation."]
    fn is_fragment(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_drag_data_t::is_file`] for more documentation."]
    fn is_file(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_drag_data_t::get_link_url`] for more documentation."]
    fn link_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_drag_data_t::get_link_title`] for more documentation."]
    fn link_title(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_drag_data_t::get_link_metadata`] for more documentation."]
    fn link_metadata(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_drag_data_t::get_fragment_text`] for more documentation."]
    fn fragment_text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_drag_data_t::get_fragment_html`] for more documentation."]
    fn fragment_html(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_drag_data_t::get_fragment_base_url`] for more documentation."]
    fn fragment_base_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_drag_data_t::get_file_name`] for more documentation."]
    fn file_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_drag_data_t::get_file_contents`] for more documentation."]
    fn file_contents(&self, writer: Option<&mut StreamWriter>) -> usize;
    #[doc = "See [`_cef_drag_data_t::get_file_names`] for more documentation."]
    fn file_names(&self, names: Option<&mut CefStringList>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_drag_data_t::get_file_paths`] for more documentation."]
    fn file_paths(&self, paths: Option<&mut CefStringList>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_drag_data_t::set_link_url`] for more documentation."]
    fn set_link_url(&self, url: Option<&CefString>);
    #[doc = "See [`_cef_drag_data_t::set_link_title`] for more documentation."]
    fn set_link_title(&self, title: Option<&CefString>);
    #[doc = "See [`_cef_drag_data_t::set_link_metadata`] for more documentation."]
    fn set_link_metadata(&self, data: Option<&CefString>);
    #[doc = "See [`_cef_drag_data_t::set_fragment_text`] for more documentation."]
    fn set_fragment_text(&self, text: Option<&CefString>);
    #[doc = "See [`_cef_drag_data_t::set_fragment_html`] for more documentation."]
    fn set_fragment_html(&self, html: Option<&CefString>);
    #[doc = "See [`_cef_drag_data_t::set_fragment_base_url`] for more documentation."]
    fn set_fragment_base_url(&self, base_url: Option<&CefString>);
    #[doc = "See [`_cef_drag_data_t::reset_file_contents`] for more documentation."]
    fn reset_file_contents(&self);
    #[doc = "See [`_cef_drag_data_t::add_file`] for more documentation."]
    fn add_file(&self, path: Option<&CefString>, display_name: Option<&CefString>);
    #[doc = "See [`_cef_drag_data_t::clear_filenames`] for more documentation."]
    fn clear_filenames(&self);
    #[doc = "See [`_cef_drag_data_t::get_image`] for more documentation."]
    fn image(&self) -> Option<Image>;
    #[doc = "See [`_cef_drag_data_t::get_image_hotspot`] for more documentation."]
    fn image_hotspot(&self) -> Point;
    #[doc = "See [`_cef_drag_data_t::has_image`] for more documentation."]
    fn has_image(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_drag_data_t;
}
impl ImplDragData for DragData {
    fn clone(&self) -> Option<DragData> {
        unsafe {
            self.0
                .clone
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_link(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_link
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_fragment(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fragment
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_file(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_file
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn link_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_link_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn link_title(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_link_title
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn link_metadata(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_link_metadata
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn fragment_text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_fragment_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn fragment_html(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_fragment_html
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn fragment_base_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_fragment_base_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn file_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_file_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn file_contents(&self, writer: Option<&mut StreamWriter>) -> usize {
        unsafe {
            self.0
                .get_file_contents
                .map(|f| {
                    let arg_writer = writer;
                    let arg_self_ = self.into_raw();
                    let arg_writer = arg_writer
                        .map(|arg| {
                            arg.add_ref();
                            ImplStreamWriter::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_writer);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn file_names(&self, names: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_file_names
                .map(|f| {
                    let arg_names = names;
                    let arg_self_ = self.into_raw();
                    let arg_names = arg_names
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_names);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn file_paths(&self, paths: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_file_paths
                .map(|f| {
                    let arg_paths = paths;
                    let arg_self_ = self.into_raw();
                    let arg_paths = arg_paths
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_paths);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_link_url(&self, url: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_link_url {
                let arg_url = url;
                let arg_self_ = self.into_raw();
                let arg_url = arg_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_url);
            }
        }
    }
    fn set_link_title(&self, title: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_link_title {
                let arg_title = title;
                let arg_self_ = self.into_raw();
                let arg_title = arg_title
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_title);
            }
        }
    }
    fn set_link_metadata(&self, data: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_link_metadata {
                let arg_data = data;
                let arg_self_ = self.into_raw();
                let arg_data = arg_data
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_data);
            }
        }
    }
    fn set_fragment_text(&self, text: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_fragment_text {
                let arg_text = text;
                let arg_self_ = self.into_raw();
                let arg_text = arg_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_text);
            }
        }
    }
    fn set_fragment_html(&self, html: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_fragment_html {
                let arg_html = html;
                let arg_self_ = self.into_raw();
                let arg_html = arg_html
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_html);
            }
        }
    }
    fn set_fragment_base_url(&self, base_url: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_fragment_base_url {
                let arg_base_url = base_url;
                let arg_self_ = self.into_raw();
                let arg_base_url = arg_base_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_base_url);
            }
        }
    }
    fn reset_file_contents(&self) {
        unsafe {
            if let Some(f) = self.0.reset_file_contents {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn add_file(&self, path: Option<&CefString>, display_name: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.add_file {
                let (arg_path, arg_display_name) = (path, display_name);
                let arg_self_ = self.into_raw();
                let arg_path = arg_path
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_display_name = arg_display_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_path, arg_display_name);
            }
        }
    }
    fn clear_filenames(&self) {
        unsafe {
            if let Some(f) = self.0.clear_filenames {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn image(&self) -> Option<Image> {
        unsafe {
            self.0
                .get_image
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn image_hotspot(&self) -> Point {
        unsafe {
            self.0
                .get_image_hotspot
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_image(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_image
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_drag_data_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_drag_data_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DragData {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_drag_data_t> for &DragData {
    fn into_raw(self) -> *mut _cef_drag_data_t {
        ImplDragData::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_drag_data_t> for &mut DragData {
    fn into_raw(self) -> *mut _cef_drag_data_t {
        ImplDragData::get_raw(self)
    }
}
impl ConvertReturnValue<DragData> for *mut _cef_drag_data_t {
    fn wrap_result(self) -> DragData {
        DragData(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DragData> for *mut _cef_drag_data_t {
    fn from(value: DragData) -> Self {
        let object = ImplDragData::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DragData {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_domvisitor_t`] for more documentation.
#[derive(Clone)]
pub struct Domvisitor(RefGuard<_cef_domvisitor_t>);
impl Domvisitor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDomvisitor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDomvisitor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDomvisitor>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_domvisitor_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapDomvisitor: ImplDomvisitor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_domvisitor_t, Self>);
}
pub trait ImplDomvisitor: Clone + Sized + Rc {
    #[doc = "See [`_cef_domvisitor_t::visit`] for more documentation."]
    fn visit(&self, document: Option<&mut Domdocument>) {}
    fn init_methods(object: &mut _cef_domvisitor_t) {
        impl_cef_domvisitor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_domvisitor_t;
}
mod impl_cef_domvisitor_t {
    use super::*;
    pub fn init_methods<I: ImplDomvisitor>(object: &mut _cef_domvisitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplDomvisitor>(
        self_: *mut _cef_domvisitor_t,
        document: *mut _cef_domdocument_t,
    ) {
        let (arg_self_, arg_document) = (self_, document);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_document = unsafe { arg_document.as_mut() }
            .map(|arg| Domdocument(unsafe { RefGuard::from_raw(arg) }));
        let arg_document = arg_document.as_mut();
        ImplDomvisitor::visit(&arg_self_.interface, arg_document)
    }
}
impl ImplDomvisitor for Domvisitor {
    fn visit(&self, document: Option<&mut Domdocument>) {
        unsafe {
            if let Some(f) = self.0.visit {
                let arg_document = document;
                let arg_self_ = self.into_raw();
                let arg_document = arg_document
                    .map(|arg| {
                        arg.add_ref();
                        ImplDomdocument::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_document);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_domvisitor_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_domvisitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domvisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domvisitor_t> for &Domvisitor {
    fn into_raw(self) -> *mut _cef_domvisitor_t {
        ImplDomvisitor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_domvisitor_t> for &mut Domvisitor {
    fn into_raw(self) -> *mut _cef_domvisitor_t {
        ImplDomvisitor::get_raw(self)
    }
}
impl ConvertReturnValue<Domvisitor> for *mut _cef_domvisitor_t {
    fn wrap_result(self) -> Domvisitor {
        Domvisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Domvisitor> for *mut _cef_domvisitor_t {
    fn from(value: Domvisitor) -> Self {
        let object = ImplDomvisitor::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Domvisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_domdocument_t`] for more documentation.
#[derive(Clone)]
pub struct Domdocument(RefGuard<_cef_domdocument_t>);
pub trait ImplDomdocument: Clone + Sized + Rc {
    #[doc = "See [`_cef_domdocument_t::get_type`] for more documentation."]
    fn get_type(&self) -> DomDocumentType;
    #[doc = "See [`_cef_domdocument_t::get_document`] for more documentation."]
    fn document(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domdocument_t::get_body`] for more documentation."]
    fn body(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domdocument_t::get_head`] for more documentation."]
    fn head(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domdocument_t::get_title`] for more documentation."]
    fn title(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domdocument_t::get_element_by_id`] for more documentation."]
    fn element_by_id(&self, id: Option<&CefString>) -> Option<Domnode>;
    #[doc = "See [`_cef_domdocument_t::get_focused_node`] for more documentation."]
    fn focused_node(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domdocument_t::has_selection`] for more documentation."]
    fn has_selection(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domdocument_t::get_selection_start_offset`] for more documentation."]
    fn selection_start_offset(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domdocument_t::get_selection_end_offset`] for more documentation."]
    fn selection_end_offset(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domdocument_t::get_selection_as_markup`] for more documentation."]
    fn selection_as_markup(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domdocument_t::get_selection_as_text`] for more documentation."]
    fn selection_as_text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domdocument_t::get_base_url`] for more documentation."]
    fn base_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domdocument_t::get_complete_url`] for more documentation."]
    fn complete_url(&self, partial_url: Option<&CefString>) -> CefStringUserfree;
    fn get_raw(&self) -> *mut _cef_domdocument_t;
}
impl ImplDomdocument for Domdocument {
    fn get_type(&self) -> DomDocumentType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn document(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_document
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn body(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_body
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn head(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_head
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn title(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn element_by_id(&self, id: Option<&CefString>) -> Option<Domnode> {
        unsafe {
            self.0
                .get_element_by_id
                .map(|f| {
                    let arg_id = id;
                    let arg_self_ = self.into_raw();
                    let arg_id = arg_id.map(|arg| arg.into_raw()).unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_id);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn focused_node(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_focused_node
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn has_selection(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_selection
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn selection_start_offset(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_selection_start_offset
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn selection_end_offset(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_selection_end_offset
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn selection_as_markup(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_selection_as_markup
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn selection_as_text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_selection_as_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn base_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_base_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn complete_url(&self, partial_url: Option<&CefString>) -> CefStringUserfree {
        unsafe {
            self.0
                .get_complete_url
                .map(|f| {
                    let arg_partial_url = partial_url;
                    let arg_self_ = self.into_raw();
                    let arg_partial_url = arg_partial_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_partial_url);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_domdocument_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_domdocument_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domdocument {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domdocument_t> for &Domdocument {
    fn into_raw(self) -> *mut _cef_domdocument_t {
        ImplDomdocument::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_domdocument_t> for &mut Domdocument {
    fn into_raw(self) -> *mut _cef_domdocument_t {
        ImplDomdocument::get_raw(self)
    }
}
impl ConvertReturnValue<Domdocument> for *mut _cef_domdocument_t {
    fn wrap_result(self) -> Domdocument {
        Domdocument(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Domdocument> for *mut _cef_domdocument_t {
    fn from(value: Domdocument) -> Self {
        let object = ImplDomdocument::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Domdocument {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_domnode_t`] for more documentation.
#[derive(Clone)]
pub struct Domnode(RefGuard<_cef_domnode_t>);
pub trait ImplDomnode: Clone + Sized + Rc {
    #[doc = "See [`_cef_domnode_t::get_type`] for more documentation."]
    fn get_type(&self) -> DomNodeType;
    #[doc = "See [`_cef_domnode_t::is_text`] for more documentation."]
    fn is_text(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::is_element`] for more documentation."]
    fn is_element(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::is_editable`] for more documentation."]
    fn is_editable(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::is_form_control_element`] for more documentation."]
    fn is_form_control_element(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::get_form_control_element_type`] for more documentation."]
    fn form_control_element_type(&self) -> DomFormControlType;
    #[doc = "See [`_cef_domnode_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut Domnode>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::get_name`] for more documentation."]
    fn name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domnode_t::get_value`] for more documentation."]
    fn value(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domnode_t::set_value`] for more documentation."]
    fn set_value(&self, value: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::get_as_markup`] for more documentation."]
    fn as_markup(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domnode_t::get_document`] for more documentation."]
    fn document(&self) -> Option<Domdocument>;
    #[doc = "See [`_cef_domnode_t::get_parent`] for more documentation."]
    fn parent(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domnode_t::get_previous_sibling`] for more documentation."]
    fn previous_sibling(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domnode_t::get_next_sibling`] for more documentation."]
    fn next_sibling(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domnode_t::has_children`] for more documentation."]
    fn has_children(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::get_first_child`] for more documentation."]
    fn first_child(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domnode_t::get_last_child`] for more documentation."]
    fn last_child(&self) -> Option<Domnode>;
    #[doc = "See [`_cef_domnode_t::get_element_tag_name`] for more documentation."]
    fn element_tag_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domnode_t::has_element_attributes`] for more documentation."]
    fn has_element_attributes(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::has_element_attribute`] for more documentation."]
    fn has_element_attribute(&self, attr_name: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::get_element_attribute`] for more documentation."]
    fn element_attribute(&self, attr_name: Option<&CefString>) -> CefStringUserfree;
    #[doc = "See [`_cef_domnode_t::get_element_attributes`] for more documentation."]
    fn element_attributes(&self, attr_map: Option<&mut CefStringMap>);
    #[doc = "See [`_cef_domnode_t::set_element_attribute`] for more documentation."]
    fn set_element_attribute(
        &self,
        attr_name: Option<&CefString>,
        value: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_domnode_t::get_element_inner_text`] for more documentation."]
    fn element_inner_text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_domnode_t::get_element_bounds`] for more documentation."]
    fn element_bounds(&self) -> Rect;
    fn get_raw(&self) -> *mut _cef_domnode_t;
}
impl ImplDomnode for Domnode {
    fn get_type(&self) -> DomNodeType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_text(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_element(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_element
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_editable(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_editable
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_form_control_element(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_form_control_element
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn form_control_element_type(&self) -> DomFormControlType {
        unsafe {
            self.0
                .get_form_control_element_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut Domnode>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplDomnode::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn value(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_value
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_value(&self, value: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value
                .map(|f| {
                    let arg_value = value;
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn as_markup(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_as_markup
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn document(&self) -> Option<Domdocument> {
        unsafe {
            self.0
                .get_document
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn parent(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_parent
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn previous_sibling(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_previous_sibling
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn next_sibling(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_next_sibling
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn has_children(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_children
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn first_child(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_first_child
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn last_child(&self) -> Option<Domnode> {
        unsafe {
            self.0
                .get_last_child
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn element_tag_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_element_tag_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_element_attributes(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_element_attributes
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_element_attribute(&self, attr_name: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_element_attribute
                .map(|f| {
                    let arg_attr_name = attr_name;
                    let arg_self_ = self.into_raw();
                    let arg_attr_name = arg_attr_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_attr_name);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn element_attribute(&self, attr_name: Option<&CefString>) -> CefStringUserfree {
        unsafe {
            self.0
                .get_element_attribute
                .map(|f| {
                    let arg_attr_name = attr_name;
                    let arg_self_ = self.into_raw();
                    let arg_attr_name = arg_attr_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_attr_name);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn element_attributes(&self, attr_map: Option<&mut CefStringMap>) {
        unsafe {
            if let Some(f) = self.0.get_element_attributes {
                let arg_attr_map = attr_map;
                let arg_self_ = self.into_raw();
                let arg_attr_map = arg_attr_map
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_attr_map);
            }
        }
    }
    fn set_element_attribute(
        &self,
        attr_name: Option<&CefString>,
        value: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_element_attribute
                .map(|f| {
                    let (arg_attr_name, arg_value) = (attr_name, value);
                    let arg_self_ = self.into_raw();
                    let arg_attr_name = arg_attr_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_attr_name, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn element_inner_text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_element_inner_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn element_bounds(&self) -> Rect {
        unsafe {
            self.0
                .get_element_bounds
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_domnode_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_domnode_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Domnode {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_domnode_t> for &Domnode {
    fn into_raw(self) -> *mut _cef_domnode_t {
        ImplDomnode::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_domnode_t> for &mut Domnode {
    fn into_raw(self) -> *mut _cef_domnode_t {
        ImplDomnode::get_raw(self)
    }
}
impl ConvertReturnValue<Domnode> for *mut _cef_domnode_t {
    fn wrap_result(self) -> Domnode {
        Domnode(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Domnode> for *mut _cef_domnode_t {
    fn from(value: Domnode) -> Self {
        let object = ImplDomnode::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Domnode {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_shared_memory_region_t`] for more documentation.
#[derive(Clone)]
pub struct SharedMemoryRegion(RefGuard<_cef_shared_memory_region_t>);
pub trait ImplSharedMemoryRegion: Clone + Sized + Rc {
    #[doc = "See [`_cef_shared_memory_region_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_shared_memory_region_t::size`] for more documentation."]
    fn size(&self) -> usize;
    #[doc = "See [`_cef_shared_memory_region_t::memory`] for more documentation."]
    fn memory(&self) -> *mut ::std::os::raw::c_void;
    fn get_raw(&self) -> *mut _cef_shared_memory_region_t;
}
impl ImplSharedMemoryRegion for SharedMemoryRegion {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn size(&self) -> usize {
        unsafe {
            self.0
                .size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn memory(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            self.0
                .memory
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn get_raw(&self) -> *mut _cef_shared_memory_region_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_shared_memory_region_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SharedMemoryRegion {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_shared_memory_region_t> for &SharedMemoryRegion {
    fn into_raw(self) -> *mut _cef_shared_memory_region_t {
        ImplSharedMemoryRegion::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_shared_memory_region_t> for &mut SharedMemoryRegion {
    fn into_raw(self) -> *mut _cef_shared_memory_region_t {
        ImplSharedMemoryRegion::get_raw(self)
    }
}
impl ConvertReturnValue<SharedMemoryRegion> for *mut _cef_shared_memory_region_t {
    fn wrap_result(self) -> SharedMemoryRegion {
        SharedMemoryRegion(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<SharedMemoryRegion> for *mut _cef_shared_memory_region_t {
    fn from(value: SharedMemoryRegion) -> Self {
        let object = ImplSharedMemoryRegion::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for SharedMemoryRegion {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_process_message_t`] for more documentation.
#[derive(Clone)]
pub struct ProcessMessage(RefGuard<_cef_process_message_t>);
pub trait ImplProcessMessage: Clone + Sized + Rc {
    #[doc = "See [`_cef_process_message_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_process_message_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_process_message_t::copy`] for more documentation."]
    fn copy(&self) -> Option<ProcessMessage>;
    #[doc = "See [`_cef_process_message_t::get_name`] for more documentation."]
    fn name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_process_message_t::get_argument_list`] for more documentation."]
    fn argument_list(&self) -> Option<ListValue>;
    #[doc = "See [`_cef_process_message_t::get_shared_memory_region`] for more documentation."]
    fn shared_memory_region(&self) -> Option<SharedMemoryRegion>;
    fn get_raw(&self) -> *mut _cef_process_message_t;
}
impl ImplProcessMessage for ProcessMessage {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<ProcessMessage> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn argument_list(&self) -> Option<ListValue> {
        unsafe {
            self.0
                .get_argument_list
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn shared_memory_region(&self) -> Option<SharedMemoryRegion> {
        unsafe {
            self.0
                .get_shared_memory_region
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_process_message_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_process_message_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ProcessMessage {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_process_message_t> for &ProcessMessage {
    fn into_raw(self) -> *mut _cef_process_message_t {
        ImplProcessMessage::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_process_message_t> for &mut ProcessMessage {
    fn into_raw(self) -> *mut _cef_process_message_t {
        ImplProcessMessage::get_raw(self)
    }
}
impl ConvertReturnValue<ProcessMessage> for *mut _cef_process_message_t {
    fn wrap_result(self) -> ProcessMessage {
        ProcessMessage(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ProcessMessage> for *mut _cef_process_message_t {
    fn from(value: ProcessMessage) -> Self {
        let object = ImplProcessMessage::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ProcessMessage {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_request_t`] for more documentation.
#[derive(Clone)]
pub struct Request(RefGuard<_cef_request_t>);
pub trait ImplRequest: Clone + Sized + Rc {
    #[doc = "See [`_cef_request_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_request_t::get_url`] for more documentation."]
    fn url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_request_t::set_url`] for more documentation."]
    fn set_url(&self, url: Option<&CefString>);
    #[doc = "See [`_cef_request_t::get_method`] for more documentation."]
    fn method(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_request_t::set_method`] for more documentation."]
    fn set_method(&self, method: Option<&CefString>);
    #[doc = "See [`_cef_request_t::set_referrer`] for more documentation."]
    fn set_referrer(&self, referrer_url: Option<&CefString>, policy: ReferrerPolicy);
    #[doc = "See [`_cef_request_t::get_referrer_url`] for more documentation."]
    fn referrer_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_request_t::get_referrer_policy`] for more documentation."]
    fn referrer_policy(&self) -> ReferrerPolicy;
    #[doc = "See [`_cef_request_t::get_post_data`] for more documentation."]
    fn post_data(&self) -> Option<PostData>;
    #[doc = "See [`_cef_request_t::set_post_data`] for more documentation."]
    fn set_post_data(&self, post_data: Option<&mut PostData>);
    #[doc = "See [`_cef_request_t::get_header_map`] for more documentation."]
    fn header_map(&self, header_map: Option<&mut CefStringMultimap>);
    #[doc = "See [`_cef_request_t::set_header_map`] for more documentation."]
    fn set_header_map(&self, header_map: Option<&mut CefStringMultimap>);
    #[doc = "See [`_cef_request_t::get_header_by_name`] for more documentation."]
    fn header_by_name(&self, name: Option<&CefString>) -> CefStringUserfree;
    #[doc = "See [`_cef_request_t::set_header_by_name`] for more documentation."]
    fn set_header_by_name(
        &self,
        name: Option<&CefString>,
        value: Option<&CefString>,
        overwrite: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_request_t::set`] for more documentation."]
    fn set(
        &self,
        url: Option<&CefString>,
        method: Option<&CefString>,
        post_data: Option<&mut PostData>,
        header_map: Option<&mut CefStringMultimap>,
    );
    #[doc = "See [`_cef_request_t::get_flags`] for more documentation."]
    fn flags(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_request_t::set_flags`] for more documentation."]
    fn set_flags(&self, flags: ::std::os::raw::c_int);
    #[doc = "See [`_cef_request_t::get_first_party_for_cookies`] for more documentation."]
    fn first_party_for_cookies(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_request_t::set_first_party_for_cookies`] for more documentation."]
    fn set_first_party_for_cookies(&self, url: Option<&CefString>);
    #[doc = "See [`_cef_request_t::get_resource_type`] for more documentation."]
    fn resource_type(&self) -> ResourceType;
    #[doc = "See [`_cef_request_t::get_transition_type`] for more documentation."]
    fn transition_type(&self) -> TransitionType;
    #[doc = "See [`_cef_request_t::get_identifier`] for more documentation."]
    fn identifier(&self) -> u64;
    fn get_raw(&self) -> *mut _cef_request_t;
}
impl ImplRequest for Request {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_url(&self, url: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_url {
                let arg_url = url;
                let arg_self_ = self.into_raw();
                let arg_url = arg_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_url);
            }
        }
    }
    fn method(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_method
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_method(&self, method: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_method {
                let arg_method = method;
                let arg_self_ = self.into_raw();
                let arg_method = arg_method
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_method);
            }
        }
    }
    fn set_referrer(&self, referrer_url: Option<&CefString>, policy: ReferrerPolicy) {
        unsafe {
            if let Some(f) = self.0.set_referrer {
                let (arg_referrer_url, arg_policy) = (referrer_url, policy);
                let arg_self_ = self.into_raw();
                let arg_referrer_url = arg_referrer_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_policy = arg_policy.into_raw();
                f(arg_self_, arg_referrer_url, arg_policy);
            }
        }
    }
    fn referrer_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_referrer_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn referrer_policy(&self) -> ReferrerPolicy {
        unsafe {
            self.0
                .get_referrer_policy
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn post_data(&self) -> Option<PostData> {
        unsafe {
            self.0
                .get_post_data
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_post_data(&self, post_data: Option<&mut PostData>) {
        unsafe {
            if let Some(f) = self.0.set_post_data {
                let arg_post_data = post_data;
                let arg_self_ = self.into_raw();
                let arg_post_data = arg_post_data
                    .map(|arg| {
                        arg.add_ref();
                        ImplPostData::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_post_data);
            }
        }
    }
    fn header_map(&self, header_map: Option<&mut CefStringMultimap>) {
        unsafe {
            if let Some(f) = self.0.get_header_map {
                let arg_header_map = header_map;
                let arg_self_ = self.into_raw();
                let arg_header_map = arg_header_map
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_header_map);
            }
        }
    }
    fn set_header_map(&self, header_map: Option<&mut CefStringMultimap>) {
        unsafe {
            if let Some(f) = self.0.set_header_map {
                let arg_header_map = header_map;
                let arg_self_ = self.into_raw();
                let arg_header_map = arg_header_map
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_header_map);
            }
        }
    }
    fn header_by_name(&self, name: Option<&CefString>) -> CefStringUserfree {
        unsafe {
            self.0
                .get_header_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_header_by_name(
        &self,
        name: Option<&CefString>,
        value: Option<&CefString>,
        overwrite: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.set_header_by_name {
                let (arg_name, arg_value, arg_overwrite) = (name, value, overwrite);
                let arg_self_ = self.into_raw();
                let arg_name = arg_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_value = arg_value
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_name, arg_value, arg_overwrite);
            }
        }
    }
    fn set(
        &self,
        url: Option<&CefString>,
        method: Option<&CefString>,
        post_data: Option<&mut PostData>,
        header_map: Option<&mut CefStringMultimap>,
    ) {
        unsafe {
            if let Some(f) = self.0.set {
                let (arg_url, arg_method, arg_post_data, arg_header_map) =
                    (url, method, post_data, header_map);
                let arg_self_ = self.into_raw();
                let arg_url = arg_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_method = arg_method
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_post_data = arg_post_data
                    .map(|arg| {
                        arg.add_ref();
                        ImplPostData::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_header_map = arg_header_map
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_url,
                    arg_method,
                    arg_post_data,
                    arg_header_map,
                );
            }
        }
    }
    fn flags(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_flags
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_flags(&self, flags: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_flags {
                let arg_flags = flags;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_flags);
            }
        }
    }
    fn first_party_for_cookies(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_first_party_for_cookies
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_first_party_for_cookies(&self, url: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_first_party_for_cookies {
                let arg_url = url;
                let arg_self_ = self.into_raw();
                let arg_url = arg_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_url);
            }
        }
    }
    fn resource_type(&self) -> ResourceType {
        unsafe {
            self.0
                .get_resource_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn transition_type(&self) -> TransitionType {
        unsafe {
            self.0
                .get_transition_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn identifier(&self) -> u64 {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_request_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_request_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Request {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_t> for &Request {
    fn into_raw(self) -> *mut _cef_request_t {
        ImplRequest::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_request_t> for &mut Request {
    fn into_raw(self) -> *mut _cef_request_t {
        ImplRequest::get_raw(self)
    }
}
impl ConvertReturnValue<Request> for *mut _cef_request_t {
    fn wrap_result(self) -> Request {
        Request(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Request> for *mut _cef_request_t {
    fn from(value: Request) -> Self {
        let object = ImplRequest::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Request {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_post_data_t`] for more documentation.
#[derive(Clone)]
pub struct PostData(RefGuard<_cef_post_data_t>);
pub trait ImplPostData: Clone + Sized + Rc {
    #[doc = "See [`_cef_post_data_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_post_data_t::has_excluded_elements`] for more documentation."]
    fn has_excluded_elements(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_post_data_t::get_element_count`] for more documentation."]
    fn element_count(&self) -> usize;
    #[doc = "See [`_cef_post_data_t::get_elements`] for more documentation."]
    fn elements(&self, elements: Option<&mut Vec<Option<PostDataElement>>>);
    #[doc = "See [`_cef_post_data_t::remove_element`] for more documentation."]
    fn remove_element(&self, element: Option<&mut PostDataElement>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_post_data_t::add_element`] for more documentation."]
    fn add_element(&self, element: Option<&mut PostDataElement>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_post_data_t::remove_elements`] for more documentation."]
    fn remove_elements(&self);
    fn get_raw(&self) -> *mut _cef_post_data_t;
}
impl ImplPostData for PostData {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_excluded_elements(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_excluded_elements
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn element_count(&self) -> usize {
        unsafe {
            self.0
                .get_element_count
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn elements(&self, elements: Option<&mut Vec<Option<PostDataElement>>>) {
        unsafe {
            if let Some(f) = self.0.get_elements {
                let arg_elements = elements;
                let arg_self_ = self.into_raw();
                let mut out_elements_count = arg_elements
                    .as_ref()
                    .map(|arg| arg.len())
                    .unwrap_or_default();
                let arg_elements_count = &mut out_elements_count;
                let out_elements = arg_elements;
                let mut vec_elements = out_elements
                    .as_ref()
                    .map(|arg| {
                        arg.iter()
                            .map(|elem| {
                                elem.as_ref()
                                    .map(|elem| {
                                        elem.add_ref();
                                        elem.get_raw()
                                    })
                                    .unwrap_or(std::ptr::null_mut())
                            })
                            .collect::<Vec<_>>()
                    })
                    .unwrap_or_default();
                let arg_elements = if vec_elements.is_empty() {
                    std::ptr::null_mut()
                } else {
                    vec_elements.as_mut_ptr()
                };
                f(arg_self_, arg_elements_count, arg_elements);
                if let Some(out_elements) = out_elements {
                    *out_elements = vec_elements
                        .into_iter()
                        .take(out_elements_count)
                        .map(|elem| {
                            if elem.is_null() {
                                None
                            } else {
                                Some(elem.wrap_result())
                            }
                        })
                        .collect();
                }
            }
        }
    }
    fn remove_element(&self, element: Option<&mut PostDataElement>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_element
                .map(|f| {
                    let arg_element = element;
                    let arg_self_ = self.into_raw();
                    let arg_element = arg_element
                        .map(|arg| {
                            arg.add_ref();
                            ImplPostDataElement::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_element);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_element(&self, element: Option<&mut PostDataElement>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_element
                .map(|f| {
                    let arg_element = element;
                    let arg_self_ = self.into_raw();
                    let arg_element = arg_element
                        .map(|arg| {
                            arg.add_ref();
                            ImplPostDataElement::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_element);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn remove_elements(&self) {
        unsafe {
            if let Some(f) = self.0.remove_elements {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_post_data_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_post_data_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PostData {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_post_data_t> for &PostData {
    fn into_raw(self) -> *mut _cef_post_data_t {
        ImplPostData::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_post_data_t> for &mut PostData {
    fn into_raw(self) -> *mut _cef_post_data_t {
        ImplPostData::get_raw(self)
    }
}
impl ConvertReturnValue<PostData> for *mut _cef_post_data_t {
    fn wrap_result(self) -> PostData {
        PostData(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PostData> for *mut _cef_post_data_t {
    fn from(value: PostData) -> Self {
        let object = ImplPostData::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PostData {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_post_data_element_t`] for more documentation.
#[derive(Clone)]
pub struct PostDataElement(RefGuard<_cef_post_data_element_t>);
pub trait ImplPostDataElement: Clone + Sized + Rc {
    #[doc = "See [`_cef_post_data_element_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_post_data_element_t::set_to_empty`] for more documentation."]
    fn set_to_empty(&self);
    #[doc = "See [`_cef_post_data_element_t::set_to_file`] for more documentation."]
    fn set_to_file(&self, file_name: Option<&CefString>);
    #[doc = "See [`_cef_post_data_element_t::set_to_bytes`] for more documentation."]
    fn set_to_bytes(&self, size: usize, bytes: *const u8);
    #[doc = "See [`_cef_post_data_element_t::get_type`] for more documentation."]
    fn get_type(&self) -> PostdataelementType;
    #[doc = "See [`_cef_post_data_element_t::get_file`] for more documentation."]
    fn file(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_post_data_element_t::get_bytes_count`] for more documentation."]
    fn bytes_count(&self) -> usize;
    #[doc = "See [`_cef_post_data_element_t::get_bytes`] for more documentation."]
    fn bytes(&self, size: usize, bytes: *mut u8) -> usize;
    fn get_raw(&self) -> *mut _cef_post_data_element_t;
}
impl ImplPostDataElement for PostDataElement {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_to_empty(&self) {
        unsafe {
            if let Some(f) = self.0.set_to_empty {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_to_file(&self, file_name: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_to_file {
                let arg_file_name = file_name;
                let arg_self_ = self.into_raw();
                let arg_file_name = arg_file_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_file_name);
            }
        }
    }
    fn set_to_bytes(&self, size: usize, bytes: *const u8) {
        unsafe {
            if let Some(f) = self.0.set_to_bytes {
                let (arg_size, arg_bytes) = (size, bytes);
                let arg_self_ = self.into_raw();
                let arg_bytes = arg_bytes.cast();
                f(arg_self_, arg_size, arg_bytes);
            }
        }
    }
    fn get_type(&self) -> PostdataelementType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn file(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_file
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn bytes_count(&self) -> usize {
        unsafe {
            self.0
                .get_bytes_count
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn bytes(&self, size: usize, bytes: *mut u8) -> usize {
        unsafe {
            self.0
                .get_bytes
                .map(|f| {
                    let (arg_size, arg_bytes) = (size, bytes);
                    let arg_self_ = self.into_raw();
                    let arg_bytes = arg_bytes.cast();
                    let result = f(arg_self_, arg_size, arg_bytes);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_post_data_element_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_post_data_element_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PostDataElement {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_post_data_element_t> for &PostDataElement {
    fn into_raw(self) -> *mut _cef_post_data_element_t {
        ImplPostDataElement::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_post_data_element_t> for &mut PostDataElement {
    fn into_raw(self) -> *mut _cef_post_data_element_t {
        ImplPostDataElement::get_raw(self)
    }
}
impl ConvertReturnValue<PostDataElement> for *mut _cef_post_data_element_t {
    fn wrap_result(self) -> PostDataElement {
        PostDataElement(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PostDataElement> for *mut _cef_post_data_element_t {
    fn from(value: PostDataElement) -> Self {
        let object = ImplPostDataElement::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PostDataElement {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_string_visitor_t`] for more documentation.
#[derive(Clone)]
pub struct CefStringVisitor(RefGuard<_cef_string_visitor_t>);
impl CefStringVisitor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCefStringVisitor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCefStringVisitor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCefStringVisitor>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_string_visitor_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapCefStringVisitor: ImplCefStringVisitor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_string_visitor_t, Self>);
}
pub trait ImplCefStringVisitor: Clone + Sized + Rc {
    #[doc = "See [`_cef_string_visitor_t::visit`] for more documentation."]
    fn visit(&self, string: Option<&CefString>) {}
    fn init_methods(object: &mut _cef_string_visitor_t) {
        impl_cef_string_visitor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_string_visitor_t;
}
mod impl_cef_string_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplCefStringVisitor>(object: &mut _cef_string_visitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplCefStringVisitor>(
        self_: *mut _cef_string_visitor_t,
        string: *const cef_string_t,
    ) {
        let (arg_self_, arg_string) = (self_, string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_string = if arg_string.is_null() {
            None
        } else {
            Some(arg_string.into())
        };
        let arg_string = arg_string.as_ref();
        ImplCefStringVisitor::visit(&arg_self_.interface, arg_string)
    }
}
impl ImplCefStringVisitor for CefStringVisitor {
    fn visit(&self, string: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.visit {
                let arg_string = string;
                let arg_self_ = self.into_raw();
                let arg_string = arg_string
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_string);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_string_visitor_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_string_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CefStringVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_string_visitor_t> for &CefStringVisitor {
    fn into_raw(self) -> *mut _cef_string_visitor_t {
        ImplCefStringVisitor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_string_visitor_t> for &mut CefStringVisitor {
    fn into_raw(self) -> *mut _cef_string_visitor_t {
        ImplCefStringVisitor::get_raw(self)
    }
}
impl ConvertReturnValue<CefStringVisitor> for *mut _cef_string_visitor_t {
    fn wrap_result(self) -> CefStringVisitor {
        CefStringVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<CefStringVisitor> for *mut _cef_string_visitor_t {
    fn from(value: CefStringVisitor) -> Self {
        let object = ImplCefStringVisitor::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for CefStringVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_frame_t`] for more documentation.
#[derive(Clone)]
pub struct Frame(RefGuard<_cef_frame_t>);
pub trait ImplFrame: Clone + Sized + Rc {
    #[doc = "See [`_cef_frame_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_frame_t::undo`] for more documentation."]
    fn undo(&self);
    #[doc = "See [`_cef_frame_t::redo`] for more documentation."]
    fn redo(&self);
    #[doc = "See [`_cef_frame_t::cut`] for more documentation."]
    fn cut(&self);
    #[doc = "See [`_cef_frame_t::copy`] for more documentation."]
    fn copy(&self);
    #[doc = "See [`_cef_frame_t::paste`] for more documentation."]
    fn paste(&self);
    #[doc = "See [`_cef_frame_t::paste_and_match_style`] for more documentation."]
    fn paste_and_match_style(&self);
    #[doc = "See [`_cef_frame_t::del`] for more documentation."]
    fn del(&self);
    #[doc = "See [`_cef_frame_t::select_all`] for more documentation."]
    fn select_all(&self);
    #[doc = "See [`_cef_frame_t::view_source`] for more documentation."]
    fn view_source(&self);
    #[doc = "See [`_cef_frame_t::get_source`] for more documentation."]
    fn source(&self, visitor: Option<&mut impl ImplCefStringVisitor>);
    #[doc = "See [`_cef_frame_t::get_text`] for more documentation."]
    fn text(&self, visitor: Option<&mut impl ImplCefStringVisitor>);
    #[doc = "See [`_cef_frame_t::load_request`] for more documentation."]
    fn load_request(&self, request: Option<&mut Request>);
    #[doc = "See [`_cef_frame_t::load_url`] for more documentation."]
    fn load_url(&self, url: Option<&CefString>);
    #[doc = "See [`_cef_frame_t::execute_java_script`] for more documentation."]
    fn execute_java_script(
        &self,
        code: Option<&CefString>,
        script_url: Option<&CefString>,
        start_line: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_frame_t::is_main`] for more documentation."]
    fn is_main(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_frame_t::is_focused`] for more documentation."]
    fn is_focused(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_frame_t::get_name`] for more documentation."]
    fn name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_frame_t::get_identifier`] for more documentation."]
    fn identifier(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_frame_t::get_parent`] for more documentation."]
    fn parent(&self) -> Option<Frame>;
    #[doc = "See [`_cef_frame_t::get_url`] for more documentation."]
    fn url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_frame_t::get_browser`] for more documentation."]
    fn browser(&self) -> Option<Browser>;
    #[doc = "See [`_cef_frame_t::get_v8_context`] for more documentation."]
    fn v8_context(&self) -> Option<V8Context>;
    #[doc = "See [`_cef_frame_t::visit_dom`] for more documentation."]
    fn visit_dom(&self, visitor: Option<&mut impl ImplDomvisitor>);
    #[doc = "See [`_cef_frame_t::create_urlrequest`] for more documentation."]
    fn create_urlrequest(
        &self,
        request: Option<&mut Request>,
        client: Option<&mut impl ImplUrlrequestClient>,
    ) -> Option<Urlrequest>;
    #[doc = "See [`_cef_frame_t::send_process_message`] for more documentation."]
    fn send_process_message(&self, target_process: ProcessId, message: Option<&mut ProcessMessage>);
    fn get_raw(&self) -> *mut _cef_frame_t;
}
impl ImplFrame for Frame {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn undo(&self) {
        unsafe {
            if let Some(f) = self.0.undo {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn redo(&self) {
        unsafe {
            if let Some(f) = self.0.redo {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn cut(&self) {
        unsafe {
            if let Some(f) = self.0.cut {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn copy(&self) {
        unsafe {
            if let Some(f) = self.0.copy {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn paste(&self) {
        unsafe {
            if let Some(f) = self.0.paste {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn paste_and_match_style(&self) {
        unsafe {
            if let Some(f) = self.0.paste_and_match_style {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn del(&self) {
        unsafe {
            if let Some(f) = self.0.del {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn select_all(&self) {
        unsafe {
            if let Some(f) = self.0.select_all {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn view_source(&self) {
        unsafe {
            if let Some(f) = self.0.view_source {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn source(&self, visitor: Option<&mut impl ImplCefStringVisitor>) {
        unsafe {
            if let Some(f) = self.0.get_source {
                let arg_visitor = visitor;
                let arg_self_ = self.into_raw();
                let arg_visitor = arg_visitor
                    .map(|arg| {
                        arg.add_ref();
                        ImplCefStringVisitor::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_visitor);
            }
        }
    }
    fn text(&self, visitor: Option<&mut impl ImplCefStringVisitor>) {
        unsafe {
            if let Some(f) = self.0.get_text {
                let arg_visitor = visitor;
                let arg_self_ = self.into_raw();
                let arg_visitor = arg_visitor
                    .map(|arg| {
                        arg.add_ref();
                        ImplCefStringVisitor::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_visitor);
            }
        }
    }
    fn load_request(&self, request: Option<&mut Request>) {
        unsafe {
            if let Some(f) = self.0.load_request {
                let arg_request = request;
                let arg_self_ = self.into_raw();
                let arg_request = arg_request
                    .map(|arg| {
                        arg.add_ref();
                        ImplRequest::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_request);
            }
        }
    }
    fn load_url(&self, url: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.load_url {
                let arg_url = url;
                let arg_self_ = self.into_raw();
                let arg_url = arg_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_url);
            }
        }
    }
    fn execute_java_script(
        &self,
        code: Option<&CefString>,
        script_url: Option<&CefString>,
        start_line: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.execute_java_script {
                let (arg_code, arg_script_url, arg_start_line) = (code, script_url, start_line);
                let arg_self_ = self.into_raw();
                let arg_code = arg_code
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_script_url = arg_script_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_code, arg_script_url, arg_start_line);
            }
        }
    }
    fn is_main(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_main
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_focused(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_focused
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn identifier(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn parent(&self) -> Option<Frame> {
        unsafe {
            self.0
                .get_parent
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn browser(&self) -> Option<Browser> {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn v8_context(&self) -> Option<V8Context> {
        unsafe {
            self.0
                .get_v8_context
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn visit_dom(&self, visitor: Option<&mut impl ImplDomvisitor>) {
        unsafe {
            if let Some(f) = self.0.visit_dom {
                let arg_visitor = visitor;
                let arg_self_ = self.into_raw();
                let arg_visitor = arg_visitor
                    .map(|arg| {
                        arg.add_ref();
                        ImplDomvisitor::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_visitor);
            }
        }
    }
    fn create_urlrequest(
        &self,
        request: Option<&mut Request>,
        client: Option<&mut impl ImplUrlrequestClient>,
    ) -> Option<Urlrequest> {
        unsafe {
            self.0
                .create_urlrequest
                .map(|f| {
                    let (arg_request, arg_client) = (request, client);
                    let arg_self_ = self.into_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_client = arg_client
                        .map(|arg| {
                            arg.add_ref();
                            ImplUrlrequestClient::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request, arg_client);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn send_process_message(
        &self,
        target_process: ProcessId,
        message: Option<&mut ProcessMessage>,
    ) {
        unsafe {
            if let Some(f) = self.0.send_process_message {
                let (arg_target_process, arg_message) = (target_process, message);
                let arg_self_ = self.into_raw();
                let arg_target_process = arg_target_process.into_raw();
                let arg_message = arg_message
                    .map(|arg| {
                        arg.add_ref();
                        ImplProcessMessage::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_target_process, arg_message);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_frame_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_frame_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Frame {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_frame_t> for &Frame {
    fn into_raw(self) -> *mut _cef_frame_t {
        ImplFrame::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_frame_t> for &mut Frame {
    fn into_raw(self) -> *mut _cef_frame_t {
        ImplFrame::get_raw(self)
    }
}
impl ConvertReturnValue<Frame> for *mut _cef_frame_t {
    fn wrap_result(self) -> Frame {
        Frame(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Frame> for *mut _cef_frame_t {
    fn from(value: Frame) -> Self {
        let object = ImplFrame::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Frame {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_x509_cert_principal_t`] for more documentation.
#[derive(Clone)]
pub struct X509CertPrincipal(RefGuard<_cef_x509_cert_principal_t>);
pub trait ImplX509CertPrincipal: Clone + Sized + Rc {
    #[doc = "See [`_cef_x509_cert_principal_t::get_display_name`] for more documentation."]
    fn display_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_x509_cert_principal_t::get_common_name`] for more documentation."]
    fn common_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_x509_cert_principal_t::get_locality_name`] for more documentation."]
    fn locality_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_x509_cert_principal_t::get_state_or_province_name`] for more documentation."]
    fn state_or_province_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_x509_cert_principal_t::get_country_name`] for more documentation."]
    fn country_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_x509_cert_principal_t::get_organization_names`] for more documentation."]
    fn organization_names(&self, names: Option<&mut CefStringList>);
    #[doc = "See [`_cef_x509_cert_principal_t::get_organization_unit_names`] for more documentation."]
    fn organization_unit_names(&self, names: Option<&mut CefStringList>);
    fn get_raw(&self) -> *mut _cef_x509_cert_principal_t;
}
impl ImplX509CertPrincipal for X509CertPrincipal {
    fn display_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_display_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn common_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_common_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn locality_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_locality_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn state_or_province_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_state_or_province_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn country_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_country_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn organization_names(&self, names: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.get_organization_names {
                let arg_names = names;
                let arg_self_ = self.into_raw();
                let arg_names = arg_names
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_names);
            }
        }
    }
    fn organization_unit_names(&self, names: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.get_organization_unit_names {
                let arg_names = names;
                let arg_self_ = self.into_raw();
                let arg_names = arg_names
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_names);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_x509_cert_principal_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_x509_cert_principal_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for X509CertPrincipal {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_x509_cert_principal_t> for &X509CertPrincipal {
    fn into_raw(self) -> *mut _cef_x509_cert_principal_t {
        ImplX509CertPrincipal::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_x509_cert_principal_t> for &mut X509CertPrincipal {
    fn into_raw(self) -> *mut _cef_x509_cert_principal_t {
        ImplX509CertPrincipal::get_raw(self)
    }
}
impl ConvertReturnValue<X509CertPrincipal> for *mut _cef_x509_cert_principal_t {
    fn wrap_result(self) -> X509CertPrincipal {
        X509CertPrincipal(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<X509CertPrincipal> for *mut _cef_x509_cert_principal_t {
    fn from(value: X509CertPrincipal) -> Self {
        let object = ImplX509CertPrincipal::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for X509CertPrincipal {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_x509_certificate_t`] for more documentation.
#[derive(Clone)]
pub struct X509Certificate(RefGuard<_cef_x509_certificate_t>);
pub trait ImplX509Certificate: Clone + Sized + Rc {
    #[doc = "See [`_cef_x509_certificate_t::get_subject`] for more documentation."]
    fn subject(&self) -> Option<X509CertPrincipal>;
    #[doc = "See [`_cef_x509_certificate_t::get_issuer`] for more documentation."]
    fn issuer(&self) -> Option<X509CertPrincipal>;
    #[doc = "See [`_cef_x509_certificate_t::get_serial_number`] for more documentation."]
    fn serial_number(&self) -> Option<BinaryValue>;
    #[doc = "See [`_cef_x509_certificate_t::get_valid_start`] for more documentation."]
    fn valid_start(&self) -> Basetime;
    #[doc = "See [`_cef_x509_certificate_t::get_valid_expiry`] for more documentation."]
    fn valid_expiry(&self) -> Basetime;
    #[doc = "See [`_cef_x509_certificate_t::get_derencoded`] for more documentation."]
    fn derencoded(&self) -> Option<BinaryValue>;
    #[doc = "See [`_cef_x509_certificate_t::get_pemencoded`] for more documentation."]
    fn pemencoded(&self) -> Option<BinaryValue>;
    #[doc = "See [`_cef_x509_certificate_t::get_issuer_chain_size`] for more documentation."]
    fn issuer_chain_size(&self) -> usize;
    #[doc = "See [`_cef_x509_certificate_t::get_derencoded_issuer_chain`] for more documentation."]
    fn derencoded_issuer_chain(&self, chain: Option<&mut Vec<Option<BinaryValue>>>);
    #[doc = "See [`_cef_x509_certificate_t::get_pemencoded_issuer_chain`] for more documentation."]
    fn pemencoded_issuer_chain(&self, chain: Option<&mut Vec<Option<BinaryValue>>>);
    fn get_raw(&self) -> *mut _cef_x509_certificate_t;
}
impl ImplX509Certificate for X509Certificate {
    fn subject(&self) -> Option<X509CertPrincipal> {
        unsafe {
            self.0
                .get_subject
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn issuer(&self) -> Option<X509CertPrincipal> {
        unsafe {
            self.0
                .get_issuer
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn serial_number(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_serial_number
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn valid_start(&self) -> Basetime {
        unsafe {
            self.0
                .get_valid_start
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn valid_expiry(&self) -> Basetime {
        unsafe {
            self.0
                .get_valid_expiry
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn derencoded(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_derencoded
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn pemencoded(&self) -> Option<BinaryValue> {
        unsafe {
            self.0
                .get_pemencoded
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn issuer_chain_size(&self) -> usize {
        unsafe {
            self.0
                .get_issuer_chain_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn derencoded_issuer_chain(&self, chain: Option<&mut Vec<Option<BinaryValue>>>) {
        unsafe {
            if let Some(f) = self.0.get_derencoded_issuer_chain {
                let arg_chain = chain;
                let arg_self_ = self.into_raw();
                let mut out_chain_count =
                    arg_chain.as_ref().map(|arg| arg.len()).unwrap_or_default();
                let arg_chain_count = &mut out_chain_count;
                let out_chain = arg_chain;
                let mut vec_chain = out_chain
                    .as_ref()
                    .map(|arg| {
                        arg.iter()
                            .map(|elem| {
                                elem.as_ref()
                                    .map(|elem| {
                                        elem.add_ref();
                                        elem.get_raw()
                                    })
                                    .unwrap_or(std::ptr::null_mut())
                            })
                            .collect::<Vec<_>>()
                    })
                    .unwrap_or_default();
                let arg_chain = if vec_chain.is_empty() {
                    std::ptr::null_mut()
                } else {
                    vec_chain.as_mut_ptr()
                };
                f(arg_self_, arg_chain_count, arg_chain);
                if let Some(out_chain) = out_chain {
                    *out_chain = vec_chain
                        .into_iter()
                        .take(out_chain_count)
                        .map(|elem| {
                            if elem.is_null() {
                                None
                            } else {
                                Some(elem.wrap_result())
                            }
                        })
                        .collect();
                }
            }
        }
    }
    fn pemencoded_issuer_chain(&self, chain: Option<&mut Vec<Option<BinaryValue>>>) {
        unsafe {
            if let Some(f) = self.0.get_pemencoded_issuer_chain {
                let arg_chain = chain;
                let arg_self_ = self.into_raw();
                let mut out_chain_count =
                    arg_chain.as_ref().map(|arg| arg.len()).unwrap_or_default();
                let arg_chain_count = &mut out_chain_count;
                let out_chain = arg_chain;
                let mut vec_chain = out_chain
                    .as_ref()
                    .map(|arg| {
                        arg.iter()
                            .map(|elem| {
                                elem.as_ref()
                                    .map(|elem| {
                                        elem.add_ref();
                                        elem.get_raw()
                                    })
                                    .unwrap_or(std::ptr::null_mut())
                            })
                            .collect::<Vec<_>>()
                    })
                    .unwrap_or_default();
                let arg_chain = if vec_chain.is_empty() {
                    std::ptr::null_mut()
                } else {
                    vec_chain.as_mut_ptr()
                };
                f(arg_self_, arg_chain_count, arg_chain);
                if let Some(out_chain) = out_chain {
                    *out_chain = vec_chain
                        .into_iter()
                        .take(out_chain_count)
                        .map(|elem| {
                            if elem.is_null() {
                                None
                            } else {
                                Some(elem.wrap_result())
                            }
                        })
                        .collect();
                }
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_x509_certificate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_x509_certificate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for X509Certificate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_x509_certificate_t> for &X509Certificate {
    fn into_raw(self) -> *mut _cef_x509_certificate_t {
        ImplX509Certificate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_x509_certificate_t> for &mut X509Certificate {
    fn into_raw(self) -> *mut _cef_x509_certificate_t {
        ImplX509Certificate::get_raw(self)
    }
}
impl ConvertReturnValue<X509Certificate> for *mut _cef_x509_certificate_t {
    fn wrap_result(self) -> X509Certificate {
        X509Certificate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<X509Certificate> for *mut _cef_x509_certificate_t {
    fn from(value: X509Certificate) -> Self {
        let object = ImplX509Certificate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for X509Certificate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_sslstatus_t`] for more documentation.
#[derive(Clone)]
pub struct Sslstatus(RefGuard<_cef_sslstatus_t>);
pub trait ImplSslstatus: Clone + Sized + Rc {
    #[doc = "See [`_cef_sslstatus_t::is_secure_connection`] for more documentation."]
    fn is_secure_connection(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_sslstatus_t::get_cert_status`] for more documentation."]
    fn cert_status(&self) -> CertStatus;
    #[doc = "See [`_cef_sslstatus_t::get_sslversion`] for more documentation."]
    fn sslversion(&self) -> SslVersion;
    #[doc = "See [`_cef_sslstatus_t::get_content_status`] for more documentation."]
    fn content_status(&self) -> SslContentStatus;
    #[doc = "See [`_cef_sslstatus_t::get_x509_certificate`] for more documentation."]
    fn x509_certificate(&self) -> Option<X509Certificate>;
    fn get_raw(&self) -> *mut _cef_sslstatus_t;
}
impl ImplSslstatus for Sslstatus {
    fn is_secure_connection(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_secure_connection
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn cert_status(&self) -> CertStatus {
        unsafe {
            self.0
                .get_cert_status
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn sslversion(&self) -> SslVersion {
        unsafe {
            self.0
                .get_sslversion
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn content_status(&self) -> SslContentStatus {
        unsafe {
            self.0
                .get_content_status
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn x509_certificate(&self) -> Option<X509Certificate> {
        unsafe {
            self.0
                .get_x509_certificate
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_sslstatus_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_sslstatus_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Sslstatus {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_sslstatus_t> for &Sslstatus {
    fn into_raw(self) -> *mut _cef_sslstatus_t {
        ImplSslstatus::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_sslstatus_t> for &mut Sslstatus {
    fn into_raw(self) -> *mut _cef_sslstatus_t {
        ImplSslstatus::get_raw(self)
    }
}
impl ConvertReturnValue<Sslstatus> for *mut _cef_sslstatus_t {
    fn wrap_result(self) -> Sslstatus {
        Sslstatus(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Sslstatus> for *mut _cef_sslstatus_t {
    fn from(value: Sslstatus) -> Self {
        let object = ImplSslstatus::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Sslstatus {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_navigation_entry_t`] for more documentation.
#[derive(Clone)]
pub struct NavigationEntry(RefGuard<_cef_navigation_entry_t>);
pub trait ImplNavigationEntry: Clone + Sized + Rc {
    #[doc = "See [`_cef_navigation_entry_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_navigation_entry_t::get_url`] for more documentation."]
    fn url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_navigation_entry_t::get_display_url`] for more documentation."]
    fn display_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_navigation_entry_t::get_original_url`] for more documentation."]
    fn original_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_navigation_entry_t::get_title`] for more documentation."]
    fn title(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_navigation_entry_t::get_transition_type`] for more documentation."]
    fn transition_type(&self) -> TransitionType;
    #[doc = "See [`_cef_navigation_entry_t::has_post_data`] for more documentation."]
    fn has_post_data(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_navigation_entry_t::get_completion_time`] for more documentation."]
    fn completion_time(&self) -> Basetime;
    #[doc = "See [`_cef_navigation_entry_t::get_http_status_code`] for more documentation."]
    fn http_status_code(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_navigation_entry_t::get_sslstatus`] for more documentation."]
    fn sslstatus(&self) -> Option<Sslstatus>;
    fn get_raw(&self) -> *mut _cef_navigation_entry_t;
}
impl ImplNavigationEntry for NavigationEntry {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn display_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_display_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn original_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_original_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn title(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn transition_type(&self) -> TransitionType {
        unsafe {
            self.0
                .get_transition_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_post_data(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_post_data
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn completion_time(&self) -> Basetime {
        unsafe {
            self.0
                .get_completion_time
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn http_status_code(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_http_status_code
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn sslstatus(&self) -> Option<Sslstatus> {
        unsafe {
            self.0
                .get_sslstatus
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_navigation_entry_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_navigation_entry_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for NavigationEntry {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_navigation_entry_t> for &NavigationEntry {
    fn into_raw(self) -> *mut _cef_navigation_entry_t {
        ImplNavigationEntry::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_navigation_entry_t> for &mut NavigationEntry {
    fn into_raw(self) -> *mut _cef_navigation_entry_t {
        ImplNavigationEntry::get_raw(self)
    }
}
impl ConvertReturnValue<NavigationEntry> for *mut _cef_navigation_entry_t {
    fn wrap_result(self) -> NavigationEntry {
        NavigationEntry(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<NavigationEntry> for *mut _cef_navigation_entry_t {
    fn from(value: NavigationEntry) -> Self {
        let object = ImplNavigationEntry::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for NavigationEntry {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_registration_t`] for more documentation.
#[derive(Clone)]
pub struct Registration(RefGuard<_cef_registration_t>);
pub trait ImplRegistration: Clone + Sized + Rc {
    fn get_raw(&self) -> *mut _cef_registration_t;
}
impl ImplRegistration for Registration {
    fn get_raw(&self) -> *mut _cef_registration_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_registration_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Registration {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_registration_t> for &Registration {
    fn into_raw(self) -> *mut _cef_registration_t {
        ImplRegistration::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_registration_t> for &mut Registration {
    fn into_raw(self) -> *mut _cef_registration_t {
        ImplRegistration::get_raw(self)
    }
}
impl ConvertReturnValue<Registration> for *mut _cef_registration_t {
    fn wrap_result(self) -> Registration {
        Registration(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Registration> for *mut _cef_registration_t {
    fn from(value: Registration) -> Self {
        let object = ImplRegistration::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Registration {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_callback_t`] for more documentation.
#[derive(Clone)]
pub struct Callback(RefGuard<_cef_callback_t>);
pub trait ImplCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_callback_t::cont`] for more documentation."]
    fn cont(&self);
    #[doc = "See [`_cef_callback_t::cancel`] for more documentation."]
    fn cancel(&self);
    fn get_raw(&self) -> *mut _cef_callback_t;
}
impl ImplCallback for Callback {
    fn cont(&self) {
        unsafe {
            if let Some(f) = self.0.cont {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Callback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_callback_t> for &Callback {
    fn into_raw(self) -> *mut _cef_callback_t {
        ImplCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_callback_t> for &mut Callback {
    fn into_raw(self) -> *mut _cef_callback_t {
        ImplCallback::get_raw(self)
    }
}
impl ConvertReturnValue<Callback> for *mut _cef_callback_t {
    fn wrap_result(self) -> Callback {
        Callback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Callback> for *mut _cef_callback_t {
    fn from(value: Callback) -> Self {
        let object = ImplCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Callback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_completion_callback_t`] for more documentation.
#[derive(Clone)]
pub struct CompletionCallback(RefGuard<_cef_completion_callback_t>);
impl CompletionCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCompletionCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCompletionCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCompletionCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_completion_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapCompletionCallback: ImplCompletionCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_completion_callback_t, Self>);
}
pub trait ImplCompletionCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_completion_callback_t::on_complete`] for more documentation."]
    fn on_complete(&self) {}
    fn init_methods(object: &mut _cef_completion_callback_t) {
        impl_cef_completion_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_completion_callback_t;
}
mod impl_cef_completion_callback_t {
    use super::*;
    pub fn init_methods<I: ImplCompletionCallback>(object: &mut _cef_completion_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplCompletionCallback>(self_: *mut _cef_completion_callback_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplCompletionCallback::on_complete(&arg_self_.interface)
    }
}
impl ImplCompletionCallback for CompletionCallback {
    fn on_complete(&self) {
        unsafe {
            if let Some(f) = self.0.on_complete {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_completion_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_completion_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CompletionCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_completion_callback_t> for &CompletionCallback {
    fn into_raw(self) -> *mut _cef_completion_callback_t {
        ImplCompletionCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_completion_callback_t> for &mut CompletionCallback {
    fn into_raw(self) -> *mut _cef_completion_callback_t {
        ImplCompletionCallback::get_raw(self)
    }
}
impl ConvertReturnValue<CompletionCallback> for *mut _cef_completion_callback_t {
    fn wrap_result(self) -> CompletionCallback {
        CompletionCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<CompletionCallback> for *mut _cef_completion_callback_t {
    fn from(value: CompletionCallback) -> Self {
        let object = ImplCompletionCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for CompletionCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_cookie_manager_t`] for more documentation.
#[derive(Clone)]
pub struct CookieManager(RefGuard<_cef_cookie_manager_t>);
pub trait ImplCookieManager: Clone + Sized + Rc {
    #[doc = "See [`_cef_cookie_manager_t::visit_all_cookies`] for more documentation."]
    fn visit_all_cookies(
        &self,
        visitor: Option<&mut impl ImplCookieVisitor>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_cookie_manager_t::visit_url_cookies`] for more documentation."]
    fn visit_url_cookies(
        &self,
        url: Option<&CefString>,
        include_http_only: ::std::os::raw::c_int,
        visitor: Option<&mut impl ImplCookieVisitor>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_cookie_manager_t::set_cookie`] for more documentation."]
    fn set_cookie(
        &self,
        url: Option<&CefString>,
        cookie: Option<&Cookie>,
        callback: Option<&mut impl ImplSetCookieCallback>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_cookie_manager_t::delete_cookies`] for more documentation."]
    fn delete_cookies(
        &self,
        url: Option<&CefString>,
        cookie_name: Option<&CefString>,
        callback: Option<&mut impl ImplDeleteCookiesCallback>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_cookie_manager_t::flush_store`] for more documentation."]
    fn flush_store(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_cookie_manager_t;
}
impl ImplCookieManager for CookieManager {
    fn visit_all_cookies(
        &self,
        visitor: Option<&mut impl ImplCookieVisitor>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit_all_cookies
                .map(|f| {
                    let arg_visitor = visitor;
                    let arg_self_ = self.into_raw();
                    let arg_visitor = arg_visitor
                        .map(|arg| {
                            arg.add_ref();
                            ImplCookieVisitor::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_visitor);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn visit_url_cookies(
        &self,
        url: Option<&CefString>,
        include_http_only: ::std::os::raw::c_int,
        visitor: Option<&mut impl ImplCookieVisitor>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit_url_cookies
                .map(|f| {
                    let (arg_url, arg_include_http_only, arg_visitor) =
                        (url, include_http_only, visitor);
                    let arg_self_ = self.into_raw();
                    let arg_url = arg_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_visitor = arg_visitor
                        .map(|arg| {
                            arg.add_ref();
                            ImplCookieVisitor::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_url, arg_include_http_only, arg_visitor);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_cookie(
        &self,
        url: Option<&CefString>,
        cookie: Option<&Cookie>,
        callback: Option<&mut impl ImplSetCookieCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_cookie
                .map(|f| {
                    let (arg_url, arg_cookie, arg_callback) = (url, cookie, callback);
                    let arg_self_ = self.into_raw();
                    let arg_url = arg_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_cookie = arg_cookie.cloned().map(|arg| arg.into());
                    let arg_cookie = arg_cookie
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplSetCookieCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_url, arg_cookie, arg_callback);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn delete_cookies(
        &self,
        url: Option<&CefString>,
        cookie_name: Option<&CefString>,
        callback: Option<&mut impl ImplDeleteCookiesCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_cookies
                .map(|f| {
                    let (arg_url, arg_cookie_name, arg_callback) = (url, cookie_name, callback);
                    let arg_self_ = self.into_raw();
                    let arg_url = arg_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_cookie_name = arg_cookie_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplDeleteCookiesCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_url, arg_cookie_name, arg_callback);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn flush_store(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .flush_store
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.into_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_cookie_manager_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_cookie_manager_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieManager {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_manager_t> for &CookieManager {
    fn into_raw(self) -> *mut _cef_cookie_manager_t {
        ImplCookieManager::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_cookie_manager_t> for &mut CookieManager {
    fn into_raw(self) -> *mut _cef_cookie_manager_t {
        ImplCookieManager::get_raw(self)
    }
}
impl ConvertReturnValue<CookieManager> for *mut _cef_cookie_manager_t {
    fn wrap_result(self) -> CookieManager {
        CookieManager(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<CookieManager> for *mut _cef_cookie_manager_t {
    fn from(value: CookieManager) -> Self {
        let object = ImplCookieManager::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for CookieManager {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_cookie_visitor_t`] for more documentation.
#[derive(Clone)]
pub struct CookieVisitor(RefGuard<_cef_cookie_visitor_t>);
impl CookieVisitor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCookieVisitor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCookieVisitor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCookieVisitor>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_cookie_visitor_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapCookieVisitor: ImplCookieVisitor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_cookie_visitor_t, Self>);
}
pub trait ImplCookieVisitor: Clone + Sized + Rc {
    #[doc = "See [`_cef_cookie_visitor_t::visit`] for more documentation."]
    fn visit(
        &self,
        cookie: Option<&Cookie>,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_cookie_visitor_t) {
        impl_cef_cookie_visitor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_cookie_visitor_t;
}
mod impl_cef_cookie_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplCookieVisitor>(object: &mut _cef_cookie_visitor_t) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplCookieVisitor>(
        self_: *mut _cef_cookie_visitor_t,
        cookie: *const _cef_cookie_t,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_cookie, arg_count, arg_total, arg_delete_cookie) =
            (self_, cookie, count, total, delete_cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_cookie = if arg_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<Cookie, _>::from(arg_cookie))
        };
        let arg_cookie = arg_cookie.as_ref().map(|arg| arg.as_ref());
        let arg_count = arg_count.into_raw();
        let arg_total = arg_total.into_raw();
        let mut arg_delete_cookie = if arg_delete_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_delete_cookie,
            ))
        };
        let arg_delete_cookie = arg_delete_cookie.as_mut().map(|arg| arg.as_mut());
        ImplCookieVisitor::visit(
            &arg_self_.interface,
            arg_cookie,
            arg_count,
            arg_total,
            arg_delete_cookie,
        )
    }
}
impl ImplCookieVisitor for CookieVisitor {
    fn visit(
        &self,
        cookie: Option<&Cookie>,
        count: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
        delete_cookie: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let (arg_cookie, arg_count, arg_total, arg_delete_cookie) =
                        (cookie, count, total, delete_cookie);
                    let arg_self_ = self.into_raw();
                    let arg_cookie = arg_cookie.cloned().map(|arg| arg.into());
                    let arg_cookie = arg_cookie
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_delete_cookie = arg_delete_cookie
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_cookie,
                        arg_count,
                        arg_total,
                        arg_delete_cookie,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_cookie_visitor_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_cookie_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_visitor_t> for &CookieVisitor {
    fn into_raw(self) -> *mut _cef_cookie_visitor_t {
        ImplCookieVisitor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_cookie_visitor_t> for &mut CookieVisitor {
    fn into_raw(self) -> *mut _cef_cookie_visitor_t {
        ImplCookieVisitor::get_raw(self)
    }
}
impl ConvertReturnValue<CookieVisitor> for *mut _cef_cookie_visitor_t {
    fn wrap_result(self) -> CookieVisitor {
        CookieVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<CookieVisitor> for *mut _cef_cookie_visitor_t {
    fn from(value: CookieVisitor) -> Self {
        let object = ImplCookieVisitor::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for CookieVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_set_cookie_callback_t`] for more documentation.
#[derive(Clone)]
pub struct SetCookieCallback(RefGuard<_cef_set_cookie_callback_t>);
impl SetCookieCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSetCookieCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSetCookieCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSetCookieCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_set_cookie_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapSetCookieCallback: ImplSetCookieCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_set_cookie_callback_t, Self>);
}
pub trait ImplSetCookieCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_set_cookie_callback_t::on_complete`] for more documentation."]
    fn on_complete(&self, success: ::std::os::raw::c_int) {}
    fn init_methods(object: &mut _cef_set_cookie_callback_t) {
        impl_cef_set_cookie_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_set_cookie_callback_t;
}
mod impl_cef_set_cookie_callback_t {
    use super::*;
    pub fn init_methods<I: ImplSetCookieCallback>(object: &mut _cef_set_cookie_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplSetCookieCallback>(
        self_: *mut _cef_set_cookie_callback_t,
        success: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_success) = (self_, success);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_success = arg_success.into_raw();
        ImplSetCookieCallback::on_complete(&arg_self_.interface, arg_success)
    }
}
impl ImplSetCookieCallback for SetCookieCallback {
    fn on_complete(&self, success: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.on_complete {
                let arg_success = success;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_success);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_set_cookie_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_set_cookie_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SetCookieCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_set_cookie_callback_t> for &SetCookieCallback {
    fn into_raw(self) -> *mut _cef_set_cookie_callback_t {
        ImplSetCookieCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_set_cookie_callback_t> for &mut SetCookieCallback {
    fn into_raw(self) -> *mut _cef_set_cookie_callback_t {
        ImplSetCookieCallback::get_raw(self)
    }
}
impl ConvertReturnValue<SetCookieCallback> for *mut _cef_set_cookie_callback_t {
    fn wrap_result(self) -> SetCookieCallback {
        SetCookieCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<SetCookieCallback> for *mut _cef_set_cookie_callback_t {
    fn from(value: SetCookieCallback) -> Self {
        let object = ImplSetCookieCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for SetCookieCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_delete_cookies_callback_t`] for more documentation.
#[derive(Clone)]
pub struct DeleteCookiesCallback(RefGuard<_cef_delete_cookies_callback_t>);
impl DeleteCookiesCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDeleteCookiesCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDeleteCookiesCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDeleteCookiesCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_delete_cookies_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapDeleteCookiesCallback: ImplDeleteCookiesCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_delete_cookies_callback_t, Self>);
}
pub trait ImplDeleteCookiesCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_delete_cookies_callback_t::on_complete`] for more documentation."]
    fn on_complete(&self, num_deleted: ::std::os::raw::c_int) {}
    fn init_methods(object: &mut _cef_delete_cookies_callback_t) {
        impl_cef_delete_cookies_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_delete_cookies_callback_t;
}
mod impl_cef_delete_cookies_callback_t {
    use super::*;
    pub fn init_methods<I: ImplDeleteCookiesCallback>(object: &mut _cef_delete_cookies_callback_t) {
        object.on_complete = Some(on_complete::<I>);
    }
    extern "C" fn on_complete<I: ImplDeleteCookiesCallback>(
        self_: *mut _cef_delete_cookies_callback_t,
        num_deleted: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_num_deleted) = (self_, num_deleted);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_num_deleted = arg_num_deleted.into_raw();
        ImplDeleteCookiesCallback::on_complete(&arg_self_.interface, arg_num_deleted)
    }
}
impl ImplDeleteCookiesCallback for DeleteCookiesCallback {
    fn on_complete(&self, num_deleted: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.on_complete {
                let arg_num_deleted = num_deleted;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_num_deleted);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_delete_cookies_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_delete_cookies_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DeleteCookiesCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_delete_cookies_callback_t> for &DeleteCookiesCallback {
    fn into_raw(self) -> *mut _cef_delete_cookies_callback_t {
        ImplDeleteCookiesCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_delete_cookies_callback_t> for &mut DeleteCookiesCallback {
    fn into_raw(self) -> *mut _cef_delete_cookies_callback_t {
        ImplDeleteCookiesCallback::get_raw(self)
    }
}
impl ConvertReturnValue<DeleteCookiesCallback> for *mut _cef_delete_cookies_callback_t {
    fn wrap_result(self) -> DeleteCookiesCallback {
        DeleteCookiesCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DeleteCookiesCallback> for *mut _cef_delete_cookies_callback_t {
    fn from(value: DeleteCookiesCallback) -> Self {
        let object = ImplDeleteCookiesCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DeleteCookiesCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_media_router_t`] for more documentation.
#[derive(Clone)]
pub struct MediaRouter(RefGuard<_cef_media_router_t>);
pub trait ImplMediaRouter: Clone + Sized + Rc {
    #[doc = "See [`_cef_media_router_t::add_observer`] for more documentation."]
    fn add_observer(&self, observer: Option<&mut impl ImplMediaObserver>) -> Option<Registration>;
    #[doc = "See [`_cef_media_router_t::get_source`] for more documentation."]
    fn source(&self, urn: Option<&CefString>) -> Option<MediaSource>;
    #[doc = "See [`_cef_media_router_t::notify_current_sinks`] for more documentation."]
    fn notify_current_sinks(&self);
    #[doc = "See [`_cef_media_router_t::create_route`] for more documentation."]
    fn create_route(
        &self,
        source: Option<&mut MediaSource>,
        sink: Option<&mut MediaSink>,
        callback: Option<&mut impl ImplMediaRouteCreateCallback>,
    );
    #[doc = "See [`_cef_media_router_t::notify_current_routes`] for more documentation."]
    fn notify_current_routes(&self);
    fn get_raw(&self) -> *mut _cef_media_router_t;
}
impl ImplMediaRouter for MediaRouter {
    fn add_observer(&self, observer: Option<&mut impl ImplMediaObserver>) -> Option<Registration> {
        unsafe {
            self.0
                .add_observer
                .map(|f| {
                    let arg_observer = observer;
                    let arg_self_ = self.into_raw();
                    let arg_observer = arg_observer
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaObserver::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_observer);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn source(&self, urn: Option<&CefString>) -> Option<MediaSource> {
        unsafe {
            self.0
                .get_source
                .map(|f| {
                    let arg_urn = urn;
                    let arg_self_ = self.into_raw();
                    let arg_urn = arg_urn
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_urn);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn notify_current_sinks(&self) {
        unsafe {
            if let Some(f) = self.0.notify_current_sinks {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn create_route(
        &self,
        source: Option<&mut MediaSource>,
        sink: Option<&mut MediaSink>,
        callback: Option<&mut impl ImplMediaRouteCreateCallback>,
    ) {
        unsafe {
            if let Some(f) = self.0.create_route {
                let (arg_source, arg_sink, arg_callback) = (source, sink, callback);
                let arg_self_ = self.into_raw();
                let arg_source = arg_source
                    .map(|arg| {
                        arg.add_ref();
                        ImplMediaSource::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_sink = arg_sink
                    .map(|arg| {
                        arg.add_ref();
                        ImplMediaSink::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplMediaRouteCreateCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_source, arg_sink, arg_callback);
            }
        }
    }
    fn notify_current_routes(&self) {
        unsafe {
            if let Some(f) = self.0.notify_current_routes {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_media_router_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_media_router_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRouter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_router_t> for &MediaRouter {
    fn into_raw(self) -> *mut _cef_media_router_t {
        ImplMediaRouter::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_router_t> for &mut MediaRouter {
    fn into_raw(self) -> *mut _cef_media_router_t {
        ImplMediaRouter::get_raw(self)
    }
}
impl ConvertReturnValue<MediaRouter> for *mut _cef_media_router_t {
    fn wrap_result(self) -> MediaRouter {
        MediaRouter(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MediaRouter> for *mut _cef_media_router_t {
    fn from(value: MediaRouter) -> Self {
        let object = ImplMediaRouter::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MediaRouter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_media_observer_t`] for more documentation.
#[derive(Clone)]
pub struct MediaObserver(RefGuard<_cef_media_observer_t>);
impl MediaObserver {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaObserver,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaObserver>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaObserver>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_media_observer_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapMediaObserver: ImplMediaObserver {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_observer_t, Self>);
}
pub trait ImplMediaObserver: Clone + Sized + Rc {
    #[doc = "See [`_cef_media_observer_t::on_sinks`] for more documentation."]
    fn on_sinks(&self, sinks: Option<&[Option<MediaSink>]>) {}
    #[doc = "See [`_cef_media_observer_t::on_routes`] for more documentation."]
    fn on_routes(&self, routes: Option<&[Option<MediaRoute>]>) {}
    #[doc = "See [`_cef_media_observer_t::on_route_state_changed`] for more documentation."]
    fn on_route_state_changed(
        &self,
        route: Option<&mut MediaRoute>,
        state: MediaRouteConnectionState,
    ) {
    }
    #[doc = "See [`_cef_media_observer_t::on_route_message_received`] for more documentation."]
    fn on_route_message_received(&self, route: Option<&mut MediaRoute>, message: Option<&[u8]>) {}
    fn init_methods(object: &mut _cef_media_observer_t) {
        impl_cef_media_observer_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_observer_t;
}
mod impl_cef_media_observer_t {
    use super::*;
    pub fn init_methods<I: ImplMediaObserver>(object: &mut _cef_media_observer_t) {
        object.on_sinks = Some(on_sinks::<I>);
        object.on_routes = Some(on_routes::<I>);
        object.on_route_state_changed = Some(on_route_state_changed::<I>);
        object.on_route_message_received = Some(on_route_message_received::<I>);
    }
    extern "C" fn on_sinks<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        sinks_count: usize,
        sinks: *const *mut _cef_media_sink_t,
    ) {
        let (arg_self_, arg_sinks_count, arg_sinks) = (self_, sinks_count, sinks);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let vec_sinks = unsafe { arg_sinks.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_sinks_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(MediaSink(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_sinks = vec_sinks.as_deref();
        ImplMediaObserver::on_sinks(&arg_self_.interface, arg_sinks)
    }
    extern "C" fn on_routes<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        routes_count: usize,
        routes: *const *mut _cef_media_route_t,
    ) {
        let (arg_self_, arg_routes_count, arg_routes) = (self_, routes_count, routes);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let vec_routes = unsafe { arg_routes.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_routes_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(MediaRoute(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_routes = vec_routes.as_deref();
        ImplMediaObserver::on_routes(&arg_self_.interface, arg_routes)
    }
    extern "C" fn on_route_state_changed<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        route: *mut _cef_media_route_t,
        state: cef_media_route_connection_state_t,
    ) {
        let (arg_self_, arg_route, arg_state) = (self_, route, state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_route =
            unsafe { arg_route.as_mut() }.map(|arg| MediaRoute(unsafe { RefGuard::from_raw(arg) }));
        let arg_route = arg_route.as_mut();
        let arg_state = arg_state.into_raw();
        ImplMediaObserver::on_route_state_changed(&arg_self_.interface, arg_route, arg_state)
    }
    extern "C" fn on_route_message_received<I: ImplMediaObserver>(
        self_: *mut _cef_media_observer_t,
        route: *mut _cef_media_route_t,
        message: *const ::std::os::raw::c_void,
        message_size: usize,
    ) {
        let (arg_self_, arg_route, arg_message, arg_message_size) =
            (self_, route, message, message_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_route =
            unsafe { arg_route.as_mut() }.map(|arg| MediaRoute(unsafe { RefGuard::from_raw(arg) }));
        let arg_route = arg_route.as_mut();
        let arg_message = (!arg_message.is_null() && arg_message_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts(arg_message.cast(), arg_message_size) });
        ImplMediaObserver::on_route_message_received(&arg_self_.interface, arg_route, arg_message)
    }
}
impl ImplMediaObserver for MediaObserver {
    fn on_sinks(&self, sinks: Option<&[Option<MediaSink>]>) {
        unsafe {
            if let Some(f) = self.0.on_sinks {
                let arg_sinks = sinks;
                let arg_self_ = self.into_raw();
                let arg_sinks_count = arg_sinks.as_ref().map(|arg| arg.len()).unwrap_or_default();
                let vec_sinks = arg_sinks
                    .as_ref()
                    .map(|arg| {
                        arg.iter()
                            .map(|elem| {
                                elem.as_ref()
                                    .map(|elem| {
                                        elem.add_ref();
                                        elem.get_raw()
                                    })
                                    .unwrap_or(std::ptr::null_mut())
                            })
                            .collect::<Vec<_>>()
                    })
                    .unwrap_or_default();
                let arg_sinks = if vec_sinks.is_empty() {
                    std::ptr::null()
                } else {
                    vec_sinks.as_ptr()
                };
                f(arg_self_, arg_sinks_count, arg_sinks);
            }
        }
    }
    fn on_routes(&self, routes: Option<&[Option<MediaRoute>]>) {
        unsafe {
            if let Some(f) = self.0.on_routes {
                let arg_routes = routes;
                let arg_self_ = self.into_raw();
                let arg_routes_count = arg_routes.as_ref().map(|arg| arg.len()).unwrap_or_default();
                let vec_routes = arg_routes
                    .as_ref()
                    .map(|arg| {
                        arg.iter()
                            .map(|elem| {
                                elem.as_ref()
                                    .map(|elem| {
                                        elem.add_ref();
                                        elem.get_raw()
                                    })
                                    .unwrap_or(std::ptr::null_mut())
                            })
                            .collect::<Vec<_>>()
                    })
                    .unwrap_or_default();
                let arg_routes = if vec_routes.is_empty() {
                    std::ptr::null()
                } else {
                    vec_routes.as_ptr()
                };
                f(arg_self_, arg_routes_count, arg_routes);
            }
        }
    }
    fn on_route_state_changed(
        &self,
        route: Option<&mut MediaRoute>,
        state: MediaRouteConnectionState,
    ) {
        unsafe {
            if let Some(f) = self.0.on_route_state_changed {
                let (arg_route, arg_state) = (route, state);
                let arg_self_ = self.into_raw();
                let arg_route = arg_route
                    .map(|arg| {
                        arg.add_ref();
                        ImplMediaRoute::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_state = arg_state.into_raw();
                f(arg_self_, arg_route, arg_state);
            }
        }
    }
    fn on_route_message_received(&self, route: Option<&mut MediaRoute>, message: Option<&[u8]>) {
        unsafe {
            if let Some(f) = self.0.on_route_message_received {
                let (arg_route, arg_message) = (route, message);
                let arg_self_ = self.into_raw();
                let arg_route = arg_route
                    .map(|arg| {
                        arg.add_ref();
                        ImplMediaRoute::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_message_size = arg_message
                    .as_ref()
                    .map(|arg| arg.len())
                    .unwrap_or_default();
                let arg_message = arg_message
                    .and_then(|arg| {
                        if arg.is_empty() {
                            None
                        } else {
                            Some(arg.as_ptr().cast())
                        }
                    })
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_route, arg_message, arg_message_size);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_media_observer_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_media_observer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaObserver {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_observer_t> for &MediaObserver {
    fn into_raw(self) -> *mut _cef_media_observer_t {
        ImplMediaObserver::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_observer_t> for &mut MediaObserver {
    fn into_raw(self) -> *mut _cef_media_observer_t {
        ImplMediaObserver::get_raw(self)
    }
}
impl ConvertReturnValue<MediaObserver> for *mut _cef_media_observer_t {
    fn wrap_result(self) -> MediaObserver {
        MediaObserver(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MediaObserver> for *mut _cef_media_observer_t {
    fn from(value: MediaObserver) -> Self {
        let object = ImplMediaObserver::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MediaObserver {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_media_route_t`] for more documentation.
#[derive(Clone)]
pub struct MediaRoute(RefGuard<_cef_media_route_t>);
pub trait ImplMediaRoute: Clone + Sized + Rc {
    #[doc = "See [`_cef_media_route_t::get_id`] for more documentation."]
    fn id(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_media_route_t::get_source`] for more documentation."]
    fn source(&self) -> Option<MediaSource>;
    #[doc = "See [`_cef_media_route_t::get_sink`] for more documentation."]
    fn sink(&self) -> Option<MediaSink>;
    #[doc = "See [`_cef_media_route_t::send_route_message`] for more documentation."]
    fn send_route_message(&self, message: Option<&[u8]>);
    #[doc = "See [`_cef_media_route_t::terminate`] for more documentation."]
    fn terminate(&self);
    fn get_raw(&self) -> *mut _cef_media_route_t;
}
impl ImplMediaRoute for MediaRoute {
    fn id(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn source(&self) -> Option<MediaSource> {
        unsafe {
            self.0
                .get_source
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn sink(&self) -> Option<MediaSink> {
        unsafe {
            self.0
                .get_sink
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn send_route_message(&self, message: Option<&[u8]>) {
        unsafe {
            if let Some(f) = self.0.send_route_message {
                let arg_message = message;
                let arg_self_ = self.into_raw();
                let arg_message_size = arg_message
                    .as_ref()
                    .map(|arg| arg.len())
                    .unwrap_or_default();
                let arg_message = arg_message
                    .and_then(|arg| {
                        if arg.is_empty() {
                            None
                        } else {
                            Some(arg.as_ptr().cast())
                        }
                    })
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_message, arg_message_size);
            }
        }
    }
    fn terminate(&self) {
        unsafe {
            if let Some(f) = self.0.terminate {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_media_route_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_media_route_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRoute {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_route_t> for &MediaRoute {
    fn into_raw(self) -> *mut _cef_media_route_t {
        ImplMediaRoute::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_route_t> for &mut MediaRoute {
    fn into_raw(self) -> *mut _cef_media_route_t {
        ImplMediaRoute::get_raw(self)
    }
}
impl ConvertReturnValue<MediaRoute> for *mut _cef_media_route_t {
    fn wrap_result(self) -> MediaRoute {
        MediaRoute(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MediaRoute> for *mut _cef_media_route_t {
    fn from(value: MediaRoute) -> Self {
        let object = ImplMediaRoute::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MediaRoute {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_media_route_create_callback_t`] for more documentation.
#[derive(Clone)]
pub struct MediaRouteCreateCallback(RefGuard<_cef_media_route_create_callback_t>);
impl MediaRouteCreateCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaRouteCreateCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaRouteCreateCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaRouteCreateCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_media_route_create_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapMediaRouteCreateCallback: ImplMediaRouteCreateCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_route_create_callback_t, Self>);
}
pub trait ImplMediaRouteCreateCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_media_route_create_callback_t::on_media_route_create_finished`] for more documentation."]
    fn on_media_route_create_finished(
        &self,
        result: MediaRouteCreateResult,
        error: Option<&CefString>,
        route: Option<&mut MediaRoute>,
    ) {
    }
    fn init_methods(object: &mut _cef_media_route_create_callback_t) {
        impl_cef_media_route_create_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_route_create_callback_t;
}
mod impl_cef_media_route_create_callback_t {
    use super::*;
    pub fn init_methods<I: ImplMediaRouteCreateCallback>(
        object: &mut _cef_media_route_create_callback_t,
    ) {
        object.on_media_route_create_finished = Some(on_media_route_create_finished::<I>);
    }
    extern "C" fn on_media_route_create_finished<I: ImplMediaRouteCreateCallback>(
        self_: *mut _cef_media_route_create_callback_t,
        result: cef_media_route_create_result_t,
        error: *const cef_string_t,
        route: *mut _cef_media_route_t,
    ) {
        let (arg_self_, arg_result, arg_error, arg_route) = (self_, result, error, route);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_result = arg_result.into_raw();
        let arg_error = if arg_error.is_null() {
            None
        } else {
            Some(arg_error.into())
        };
        let arg_error = arg_error.as_ref();
        let mut arg_route =
            unsafe { arg_route.as_mut() }.map(|arg| MediaRoute(unsafe { RefGuard::from_raw(arg) }));
        let arg_route = arg_route.as_mut();
        ImplMediaRouteCreateCallback::on_media_route_create_finished(
            &arg_self_.interface,
            arg_result,
            arg_error,
            arg_route,
        )
    }
}
impl ImplMediaRouteCreateCallback for MediaRouteCreateCallback {
    fn on_media_route_create_finished(
        &self,
        result: MediaRouteCreateResult,
        error: Option<&CefString>,
        route: Option<&mut MediaRoute>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_media_route_create_finished {
                let (arg_result, arg_error, arg_route) = (result, error, route);
                let arg_self_ = self.into_raw();
                let arg_result = arg_result.into_raw();
                let arg_error = arg_error
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_route = arg_route
                    .map(|arg| {
                        arg.add_ref();
                        ImplMediaRoute::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_result, arg_error, arg_route);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_media_route_create_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_media_route_create_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaRouteCreateCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_route_create_callback_t> for &MediaRouteCreateCallback {
    fn into_raw(self) -> *mut _cef_media_route_create_callback_t {
        ImplMediaRouteCreateCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_route_create_callback_t> for &mut MediaRouteCreateCallback {
    fn into_raw(self) -> *mut _cef_media_route_create_callback_t {
        ImplMediaRouteCreateCallback::get_raw(self)
    }
}
impl ConvertReturnValue<MediaRouteCreateCallback> for *mut _cef_media_route_create_callback_t {
    fn wrap_result(self) -> MediaRouteCreateCallback {
        MediaRouteCreateCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MediaRouteCreateCallback> for *mut _cef_media_route_create_callback_t {
    fn from(value: MediaRouteCreateCallback) -> Self {
        let object = ImplMediaRouteCreateCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MediaRouteCreateCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_media_sink_t`] for more documentation.
#[derive(Clone)]
pub struct MediaSink(RefGuard<_cef_media_sink_t>);
pub trait ImplMediaSink: Clone + Sized + Rc {
    #[doc = "See [`_cef_media_sink_t::get_id`] for more documentation."]
    fn id(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_media_sink_t::get_name`] for more documentation."]
    fn name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_media_sink_t::get_icon_type`] for more documentation."]
    fn icon_type(&self) -> MediaSinkIconType;
    #[doc = "See [`_cef_media_sink_t::get_device_info`] for more documentation."]
    fn device_info(&self, callback: Option<&mut impl ImplMediaSinkDeviceInfoCallback>);
    #[doc = "See [`_cef_media_sink_t::is_cast_sink`] for more documentation."]
    fn is_cast_sink(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_media_sink_t::is_dial_sink`] for more documentation."]
    fn is_dial_sink(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_media_sink_t::is_compatible_with`] for more documentation."]
    fn is_compatible_with(&self, source: Option<&mut MediaSource>) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_media_sink_t;
}
impl ImplMediaSink for MediaSink {
    fn id(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn icon_type(&self) -> MediaSinkIconType {
        unsafe {
            self.0
                .get_icon_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn device_info(&self, callback: Option<&mut impl ImplMediaSinkDeviceInfoCallback>) {
        unsafe {
            if let Some(f) = self.0.get_device_info {
                let arg_callback = callback;
                let arg_self_ = self.into_raw();
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplMediaSinkDeviceInfoCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_callback);
            }
        }
    }
    fn is_cast_sink(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_cast_sink
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_dial_sink(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_dial_sink
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_compatible_with(&self, source: Option<&mut MediaSource>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_compatible_with
                .map(|f| {
                    let arg_source = source;
                    let arg_self_ = self.into_raw();
                    let arg_source = arg_source
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaSource::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_source);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_media_sink_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_media_sink_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSink {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_sink_t> for &MediaSink {
    fn into_raw(self) -> *mut _cef_media_sink_t {
        ImplMediaSink::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_sink_t> for &mut MediaSink {
    fn into_raw(self) -> *mut _cef_media_sink_t {
        ImplMediaSink::get_raw(self)
    }
}
impl ConvertReturnValue<MediaSink> for *mut _cef_media_sink_t {
    fn wrap_result(self) -> MediaSink {
        MediaSink(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MediaSink> for *mut _cef_media_sink_t {
    fn from(value: MediaSink) -> Self {
        let object = ImplMediaSink::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MediaSink {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_media_sink_device_info_callback_t`] for more documentation.
#[derive(Clone)]
pub struct MediaSinkDeviceInfoCallback(RefGuard<_cef_media_sink_device_info_callback_t>);
impl MediaSinkDeviceInfoCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMediaSinkDeviceInfoCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMediaSinkDeviceInfoCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMediaSinkDeviceInfoCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_media_sink_device_info_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapMediaSinkDeviceInfoCallback: ImplMediaSinkDeviceInfoCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_media_sink_device_info_callback_t, Self>);
}
pub trait ImplMediaSinkDeviceInfoCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_media_sink_device_info_callback_t::on_media_sink_device_info`] for more documentation."]
    fn on_media_sink_device_info(&self, device_info: Option<&MediaSinkDeviceInfo>) {}
    fn init_methods(object: &mut _cef_media_sink_device_info_callback_t) {
        impl_cef_media_sink_device_info_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_media_sink_device_info_callback_t;
}
mod impl_cef_media_sink_device_info_callback_t {
    use super::*;
    pub fn init_methods<I: ImplMediaSinkDeviceInfoCallback>(
        object: &mut _cef_media_sink_device_info_callback_t,
    ) {
        object.on_media_sink_device_info = Some(on_media_sink_device_info::<I>);
    }
    extern "C" fn on_media_sink_device_info<I: ImplMediaSinkDeviceInfoCallback>(
        self_: *mut _cef_media_sink_device_info_callback_t,
        device_info: *const _cef_media_sink_device_info_t,
    ) {
        let (arg_self_, arg_device_info) = (self_, device_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_device_info = if arg_device_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<MediaSinkDeviceInfo, _>::from(
                arg_device_info,
            ))
        };
        let arg_device_info = arg_device_info.as_ref().map(|arg| arg.as_ref());
        ImplMediaSinkDeviceInfoCallback::on_media_sink_device_info(
            &arg_self_.interface,
            arg_device_info,
        )
    }
}
impl ImplMediaSinkDeviceInfoCallback for MediaSinkDeviceInfoCallback {
    fn on_media_sink_device_info(&self, device_info: Option<&MediaSinkDeviceInfo>) {
        unsafe {
            if let Some(f) = self.0.on_media_sink_device_info {
                let arg_device_info = device_info;
                let arg_self_ = self.into_raw();
                let arg_device_info = arg_device_info.cloned().map(|arg| arg.into());
                let arg_device_info = arg_device_info
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_device_info);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_media_sink_device_info_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_media_sink_device_info_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSinkDeviceInfoCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_sink_device_info_callback_t> for &MediaSinkDeviceInfoCallback {
    fn into_raw(self) -> *mut _cef_media_sink_device_info_callback_t {
        ImplMediaSinkDeviceInfoCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_sink_device_info_callback_t>
    for &mut MediaSinkDeviceInfoCallback
{
    fn into_raw(self) -> *mut _cef_media_sink_device_info_callback_t {
        ImplMediaSinkDeviceInfoCallback::get_raw(self)
    }
}
impl ConvertReturnValue<MediaSinkDeviceInfoCallback>
    for *mut _cef_media_sink_device_info_callback_t
{
    fn wrap_result(self) -> MediaSinkDeviceInfoCallback {
        MediaSinkDeviceInfoCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MediaSinkDeviceInfoCallback> for *mut _cef_media_sink_device_info_callback_t {
    fn from(value: MediaSinkDeviceInfoCallback) -> Self {
        let object = ImplMediaSinkDeviceInfoCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MediaSinkDeviceInfoCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_media_source_t`] for more documentation.
#[derive(Clone)]
pub struct MediaSource(RefGuard<_cef_media_source_t>);
pub trait ImplMediaSource: Clone + Sized + Rc {
    #[doc = "See [`_cef_media_source_t::get_id`] for more documentation."]
    fn id(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_media_source_t::is_cast_source`] for more documentation."]
    fn is_cast_source(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_media_source_t::is_dial_source`] for more documentation."]
    fn is_dial_source(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_media_source_t;
}
impl ImplMediaSource for MediaSource {
    fn id(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_cast_source(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_cast_source
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_dial_source(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_dial_source
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_media_source_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_media_source_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaSource {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_source_t> for &MediaSource {
    fn into_raw(self) -> *mut _cef_media_source_t {
        ImplMediaSource::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_source_t> for &mut MediaSource {
    fn into_raw(self) -> *mut _cef_media_source_t {
        ImplMediaSource::get_raw(self)
    }
}
impl ConvertReturnValue<MediaSource> for *mut _cef_media_source_t {
    fn wrap_result(self) -> MediaSource {
        MediaSource(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MediaSource> for *mut _cef_media_source_t {
    fn from(value: MediaSource) -> Self {
        let object = ImplMediaSource::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MediaSource {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_preference_registrar_t`] for more documentation.
#[derive(Clone, Copy)]
pub struct PreferenceRegistrar(*mut _cef_preference_registrar_t);
pub trait ImplPreferenceRegistrar: Sized {
    #[doc = "See [`_cef_preference_registrar_t::add_preference`] for more documentation."]
    fn add_preference(
        &self,
        name: Option<&CefString>,
        default_value: Option<&mut Value>,
    ) -> ::std::os::raw::c_int;
    fn init_methods(object: &mut _cef_preference_registrar_t) {
        impl_cef_preference_registrar_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_preference_registrar_t;
}
mod impl_cef_preference_registrar_t {
    use super::*;
    pub fn init_methods<I: ImplPreferenceRegistrar>(object: &mut _cef_preference_registrar_t) {
        object.add_preference = Some(add_preference::<I>);
    }
    extern "C" fn add_preference<I: ImplPreferenceRegistrar>(
        self_: *mut _cef_preference_registrar_t,
        name: *const cef_string_t,
        default_value: *mut _cef_value_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_default_value) = (self_, name, default_value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_default_value = unsafe { arg_default_value.as_mut() }
            .map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_default_value = arg_default_value.as_mut();
        ImplPreferenceRegistrar::add_preference(&arg_self_.interface, arg_name, arg_default_value)
    }
}
impl ImplPreferenceRegistrar for PreferenceRegistrar {
    fn add_preference(
        &self,
        name: Option<&CefString>,
        default_value: Option<&mut Value>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .as_ref()
                .and_then(|this| this.add_preference)
                .map(|f| {
                    let (arg_name, arg_default_value) = (name, default_value);
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_default_value = arg_default_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_default_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_preference_registrar_t {
        self.0
    }
}
impl ConvertParam<*mut _cef_preference_registrar_t> for &PreferenceRegistrar {
    fn into_raw(self) -> *mut _cef_preference_registrar_t {
        ImplPreferenceRegistrar::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_preference_registrar_t> for &mut PreferenceRegistrar {
    fn into_raw(self) -> *mut _cef_preference_registrar_t {
        ImplPreferenceRegistrar::get_raw(self)
    }
}
impl ConvertReturnValue<PreferenceRegistrar> for *mut _cef_preference_registrar_t {
    fn wrap_result(self) -> PreferenceRegistrar {
        PreferenceRegistrar(self)
    }
}
impl From<PreferenceRegistrar> for *mut _cef_preference_registrar_t {
    fn from(value: PreferenceRegistrar) -> Self {
        ImplPreferenceRegistrar::get_raw(&value)
    }
}
impl Default for PreferenceRegistrar {
    fn default() -> Self {
        Self(std::ptr::null_mut())
    }
}

/// See [`_cef_preference_observer_t`] for more documentation.
#[derive(Clone)]
pub struct PreferenceObserver(RefGuard<_cef_preference_observer_t>);
impl PreferenceObserver {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPreferenceObserver,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPreferenceObserver>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPreferenceObserver>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_preference_observer_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapPreferenceObserver: ImplPreferenceObserver {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_preference_observer_t, Self>);
}
pub trait ImplPreferenceObserver: Clone + Sized + Rc {
    #[doc = "See [`_cef_preference_observer_t::on_preference_changed`] for more documentation."]
    fn on_preference_changed(&self, name: Option<&CefString>) {}
    fn init_methods(object: &mut _cef_preference_observer_t) {
        impl_cef_preference_observer_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_preference_observer_t;
}
mod impl_cef_preference_observer_t {
    use super::*;
    pub fn init_methods<I: ImplPreferenceObserver>(object: &mut _cef_preference_observer_t) {
        object.on_preference_changed = Some(on_preference_changed::<I>);
    }
    extern "C" fn on_preference_changed<I: ImplPreferenceObserver>(
        self_: *mut _cef_preference_observer_t,
        name: *const cef_string_t,
    ) {
        let (arg_self_, arg_name) = (self_, name);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        ImplPreferenceObserver::on_preference_changed(&arg_self_.interface, arg_name)
    }
}
impl ImplPreferenceObserver for PreferenceObserver {
    fn on_preference_changed(&self, name: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.on_preference_changed {
                let arg_name = name;
                let arg_self_ = self.into_raw();
                let arg_name = arg_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_name);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_preference_observer_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_preference_observer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PreferenceObserver {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_preference_observer_t> for &PreferenceObserver {
    fn into_raw(self) -> *mut _cef_preference_observer_t {
        ImplPreferenceObserver::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_preference_observer_t> for &mut PreferenceObserver {
    fn into_raw(self) -> *mut _cef_preference_observer_t {
        ImplPreferenceObserver::get_raw(self)
    }
}
impl ConvertReturnValue<PreferenceObserver> for *mut _cef_preference_observer_t {
    fn wrap_result(self) -> PreferenceObserver {
        PreferenceObserver(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PreferenceObserver> for *mut _cef_preference_observer_t {
    fn from(value: PreferenceObserver) -> Self {
        let object = ImplPreferenceObserver::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PreferenceObserver {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_preference_manager_t`] for more documentation.
#[derive(Clone)]
pub struct PreferenceManager(RefGuard<_cef_preference_manager_t>);
pub trait ImplPreferenceManager: Clone + Sized + Rc {
    #[doc = "See [`_cef_preference_manager_t::has_preference`] for more documentation."]
    fn has_preference(&self, name: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_preference_manager_t::get_preference`] for more documentation."]
    fn preference(&self, name: Option<&CefString>) -> Option<Value>;
    #[doc = "See [`_cef_preference_manager_t::get_all_preferences`] for more documentation."]
    fn all_preferences(&self, include_defaults: ::std::os::raw::c_int) -> Option<DictionaryValue>;
    #[doc = "See [`_cef_preference_manager_t::can_set_preference`] for more documentation."]
    fn can_set_preference(&self, name: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_preference_manager_t::set_preference`] for more documentation."]
    fn set_preference(
        &self,
        name: Option<&CefString>,
        value: Option<&mut Value>,
        error: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_preference_manager_t::add_preference_observer`] for more documentation."]
    fn add_preference_observer(
        &self,
        name: Option<&CefString>,
        observer: Option<&mut impl ImplPreferenceObserver>,
    ) -> Option<Registration>;
    fn get_raw(&self) -> *mut _cef_preference_manager_t;
}
impl ImplPreferenceManager for PreferenceManager {
    fn has_preference(&self, name: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn preference(&self, name: Option<&CefString>) -> Option<Value> {
        unsafe {
            self.0
                .get_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn all_preferences(&self, include_defaults: ::std::os::raw::c_int) -> Option<DictionaryValue> {
        unsafe {
            self.0
                .get_all_preferences
                .map(|f| {
                    let arg_include_defaults = include_defaults;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_include_defaults);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn can_set_preference(&self, name: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_set_preference
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_preference(
        &self,
        name: Option<&CefString>,
        value: Option<&mut Value>,
        error: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_preference
                .map(|f| {
                    let (arg_name, arg_value, arg_error) = (name, value, error);
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_error = arg_error
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_value, arg_error);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_preference_observer(
        &self,
        name: Option<&CefString>,
        observer: Option<&mut impl ImplPreferenceObserver>,
    ) -> Option<Registration> {
        unsafe {
            self.0
                .add_preference_observer
                .map(|f| {
                    let (arg_name, arg_observer) = (name, observer);
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_observer = arg_observer
                        .map(|arg| {
                            arg.add_ref();
                            ImplPreferenceObserver::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_observer);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_preference_manager_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_preference_manager_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PreferenceManager {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_preference_manager_t> for &PreferenceManager {
    fn into_raw(self) -> *mut _cef_preference_manager_t {
        ImplPreferenceManager::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_preference_manager_t> for &mut PreferenceManager {
    fn into_raw(self) -> *mut _cef_preference_manager_t {
        ImplPreferenceManager::get_raw(self)
    }
}
impl ConvertReturnValue<PreferenceManager> for *mut _cef_preference_manager_t {
    fn wrap_result(self) -> PreferenceManager {
        PreferenceManager(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PreferenceManager> for *mut _cef_preference_manager_t {
    fn from(value: PreferenceManager) -> Self {
        let object = ImplPreferenceManager::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PreferenceManager {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_resolve_callback_t`] for more documentation.
#[derive(Clone)]
pub struct ResolveCallback(RefGuard<_cef_resolve_callback_t>);
impl ResolveCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResolveCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResolveCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResolveCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_resolve_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapResolveCallback: ImplResolveCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resolve_callback_t, Self>);
}
pub trait ImplResolveCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_resolve_callback_t::on_resolve_completed`] for more documentation."]
    fn on_resolve_completed(&self, result: Errorcode, resolved_ips: Option<&mut CefStringList>) {}
    fn init_methods(object: &mut _cef_resolve_callback_t) {
        impl_cef_resolve_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resolve_callback_t;
}
mod impl_cef_resolve_callback_t {
    use super::*;
    pub fn init_methods<I: ImplResolveCallback>(object: &mut _cef_resolve_callback_t) {
        object.on_resolve_completed = Some(on_resolve_completed::<I>);
    }
    extern "C" fn on_resolve_completed<I: ImplResolveCallback>(
        self_: *mut _cef_resolve_callback_t,
        result: cef_errorcode_t,
        resolved_ips: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_result, arg_resolved_ips) = (self_, result, resolved_ips);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_result = arg_result.into_raw();
        let mut arg_resolved_ips = if arg_resolved_ips.is_null() {
            None
        } else {
            Some(arg_resolved_ips.into())
        };
        let arg_resolved_ips = arg_resolved_ips.as_mut();
        ImplResolveCallback::on_resolve_completed(
            &arg_self_.interface,
            arg_result,
            arg_resolved_ips,
        )
    }
}
impl ImplResolveCallback for ResolveCallback {
    fn on_resolve_completed(&self, result: Errorcode, resolved_ips: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.on_resolve_completed {
                let (arg_result, arg_resolved_ips) = (result, resolved_ips);
                let arg_self_ = self.into_raw();
                let arg_result = arg_result.into_raw();
                let arg_resolved_ips = arg_resolved_ips
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_result, arg_resolved_ips);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_resolve_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_resolve_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResolveCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resolve_callback_t> for &ResolveCallback {
    fn into_raw(self) -> *mut _cef_resolve_callback_t {
        ImplResolveCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resolve_callback_t> for &mut ResolveCallback {
    fn into_raw(self) -> *mut _cef_resolve_callback_t {
        ImplResolveCallback::get_raw(self)
    }
}
impl ConvertReturnValue<ResolveCallback> for *mut _cef_resolve_callback_t {
    fn wrap_result(self) -> ResolveCallback {
        ResolveCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ResolveCallback> for *mut _cef_resolve_callback_t {
    fn from(value: ResolveCallback) -> Self {
        let object = ImplResolveCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ResolveCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_setting_observer_t`] for more documentation.
#[derive(Clone)]
pub struct SettingObserver(RefGuard<_cef_setting_observer_t>);
impl SettingObserver {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSettingObserver,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSettingObserver>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSettingObserver>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_setting_observer_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapSettingObserver: ImplSettingObserver {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_setting_observer_t, Self>);
}
pub trait ImplSettingObserver: Clone + Sized + Rc {
    #[doc = "See [`_cef_setting_observer_t::on_setting_changed`] for more documentation."]
    fn on_setting_changed(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
    ) {
    }
    fn init_methods(object: &mut _cef_setting_observer_t) {
        impl_cef_setting_observer_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_setting_observer_t;
}
mod impl_cef_setting_observer_t {
    use super::*;
    pub fn init_methods<I: ImplSettingObserver>(object: &mut _cef_setting_observer_t) {
        object.on_setting_changed = Some(on_setting_changed::<I>);
    }
    extern "C" fn on_setting_changed<I: ImplSettingObserver>(
        self_: *mut _cef_setting_observer_t,
        requesting_url: *const cef_string_t,
        top_level_url: *const cef_string_t,
        content_type: cef_content_setting_types_t,
    ) {
        let (arg_self_, arg_requesting_url, arg_top_level_url, arg_content_type) =
            (self_, requesting_url, top_level_url, content_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_requesting_url = if arg_requesting_url.is_null() {
            None
        } else {
            Some(arg_requesting_url.into())
        };
        let arg_requesting_url = arg_requesting_url.as_ref();
        let arg_top_level_url = if arg_top_level_url.is_null() {
            None
        } else {
            Some(arg_top_level_url.into())
        };
        let arg_top_level_url = arg_top_level_url.as_ref();
        let arg_content_type = arg_content_type.into_raw();
        ImplSettingObserver::on_setting_changed(
            &arg_self_.interface,
            arg_requesting_url,
            arg_top_level_url,
            arg_content_type,
        )
    }
}
impl ImplSettingObserver for SettingObserver {
    fn on_setting_changed(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
    ) {
        unsafe {
            if let Some(f) = self.0.on_setting_changed {
                let (arg_requesting_url, arg_top_level_url, arg_content_type) =
                    (requesting_url, top_level_url, content_type);
                let arg_self_ = self.into_raw();
                let arg_requesting_url = arg_requesting_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_top_level_url = arg_top_level_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_content_type = arg_content_type.into_raw();
                f(
                    arg_self_,
                    arg_requesting_url,
                    arg_top_level_url,
                    arg_content_type,
                );
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_setting_observer_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_setting_observer_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SettingObserver {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_setting_observer_t> for &SettingObserver {
    fn into_raw(self) -> *mut _cef_setting_observer_t {
        ImplSettingObserver::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_setting_observer_t> for &mut SettingObserver {
    fn into_raw(self) -> *mut _cef_setting_observer_t {
        ImplSettingObserver::get_raw(self)
    }
}
impl ConvertReturnValue<SettingObserver> for *mut _cef_setting_observer_t {
    fn wrap_result(self) -> SettingObserver {
        SettingObserver(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<SettingObserver> for *mut _cef_setting_observer_t {
    fn from(value: SettingObserver) -> Self {
        let object = ImplSettingObserver::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for SettingObserver {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_request_context_t`] for more documentation.
#[derive(Clone)]
pub struct RequestContext(RefGuard<_cef_request_context_t>);
pub trait ImplRequestContext: ImplPreferenceManager {
    #[doc = "See [`_cef_request_context_t::is_same`] for more documentation."]
    fn is_same(&self, other: Option<&mut RequestContext>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_request_context_t::is_sharing_with`] for more documentation."]
    fn is_sharing_with(&self, other: Option<&mut RequestContext>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_request_context_t::is_global`] for more documentation."]
    fn is_global(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_request_context_t::get_handler`] for more documentation."]
    fn handler(&self) -> Option<RequestContextHandler>;
    #[doc = "See [`_cef_request_context_t::get_cache_path`] for more documentation."]
    fn cache_path(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_request_context_t::get_cookie_manager`] for more documentation."]
    fn cookie_manager(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> Option<CookieManager>;
    #[doc = "See [`_cef_request_context_t::register_scheme_handler_factory`] for more documentation."]
    fn register_scheme_handler_factory(
        &self,
        scheme_name: Option<&CefString>,
        domain_name: Option<&CefString>,
        factory: Option<&mut impl ImplSchemeHandlerFactory>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_request_context_t::clear_scheme_handler_factories`] for more documentation."]
    fn clear_scheme_handler_factories(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_request_context_t::clear_certificate_exceptions`] for more documentation."]
    fn clear_certificate_exceptions(&self, callback: Option<&mut impl ImplCompletionCallback>);
    #[doc = "See [`_cef_request_context_t::clear_http_auth_credentials`] for more documentation."]
    fn clear_http_auth_credentials(&self, callback: Option<&mut impl ImplCompletionCallback>);
    #[doc = "See [`_cef_request_context_t::close_all_connections`] for more documentation."]
    fn close_all_connections(&self, callback: Option<&mut impl ImplCompletionCallback>);
    #[doc = "See [`_cef_request_context_t::resolve_host`] for more documentation."]
    fn resolve_host(
        &self,
        origin: Option<&CefString>,
        callback: Option<&mut impl ImplResolveCallback>,
    );
    #[doc = "See [`_cef_request_context_t::get_media_router`] for more documentation."]
    fn media_router(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> Option<MediaRouter>;
    #[doc = "See [`_cef_request_context_t::get_website_setting`] for more documentation."]
    fn website_setting(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
    ) -> Option<Value>;
    #[doc = "See [`_cef_request_context_t::set_website_setting`] for more documentation."]
    fn set_website_setting(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
        value: Option<&mut Value>,
    );
    #[doc = "See [`_cef_request_context_t::get_content_setting`] for more documentation."]
    fn content_setting(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
    ) -> ContentSettingValues;
    #[doc = "See [`_cef_request_context_t::set_content_setting`] for more documentation."]
    fn set_content_setting(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
        value: ContentSettingValues,
    );
    #[doc = "See [`_cef_request_context_t::set_chrome_color_scheme`] for more documentation."]
    fn set_chrome_color_scheme(&self, variant: ColorVariant, user_color: u32);
    #[doc = "See [`_cef_request_context_t::get_chrome_color_scheme_mode`] for more documentation."]
    fn chrome_color_scheme_mode(&self) -> ColorVariant;
    #[doc = "See [`_cef_request_context_t::get_chrome_color_scheme_color`] for more documentation."]
    fn chrome_color_scheme_color(&self) -> cef_color_t;
    #[doc = "See [`_cef_request_context_t::get_chrome_color_scheme_variant`] for more documentation."]
    fn chrome_color_scheme_variant(&self) -> ColorVariant;
    #[doc = "See [`_cef_request_context_t::add_setting_observer`] for more documentation."]
    fn add_setting_observer(
        &self,
        observer: Option<&mut impl ImplSettingObserver>,
    ) -> Option<Registration>;
    fn get_raw(&self) -> *mut _cef_request_context_t {
        <Self as ImplPreferenceManager>::get_raw(self).cast()
    }
}
impl ImplPreferenceManager for RequestContext {
    fn has_preference(&self, name: Option<&CefString>) -> ::std::os::raw::c_int {
        PreferenceManager::from(self).has_preference(name)
    }
    fn preference(&self, name: Option<&CefString>) -> Option<Value> {
        PreferenceManager::from(self).preference(name)
    }
    fn all_preferences(&self, include_defaults: ::std::os::raw::c_int) -> Option<DictionaryValue> {
        PreferenceManager::from(self).all_preferences(include_defaults)
    }
    fn can_set_preference(&self, name: Option<&CefString>) -> ::std::os::raw::c_int {
        PreferenceManager::from(self).can_set_preference(name)
    }
    fn set_preference(
        &self,
        name: Option<&CefString>,
        value: Option<&mut Value>,
        error: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        PreferenceManager::from(self).set_preference(name, value, error)
    }
    fn add_preference_observer(
        &self,
        name: Option<&CefString>,
        observer: Option<&mut impl ImplPreferenceObserver>,
    ) -> Option<Registration> {
        PreferenceManager::from(self).add_preference_observer(name, observer)
    }
    fn get_raw(&self) -> *mut _cef_preference_manager_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&RequestContext> for PreferenceManager {
    fn from(from: &RequestContext) -> Self {
        PreferenceManager(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplRequestContext for RequestContext {
    fn is_same(&self, other: Option<&mut RequestContext>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_other = other;
                    let arg_self_ = self.into_raw();
                    let arg_other = arg_other
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequestContext::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_other);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_sharing_with(&self, other: Option<&mut RequestContext>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_sharing_with
                .map(|f| {
                    let arg_other = other;
                    let arg_self_ = self.into_raw();
                    let arg_other = arg_other
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequestContext::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_other);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_global(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_global
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn handler(&self) -> Option<RequestContextHandler> {
        unsafe {
            self.0
                .get_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn cache_path(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_cache_path
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn cookie_manager(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> Option<CookieManager> {
        unsafe {
            self.0
                .get_cookie_manager
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.into_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn register_scheme_handler_factory(
        &self,
        scheme_name: Option<&CefString>,
        domain_name: Option<&CefString>,
        factory: Option<&mut impl ImplSchemeHandlerFactory>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .register_scheme_handler_factory
                .map(|f| {
                    let (arg_scheme_name, arg_domain_name, arg_factory) =
                        (scheme_name, domain_name, factory);
                    let arg_self_ = self.into_raw();
                    let arg_scheme_name = arg_scheme_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_domain_name = arg_domain_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_factory = arg_factory
                        .map(|arg| {
                            arg.add_ref();
                            ImplSchemeHandlerFactory::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_scheme_name, arg_domain_name, arg_factory);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn clear_scheme_handler_factories(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear_scheme_handler_factories
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn clear_certificate_exceptions(&self, callback: Option<&mut impl ImplCompletionCallback>) {
        unsafe {
            if let Some(f) = self.0.clear_certificate_exceptions {
                let arg_callback = callback;
                let arg_self_ = self.into_raw();
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplCompletionCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_callback);
            }
        }
    }
    fn clear_http_auth_credentials(&self, callback: Option<&mut impl ImplCompletionCallback>) {
        unsafe {
            if let Some(f) = self.0.clear_http_auth_credentials {
                let arg_callback = callback;
                let arg_self_ = self.into_raw();
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplCompletionCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_callback);
            }
        }
    }
    fn close_all_connections(&self, callback: Option<&mut impl ImplCompletionCallback>) {
        unsafe {
            if let Some(f) = self.0.close_all_connections {
                let arg_callback = callback;
                let arg_self_ = self.into_raw();
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplCompletionCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_callback);
            }
        }
    }
    fn resolve_host(
        &self,
        origin: Option<&CefString>,
        callback: Option<&mut impl ImplResolveCallback>,
    ) {
        unsafe {
            if let Some(f) = self.0.resolve_host {
                let (arg_origin, arg_callback) = (origin, callback);
                let arg_self_ = self.into_raw();
                let arg_origin = arg_origin
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplResolveCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_origin, arg_callback);
            }
        }
    }
    fn media_router(
        &self,
        callback: Option<&mut impl ImplCompletionCallback>,
    ) -> Option<MediaRouter> {
        unsafe {
            self.0
                .get_media_router
                .map(|f| {
                    let arg_callback = callback;
                    let arg_self_ = self.into_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCompletionCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_callback);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn website_setting(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
    ) -> Option<Value> {
        unsafe {
            self.0
                .get_website_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type) =
                        (requesting_url, top_level_url, content_type);
                    let arg_self_ = self.into_raw();
                    let arg_requesting_url = arg_requesting_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_top_level_url = arg_top_level_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_content_type = arg_content_type.into_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_website_setting(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
        value: Option<&mut Value>,
    ) {
        unsafe {
            if let Some(f) = self.0.set_website_setting {
                let (arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
                    (requesting_url, top_level_url, content_type, value);
                let arg_self_ = self.into_raw();
                let arg_requesting_url = arg_requesting_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_top_level_url = arg_top_level_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_content_type = arg_content_type.into_raw();
                let arg_value = arg_value
                    .map(|arg| {
                        arg.add_ref();
                        ImplValue::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_requesting_url,
                    arg_top_level_url,
                    arg_content_type,
                    arg_value,
                );
            }
        }
    }
    fn content_setting(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
    ) -> ContentSettingValues {
        unsafe {
            self.0
                .get_content_setting
                .map(|f| {
                    let (arg_requesting_url, arg_top_level_url, arg_content_type) =
                        (requesting_url, top_level_url, content_type);
                    let arg_self_ = self.into_raw();
                    let arg_requesting_url = arg_requesting_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_top_level_url = arg_top_level_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_content_type = arg_content_type.into_raw();
                    let result = f(
                        arg_self_,
                        arg_requesting_url,
                        arg_top_level_url,
                        arg_content_type,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_content_setting(
        &self,
        requesting_url: Option<&CefString>,
        top_level_url: Option<&CefString>,
        content_type: ContentSettingTypes,
        value: ContentSettingValues,
    ) {
        unsafe {
            if let Some(f) = self.0.set_content_setting {
                let (arg_requesting_url, arg_top_level_url, arg_content_type, arg_value) =
                    (requesting_url, top_level_url, content_type, value);
                let arg_self_ = self.into_raw();
                let arg_requesting_url = arg_requesting_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_top_level_url = arg_top_level_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_content_type = arg_content_type.into_raw();
                let arg_value = arg_value.into_raw();
                f(
                    arg_self_,
                    arg_requesting_url,
                    arg_top_level_url,
                    arg_content_type,
                    arg_value,
                );
            }
        }
    }
    fn set_chrome_color_scheme(&self, variant: ColorVariant, user_color: u32) {
        unsafe {
            if let Some(f) = self.0.set_chrome_color_scheme {
                let (arg_variant, arg_user_color) = (variant, user_color);
                let arg_self_ = self.into_raw();
                let arg_variant = arg_variant.into_raw();
                f(arg_self_, arg_variant, arg_user_color);
            }
        }
    }
    fn chrome_color_scheme_mode(&self) -> ColorVariant {
        unsafe {
            self.0
                .get_chrome_color_scheme_mode
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn chrome_color_scheme_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_chrome_color_scheme_color
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn chrome_color_scheme_variant(&self) -> ColorVariant {
        unsafe {
            self.0
                .get_chrome_color_scheme_variant
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_setting_observer(
        &self,
        observer: Option<&mut impl ImplSettingObserver>,
    ) -> Option<Registration> {
        unsafe {
            self.0
                .add_setting_observer
                .map(|f| {
                    let arg_observer = observer;
                    let arg_self_ = self.into_raw();
                    let arg_observer = arg_observer
                        .map(|arg| {
                            arg.add_ref();
                            ImplSettingObserver::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_observer);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_request_context_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_request_context_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestContext {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_context_t> for &RequestContext {
    fn into_raw(self) -> *mut _cef_request_context_t {
        ImplRequestContext::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_request_context_t> for &mut RequestContext {
    fn into_raw(self) -> *mut _cef_request_context_t {
        ImplRequestContext::get_raw(self)
    }
}
impl ConvertReturnValue<RequestContext> for *mut _cef_request_context_t {
    fn wrap_result(self) -> RequestContext {
        RequestContext(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<RequestContext> for *mut _cef_request_context_t {
    fn from(value: RequestContext) -> Self {
        let object = ImplRequestContext::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for RequestContext {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_browser_t`] for more documentation.
#[derive(Clone)]
pub struct Browser(RefGuard<_cef_browser_t>);
pub trait ImplBrowser: Clone + Sized + Rc {
    #[doc = "See [`_cef_browser_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_t::get_host`] for more documentation."]
    fn host(&self) -> Option<BrowserHost>;
    #[doc = "See [`_cef_browser_t::can_go_back`] for more documentation."]
    fn can_go_back(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_t::go_back`] for more documentation."]
    fn go_back(&self);
    #[doc = "See [`_cef_browser_t::can_go_forward`] for more documentation."]
    fn can_go_forward(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_t::go_forward`] for more documentation."]
    fn go_forward(&self);
    #[doc = "See [`_cef_browser_t::is_loading`] for more documentation."]
    fn is_loading(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_t::reload`] for more documentation."]
    fn reload(&self);
    #[doc = "See [`_cef_browser_t::reload_ignore_cache`] for more documentation."]
    fn reload_ignore_cache(&self);
    #[doc = "See [`_cef_browser_t::stop_load`] for more documentation."]
    fn stop_load(&self);
    #[doc = "See [`_cef_browser_t::get_identifier`] for more documentation."]
    fn identifier(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut Browser>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_t::is_popup`] for more documentation."]
    fn is_popup(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_t::has_document`] for more documentation."]
    fn has_document(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_t::get_main_frame`] for more documentation."]
    fn main_frame(&self) -> Option<Frame>;
    #[doc = "See [`_cef_browser_t::get_focused_frame`] for more documentation."]
    fn focused_frame(&self) -> Option<Frame>;
    #[doc = "See [`_cef_browser_t::get_frame_by_identifier`] for more documentation."]
    fn frame_by_identifier(&self, identifier: Option<&CefString>) -> Option<Frame>;
    #[doc = "See [`_cef_browser_t::get_frame_by_name`] for more documentation."]
    fn frame_by_name(&self, name: Option<&CefString>) -> Option<Frame>;
    #[doc = "See [`_cef_browser_t::get_frame_count`] for more documentation."]
    fn frame_count(&self) -> usize;
    #[doc = "See [`_cef_browser_t::get_frame_identifiers`] for more documentation."]
    fn frame_identifiers(&self, identifiers: Option<&mut CefStringList>);
    #[doc = "See [`_cef_browser_t::get_frame_names`] for more documentation."]
    fn frame_names(&self, names: Option<&mut CefStringList>);
    fn get_raw(&self) -> *mut _cef_browser_t;
}
impl ImplBrowser for Browser {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn host(&self) -> Option<BrowserHost> {
        unsafe {
            self.0
                .get_host
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn can_go_back(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_go_back
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn go_back(&self) {
        unsafe {
            if let Some(f) = self.0.go_back {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn can_go_forward(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_go_forward
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn go_forward(&self) {
        unsafe {
            if let Some(f) = self.0.go_forward {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn is_loading(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_loading
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn reload(&self) {
        unsafe {
            if let Some(f) = self.0.reload {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn reload_ignore_cache(&self) {
        unsafe {
            if let Some(f) = self.0.reload_ignore_cache {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn stop_load(&self) {
        unsafe {
            if let Some(f) = self.0.stop_load {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn identifier(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_identifier
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut Browser>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_popup(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_popup
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_document(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_document
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn main_frame(&self) -> Option<Frame> {
        unsafe {
            self.0
                .get_main_frame
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn focused_frame(&self) -> Option<Frame> {
        unsafe {
            self.0
                .get_focused_frame
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn frame_by_identifier(&self, identifier: Option<&CefString>) -> Option<Frame> {
        unsafe {
            self.0
                .get_frame_by_identifier
                .map(|f| {
                    let arg_identifier = identifier;
                    let arg_self_ = self.into_raw();
                    let arg_identifier = arg_identifier
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_identifier);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn frame_by_name(&self, name: Option<&CefString>) -> Option<Frame> {
        unsafe {
            self.0
                .get_frame_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn frame_count(&self) -> usize {
        unsafe {
            self.0
                .get_frame_count
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn frame_identifiers(&self, identifiers: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.get_frame_identifiers {
                let arg_identifiers = identifiers;
                let arg_self_ = self.into_raw();
                let arg_identifiers = arg_identifiers
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_identifiers);
            }
        }
    }
    fn frame_names(&self, names: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.get_frame_names {
                let arg_names = names;
                let arg_self_ = self.into_raw();
                let arg_names = arg_names
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_names);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_browser_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Browser {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_t> for &Browser {
    fn into_raw(self) -> *mut _cef_browser_t {
        ImplBrowser::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_t> for &mut Browser {
    fn into_raw(self) -> *mut _cef_browser_t {
        ImplBrowser::get_raw(self)
    }
}
impl ConvertReturnValue<Browser> for *mut _cef_browser_t {
    fn wrap_result(self) -> Browser {
        Browser(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Browser> for *mut _cef_browser_t {
    fn from(value: Browser) -> Self {
        let object = ImplBrowser::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Browser {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_run_file_dialog_callback_t`] for more documentation.
#[derive(Clone)]
pub struct RunFileDialogCallback(RefGuard<_cef_run_file_dialog_callback_t>);
impl RunFileDialogCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRunFileDialogCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRunFileDialogCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRunFileDialogCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_run_file_dialog_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapRunFileDialogCallback: ImplRunFileDialogCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_run_file_dialog_callback_t, Self>);
}
pub trait ImplRunFileDialogCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_run_file_dialog_callback_t::on_file_dialog_dismissed`] for more documentation."]
    fn on_file_dialog_dismissed(&self, file_paths: Option<&mut CefStringList>) {}
    fn init_methods(object: &mut _cef_run_file_dialog_callback_t) {
        impl_cef_run_file_dialog_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_run_file_dialog_callback_t;
}
mod impl_cef_run_file_dialog_callback_t {
    use super::*;
    pub fn init_methods<I: ImplRunFileDialogCallback>(
        object: &mut _cef_run_file_dialog_callback_t,
    ) {
        object.on_file_dialog_dismissed = Some(on_file_dialog_dismissed::<I>);
    }
    extern "C" fn on_file_dialog_dismissed<I: ImplRunFileDialogCallback>(
        self_: *mut _cef_run_file_dialog_callback_t,
        file_paths: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_file_paths) = (self_, file_paths);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_file_paths = if arg_file_paths.is_null() {
            None
        } else {
            Some(arg_file_paths.into())
        };
        let arg_file_paths = arg_file_paths.as_mut();
        ImplRunFileDialogCallback::on_file_dialog_dismissed(&arg_self_.interface, arg_file_paths)
    }
}
impl ImplRunFileDialogCallback for RunFileDialogCallback {
    fn on_file_dialog_dismissed(&self, file_paths: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.on_file_dialog_dismissed {
                let arg_file_paths = file_paths;
                let arg_self_ = self.into_raw();
                let arg_file_paths = arg_file_paths
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_file_paths);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_run_file_dialog_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_run_file_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunFileDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_file_dialog_callback_t> for &RunFileDialogCallback {
    fn into_raw(self) -> *mut _cef_run_file_dialog_callback_t {
        ImplRunFileDialogCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_run_file_dialog_callback_t> for &mut RunFileDialogCallback {
    fn into_raw(self) -> *mut _cef_run_file_dialog_callback_t {
        ImplRunFileDialogCallback::get_raw(self)
    }
}
impl ConvertReturnValue<RunFileDialogCallback> for *mut _cef_run_file_dialog_callback_t {
    fn wrap_result(self) -> RunFileDialogCallback {
        RunFileDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<RunFileDialogCallback> for *mut _cef_run_file_dialog_callback_t {
    fn from(value: RunFileDialogCallback) -> Self {
        let object = ImplRunFileDialogCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for RunFileDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_navigation_entry_visitor_t`] for more documentation.
#[derive(Clone)]
pub struct NavigationEntryVisitor(RefGuard<_cef_navigation_entry_visitor_t>);
impl NavigationEntryVisitor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapNavigationEntryVisitor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplNavigationEntryVisitor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapNavigationEntryVisitor>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_navigation_entry_visitor_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapNavigationEntryVisitor: ImplNavigationEntryVisitor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_navigation_entry_visitor_t, Self>);
}
pub trait ImplNavigationEntryVisitor: Clone + Sized + Rc {
    #[doc = "See [`_cef_navigation_entry_visitor_t::visit`] for more documentation."]
    fn visit(
        &self,
        entry: Option<&mut NavigationEntry>,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_navigation_entry_visitor_t) {
        impl_cef_navigation_entry_visitor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_navigation_entry_visitor_t;
}
mod impl_cef_navigation_entry_visitor_t {
    use super::*;
    pub fn init_methods<I: ImplNavigationEntryVisitor>(
        object: &mut _cef_navigation_entry_visitor_t,
    ) {
        object.visit = Some(visit::<I>);
    }
    extern "C" fn visit<I: ImplNavigationEntryVisitor>(
        self_: *mut _cef_navigation_entry_visitor_t,
        entry: *mut _cef_navigation_entry_t,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_entry, arg_current, arg_index, arg_total) =
            (self_, entry, current, index, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_entry = unsafe { arg_entry.as_mut() }
            .map(|arg| NavigationEntry(unsafe { RefGuard::from_raw(arg) }));
        let arg_entry = arg_entry.as_mut();
        let arg_current = arg_current.into_raw();
        let arg_index = arg_index.into_raw();
        let arg_total = arg_total.into_raw();
        ImplNavigationEntryVisitor::visit(
            &arg_self_.interface,
            arg_entry,
            arg_current,
            arg_index,
            arg_total,
        )
    }
}
impl ImplNavigationEntryVisitor for NavigationEntryVisitor {
    fn visit(
        &self,
        entry: Option<&mut NavigationEntry>,
        current: ::std::os::raw::c_int,
        index: ::std::os::raw::c_int,
        total: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .visit
                .map(|f| {
                    let (arg_entry, arg_current, arg_index, arg_total) =
                        (entry, current, index, total);
                    let arg_self_ = self.into_raw();
                    let arg_entry = arg_entry
                        .map(|arg| {
                            arg.add_ref();
                            ImplNavigationEntry::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_entry, arg_current, arg_index, arg_total);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_navigation_entry_visitor_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_navigation_entry_visitor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for NavigationEntryVisitor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_navigation_entry_visitor_t> for &NavigationEntryVisitor {
    fn into_raw(self) -> *mut _cef_navigation_entry_visitor_t {
        ImplNavigationEntryVisitor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_navigation_entry_visitor_t> for &mut NavigationEntryVisitor {
    fn into_raw(self) -> *mut _cef_navigation_entry_visitor_t {
        ImplNavigationEntryVisitor::get_raw(self)
    }
}
impl ConvertReturnValue<NavigationEntryVisitor> for *mut _cef_navigation_entry_visitor_t {
    fn wrap_result(self) -> NavigationEntryVisitor {
        NavigationEntryVisitor(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<NavigationEntryVisitor> for *mut _cef_navigation_entry_visitor_t {
    fn from(value: NavigationEntryVisitor) -> Self {
        let object = ImplNavigationEntryVisitor::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for NavigationEntryVisitor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_pdf_print_callback_t`] for more documentation.
#[derive(Clone)]
pub struct PdfPrintCallback(RefGuard<_cef_pdf_print_callback_t>);
impl PdfPrintCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPdfPrintCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPdfPrintCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPdfPrintCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_pdf_print_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapPdfPrintCallback: ImplPdfPrintCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_pdf_print_callback_t, Self>);
}
pub trait ImplPdfPrintCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_pdf_print_callback_t::on_pdf_print_finished`] for more documentation."]
    fn on_pdf_print_finished(&self, path: Option<&CefString>, ok: ::std::os::raw::c_int) {}
    fn init_methods(object: &mut _cef_pdf_print_callback_t) {
        impl_cef_pdf_print_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_pdf_print_callback_t;
}
mod impl_cef_pdf_print_callback_t {
    use super::*;
    pub fn init_methods<I: ImplPdfPrintCallback>(object: &mut _cef_pdf_print_callback_t) {
        object.on_pdf_print_finished = Some(on_pdf_print_finished::<I>);
    }
    extern "C" fn on_pdf_print_finished<I: ImplPdfPrintCallback>(
        self_: *mut _cef_pdf_print_callback_t,
        path: *const cef_string_t,
        ok: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_path, arg_ok) = (self_, path, ok);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_path = if arg_path.is_null() {
            None
        } else {
            Some(arg_path.into())
        };
        let arg_path = arg_path.as_ref();
        let arg_ok = arg_ok.into_raw();
        ImplPdfPrintCallback::on_pdf_print_finished(&arg_self_.interface, arg_path, arg_ok)
    }
}
impl ImplPdfPrintCallback for PdfPrintCallback {
    fn on_pdf_print_finished(&self, path: Option<&CefString>, ok: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.on_pdf_print_finished {
                let (arg_path, arg_ok) = (path, ok);
                let arg_self_ = self.into_raw();
                let arg_path = arg_path
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_path, arg_ok);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_pdf_print_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_pdf_print_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PdfPrintCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_pdf_print_callback_t> for &PdfPrintCallback {
    fn into_raw(self) -> *mut _cef_pdf_print_callback_t {
        ImplPdfPrintCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_pdf_print_callback_t> for &mut PdfPrintCallback {
    fn into_raw(self) -> *mut _cef_pdf_print_callback_t {
        ImplPdfPrintCallback::get_raw(self)
    }
}
impl ConvertReturnValue<PdfPrintCallback> for *mut _cef_pdf_print_callback_t {
    fn wrap_result(self) -> PdfPrintCallback {
        PdfPrintCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PdfPrintCallback> for *mut _cef_pdf_print_callback_t {
    fn from(value: PdfPrintCallback) -> Self {
        let object = ImplPdfPrintCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PdfPrintCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_download_image_callback_t`] for more documentation.
#[derive(Clone)]
pub struct DownloadImageCallback(RefGuard<_cef_download_image_callback_t>);
impl DownloadImageCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDownloadImageCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDownloadImageCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDownloadImageCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_download_image_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapDownloadImageCallback: ImplDownloadImageCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_download_image_callback_t, Self>);
}
pub trait ImplDownloadImageCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_download_image_callback_t::on_download_image_finished`] for more documentation."]
    fn on_download_image_finished(
        &self,
        image_url: Option<&CefString>,
        http_status_code: ::std::os::raw::c_int,
        image: Option<&mut Image>,
    ) {
    }
    fn init_methods(object: &mut _cef_download_image_callback_t) {
        impl_cef_download_image_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_download_image_callback_t;
}
mod impl_cef_download_image_callback_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadImageCallback>(object: &mut _cef_download_image_callback_t) {
        object.on_download_image_finished = Some(on_download_image_finished::<I>);
    }
    extern "C" fn on_download_image_finished<I: ImplDownloadImageCallback>(
        self_: *mut _cef_download_image_callback_t,
        image_url: *const cef_string_t,
        http_status_code: ::std::os::raw::c_int,
        image: *mut _cef_image_t,
    ) {
        let (arg_self_, arg_image_url, arg_http_status_code, arg_image) =
            (self_, image_url, http_status_code, image);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_image_url = if arg_image_url.is_null() {
            None
        } else {
            Some(arg_image_url.into())
        };
        let arg_image_url = arg_image_url.as_ref();
        let arg_http_status_code = arg_http_status_code.into_raw();
        let mut arg_image =
            unsafe { arg_image.as_mut() }.map(|arg| Image(unsafe { RefGuard::from_raw(arg) }));
        let arg_image = arg_image.as_mut();
        ImplDownloadImageCallback::on_download_image_finished(
            &arg_self_.interface,
            arg_image_url,
            arg_http_status_code,
            arg_image,
        )
    }
}
impl ImplDownloadImageCallback for DownloadImageCallback {
    fn on_download_image_finished(
        &self,
        image_url: Option<&CefString>,
        http_status_code: ::std::os::raw::c_int,
        image: Option<&mut Image>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_download_image_finished {
                let (arg_image_url, arg_http_status_code, arg_image) =
                    (image_url, http_status_code, image);
                let arg_self_ = self.into_raw();
                let arg_image_url = arg_image_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_image = arg_image
                    .map(|arg| {
                        arg.add_ref();
                        ImplImage::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_image_url, arg_http_status_code, arg_image);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_download_image_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_download_image_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadImageCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_image_callback_t> for &DownloadImageCallback {
    fn into_raw(self) -> *mut _cef_download_image_callback_t {
        ImplDownloadImageCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_download_image_callback_t> for &mut DownloadImageCallback {
    fn into_raw(self) -> *mut _cef_download_image_callback_t {
        ImplDownloadImageCallback::get_raw(self)
    }
}
impl ConvertReturnValue<DownloadImageCallback> for *mut _cef_download_image_callback_t {
    fn wrap_result(self) -> DownloadImageCallback {
        DownloadImageCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DownloadImageCallback> for *mut _cef_download_image_callback_t {
    fn from(value: DownloadImageCallback) -> Self {
        let object = ImplDownloadImageCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DownloadImageCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_browser_host_t`] for more documentation.
#[derive(Clone)]
pub struct BrowserHost(RefGuard<_cef_browser_host_t>);
pub trait ImplBrowserHost: Clone + Sized + Rc {
    #[doc = "See [`_cef_browser_host_t::get_browser`] for more documentation."]
    fn browser(&self) -> Option<Browser>;
    #[doc = "See [`_cef_browser_host_t::close_browser`] for more documentation."]
    fn close_browser(&self, force_close: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::try_close_browser`] for more documentation."]
    fn try_close_browser(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::is_ready_to_be_closed`] for more documentation."]
    fn is_ready_to_be_closed(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::set_focus`] for more documentation."]
    fn set_focus(&self, focus: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::get_window_handle`] for more documentation."]
    fn window_handle(&self) -> cef_window_handle_t;
    #[doc = "See [`_cef_browser_host_t::get_opener_window_handle`] for more documentation."]
    fn opener_window_handle(&self) -> cef_window_handle_t;
    #[doc = "See [`_cef_browser_host_t::get_opener_identifier`] for more documentation."]
    fn opener_identifier(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::has_view`] for more documentation."]
    fn has_view(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::get_client`] for more documentation."]
    fn client(&self) -> Option<Client>;
    #[doc = "See [`_cef_browser_host_t::get_request_context`] for more documentation."]
    fn request_context(&self) -> Option<RequestContext>;
    #[doc = "See [`_cef_browser_host_t::can_zoom`] for more documentation."]
    fn can_zoom(&self, command: ZoomCommand) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::zoom`] for more documentation."]
    fn zoom(&self, command: ZoomCommand);
    #[doc = "See [`_cef_browser_host_t::get_default_zoom_level`] for more documentation."]
    fn default_zoom_level(&self) -> f64;
    #[doc = "See [`_cef_browser_host_t::get_zoom_level`] for more documentation."]
    fn zoom_level(&self) -> f64;
    #[doc = "See [`_cef_browser_host_t::set_zoom_level`] for more documentation."]
    fn set_zoom_level(&self, zoom_level: f64);
    #[doc = "See [`_cef_browser_host_t::run_file_dialog`] for more documentation."]
    fn run_file_dialog(
        &self,
        mode: FileDialogMode,
        title: Option<&CefString>,
        default_file_path: Option<&CefString>,
        accept_filters: Option<&mut CefStringList>,
        callback: Option<&mut impl ImplRunFileDialogCallback>,
    );
    #[doc = "See [`_cef_browser_host_t::start_download`] for more documentation."]
    fn start_download(&self, url: Option<&CefString>);
    #[doc = "See [`_cef_browser_host_t::download_image`] for more documentation."]
    fn download_image(
        &self,
        image_url: Option<&CefString>,
        is_favicon: ::std::os::raw::c_int,
        max_image_size: u32,
        bypass_cache: ::std::os::raw::c_int,
        callback: Option<&mut impl ImplDownloadImageCallback>,
    );
    #[doc = "See [`_cef_browser_host_t::print`] for more documentation."]
    fn print(&self);
    #[doc = "See [`_cef_browser_host_t::print_to_pdf`] for more documentation."]
    fn print_to_pdf(
        &self,
        path: Option<&CefString>,
        settings: Option<&PdfPrintSettings>,
        callback: Option<&mut impl ImplPdfPrintCallback>,
    );
    #[doc = "See [`_cef_browser_host_t::find`] for more documentation."]
    fn find(
        &self,
        search_text: Option<&CefString>,
        forward: ::std::os::raw::c_int,
        match_case: ::std::os::raw::c_int,
        find_next: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_browser_host_t::stop_finding`] for more documentation."]
    fn stop_finding(&self, clear_selection: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::show_dev_tools`] for more documentation."]
    fn show_dev_tools(
        &self,
        window_info: Option<&WindowInfo>,
        client: Option<&mut impl ImplClient>,
        settings: Option<&BrowserSettings>,
        inspect_element_at: Option<&Point>,
    );
    #[doc = "See [`_cef_browser_host_t::close_dev_tools`] for more documentation."]
    fn close_dev_tools(&self);
    #[doc = "See [`_cef_browser_host_t::has_dev_tools`] for more documentation."]
    fn has_dev_tools(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::send_dev_tools_message`] for more documentation."]
    fn send_dev_tools_message(&self, message: Option<&[u8]>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::execute_dev_tools_method`] for more documentation."]
    fn execute_dev_tools_method(
        &self,
        message_id: ::std::os::raw::c_int,
        method: Option<&CefString>,
        params: Option<&mut DictionaryValue>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::add_dev_tools_message_observer`] for more documentation."]
    fn add_dev_tools_message_observer(
        &self,
        observer: Option<&mut impl ImplDevToolsMessageObserver>,
    ) -> Option<Registration>;
    #[doc = "See [`_cef_browser_host_t::get_navigation_entries`] for more documentation."]
    fn navigation_entries(
        &self,
        visitor: Option<&mut impl ImplNavigationEntryVisitor>,
        current_only: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_browser_host_t::replace_misspelling`] for more documentation."]
    fn replace_misspelling(&self, word: Option<&CefString>);
    #[doc = "See [`_cef_browser_host_t::add_word_to_dictionary`] for more documentation."]
    fn add_word_to_dictionary(&self, word: Option<&CefString>);
    #[doc = "See [`_cef_browser_host_t::is_window_rendering_disabled`] for more documentation."]
    fn is_window_rendering_disabled(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::was_resized`] for more documentation."]
    fn was_resized(&self);
    #[doc = "See [`_cef_browser_host_t::was_hidden`] for more documentation."]
    fn was_hidden(&self, hidden: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::notify_screen_info_changed`] for more documentation."]
    fn notify_screen_info_changed(&self);
    #[doc = "See [`_cef_browser_host_t::invalidate`] for more documentation."]
    fn invalidate(&self, type_: PaintElementType);
    #[doc = "See [`_cef_browser_host_t::send_external_begin_frame`] for more documentation."]
    fn send_external_begin_frame(&self);
    #[doc = "See [`_cef_browser_host_t::send_key_event`] for more documentation."]
    fn send_key_event(&self, event: Option<&KeyEvent>);
    #[doc = "See [`_cef_browser_host_t::send_mouse_click_event`] for more documentation."]
    fn send_mouse_click_event(
        &self,
        event: Option<&MouseEvent>,
        type_: MouseButtonType,
        mouse_up: ::std::os::raw::c_int,
        click_count: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_browser_host_t::send_mouse_move_event`] for more documentation."]
    fn send_mouse_move_event(&self, event: Option<&MouseEvent>, mouse_leave: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::send_mouse_wheel_event`] for more documentation."]
    fn send_mouse_wheel_event(
        &self,
        event: Option<&MouseEvent>,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_browser_host_t::send_touch_event`] for more documentation."]
    fn send_touch_event(&self, event: Option<&TouchEvent>);
    #[doc = "See [`_cef_browser_host_t::send_capture_lost_event`] for more documentation."]
    fn send_capture_lost_event(&self);
    #[doc = "See [`_cef_browser_host_t::notify_move_or_resize_started`] for more documentation."]
    fn notify_move_or_resize_started(&self);
    #[doc = "See [`_cef_browser_host_t::get_windowless_frame_rate`] for more documentation."]
    fn windowless_frame_rate(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::set_windowless_frame_rate`] for more documentation."]
    fn set_windowless_frame_rate(&self, frame_rate: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::ime_set_composition`] for more documentation."]
    fn ime_set_composition(
        &self,
        text: Option<&CefString>,
        underlines_count: usize,
        underlines: Option<&CompositionUnderline>,
        replacement_range: Option<&Range>,
        selection_range: Option<&Range>,
    );
    #[doc = "See [`_cef_browser_host_t::ime_commit_text`] for more documentation."]
    fn ime_commit_text(
        &self,
        text: Option<&CefString>,
        replacement_range: Option<&Range>,
        relative_cursor_pos: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_browser_host_t::ime_finish_composing_text`] for more documentation."]
    fn ime_finish_composing_text(&self, keep_selection: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::ime_cancel_composition`] for more documentation."]
    fn ime_cancel_composition(&self);
    #[doc = "See [`_cef_browser_host_t::drag_target_drag_enter`] for more documentation."]
    fn drag_target_drag_enter(
        &self,
        drag_data: Option<&mut DragData>,
        event: Option<&MouseEvent>,
        allowed_ops: DragOperationsMask,
    );
    #[doc = "See [`_cef_browser_host_t::drag_target_drag_over`] for more documentation."]
    fn drag_target_drag_over(&self, event: Option<&MouseEvent>, allowed_ops: DragOperationsMask);
    #[doc = "See [`_cef_browser_host_t::drag_target_drag_leave`] for more documentation."]
    fn drag_target_drag_leave(&self);
    #[doc = "See [`_cef_browser_host_t::drag_target_drop`] for more documentation."]
    fn drag_target_drop(&self, event: Option<&MouseEvent>);
    #[doc = "See [`_cef_browser_host_t::drag_source_ended_at`] for more documentation."]
    fn drag_source_ended_at(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: DragOperationsMask,
    );
    #[doc = "See [`_cef_browser_host_t::drag_source_system_drag_ended`] for more documentation."]
    fn drag_source_system_drag_ended(&self);
    #[doc = "See [`_cef_browser_host_t::get_visible_navigation_entry`] for more documentation."]
    fn visible_navigation_entry(&self) -> Option<NavigationEntry>;
    #[doc = "See [`_cef_browser_host_t::set_accessibility_state`] for more documentation."]
    fn set_accessibility_state(&self, accessibility_state: State);
    #[doc = "See [`_cef_browser_host_t::set_auto_resize_enabled`] for more documentation."]
    fn set_auto_resize_enabled(
        &self,
        enabled: ::std::os::raw::c_int,
        min_size: Option<&Size>,
        max_size: Option<&Size>,
    );
    #[doc = "See [`_cef_browser_host_t::set_audio_muted`] for more documentation."]
    fn set_audio_muted(&self, mute: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::is_audio_muted`] for more documentation."]
    fn is_audio_muted(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::is_fullscreen`] for more documentation."]
    fn is_fullscreen(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::exit_fullscreen`] for more documentation."]
    fn exit_fullscreen(&self, will_cause_resize: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_host_t::can_execute_chrome_command`] for more documentation."]
    fn can_execute_chrome_command(
        &self,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::execute_chrome_command`] for more documentation."]
    fn execute_chrome_command(
        &self,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    );
    #[doc = "See [`_cef_browser_host_t::is_render_process_unresponsive`] for more documentation."]
    fn is_render_process_unresponsive(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_browser_host_t::get_runtime_style`] for more documentation."]
    fn runtime_style(&self) -> RuntimeStyle;
    fn get_raw(&self) -> *mut _cef_browser_host_t;
}
impl ImplBrowserHost for BrowserHost {
    fn browser(&self) -> Option<Browser> {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn close_browser(&self, force_close: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.close_browser {
                let arg_force_close = force_close;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_force_close);
            }
        }
    }
    fn try_close_browser(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .try_close_browser
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_ready_to_be_closed(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_ready_to_be_closed
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_focus(&self, focus: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_focus {
                let arg_focus = focus;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_focus);
            }
        }
    }
    fn window_handle(&self) -> cef_window_handle_t {
        unsafe {
            self.0
                .get_window_handle
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn opener_window_handle(&self) -> cef_window_handle_t {
        unsafe {
            self.0
                .get_opener_window_handle
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn opener_identifier(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_opener_identifier
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_view(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_view
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn client(&self) -> Option<Client> {
        unsafe {
            self.0
                .get_client
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn request_context(&self) -> Option<RequestContext> {
        unsafe {
            self.0
                .get_request_context
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn can_zoom(&self, command: ZoomCommand) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_zoom
                .map(|f| {
                    let arg_command = command;
                    let arg_self_ = self.into_raw();
                    let arg_command = arg_command.into_raw();
                    let result = f(arg_self_, arg_command);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn zoom(&self, command: ZoomCommand) {
        unsafe {
            if let Some(f) = self.0.zoom {
                let arg_command = command;
                let arg_self_ = self.into_raw();
                let arg_command = arg_command.into_raw();
                f(arg_self_, arg_command);
            }
        }
    }
    fn default_zoom_level(&self) -> f64 {
        unsafe {
            self.0
                .get_default_zoom_level
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn zoom_level(&self) -> f64 {
        unsafe {
            self.0
                .get_zoom_level
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_zoom_level(&self, zoom_level: f64) {
        unsafe {
            if let Some(f) = self.0.set_zoom_level {
                let arg_zoom_level = zoom_level;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_zoom_level);
            }
        }
    }
    fn run_file_dialog(
        &self,
        mode: FileDialogMode,
        title: Option<&CefString>,
        default_file_path: Option<&CefString>,
        accept_filters: Option<&mut CefStringList>,
        callback: Option<&mut impl ImplRunFileDialogCallback>,
    ) {
        unsafe {
            if let Some(f) = self.0.run_file_dialog {
                let (arg_mode, arg_title, arg_default_file_path, arg_accept_filters, arg_callback) =
                    (mode, title, default_file_path, accept_filters, callback);
                let arg_self_ = self.into_raw();
                let arg_mode = arg_mode.into_raw();
                let arg_title = arg_title
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_default_file_path = arg_default_file_path
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_accept_filters = arg_accept_filters
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplRunFileDialogCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_mode,
                    arg_title,
                    arg_default_file_path,
                    arg_accept_filters,
                    arg_callback,
                );
            }
        }
    }
    fn start_download(&self, url: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.start_download {
                let arg_url = url;
                let arg_self_ = self.into_raw();
                let arg_url = arg_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_url);
            }
        }
    }
    fn download_image(
        &self,
        image_url: Option<&CefString>,
        is_favicon: ::std::os::raw::c_int,
        max_image_size: u32,
        bypass_cache: ::std::os::raw::c_int,
        callback: Option<&mut impl ImplDownloadImageCallback>,
    ) {
        unsafe {
            if let Some(f) = self.0.download_image {
                let (
                    arg_image_url,
                    arg_is_favicon,
                    arg_max_image_size,
                    arg_bypass_cache,
                    arg_callback,
                ) = (
                    image_url,
                    is_favicon,
                    max_image_size,
                    bypass_cache,
                    callback,
                );
                let arg_self_ = self.into_raw();
                let arg_image_url = arg_image_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplDownloadImageCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_image_url,
                    arg_is_favicon,
                    arg_max_image_size,
                    arg_bypass_cache,
                    arg_callback,
                );
            }
        }
    }
    fn print(&self) {
        unsafe {
            if let Some(f) = self.0.print {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn print_to_pdf(
        &self,
        path: Option<&CefString>,
        settings: Option<&PdfPrintSettings>,
        callback: Option<&mut impl ImplPdfPrintCallback>,
    ) {
        unsafe {
            if let Some(f) = self.0.print_to_pdf {
                let (arg_path, arg_settings, arg_callback) = (path, settings, callback);
                let arg_self_ = self.into_raw();
                let arg_path = arg_path
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_settings = arg_settings.cloned().map(|arg| arg.into());
                let arg_settings = arg_settings
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplPdfPrintCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_path, arg_settings, arg_callback);
            }
        }
    }
    fn find(
        &self,
        search_text: Option<&CefString>,
        forward: ::std::os::raw::c_int,
        match_case: ::std::os::raw::c_int,
        find_next: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.find {
                let (arg_search_text, arg_forward, arg_match_case, arg_find_next) =
                    (search_text, forward, match_case, find_next);
                let arg_self_ = self.into_raw();
                let arg_search_text = arg_search_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_search_text,
                    arg_forward,
                    arg_match_case,
                    arg_find_next,
                );
            }
        }
    }
    fn stop_finding(&self, clear_selection: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.stop_finding {
                let arg_clear_selection = clear_selection;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_clear_selection);
            }
        }
    }
    fn show_dev_tools(
        &self,
        window_info: Option<&WindowInfo>,
        client: Option<&mut impl ImplClient>,
        settings: Option<&BrowserSettings>,
        inspect_element_at: Option<&Point>,
    ) {
        unsafe {
            if let Some(f) = self.0.show_dev_tools {
                let (arg_window_info, arg_client, arg_settings, arg_inspect_element_at) =
                    (window_info, client, settings, inspect_element_at);
                let arg_self_ = self.into_raw();
                let arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
                let arg_window_info = arg_window_info
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_client = arg_client
                    .map(|arg| {
                        arg.add_ref();
                        ImplClient::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_settings = arg_settings.cloned().map(|arg| arg.into());
                let arg_settings = arg_settings
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_inspect_element_at = arg_inspect_element_at.cloned().map(|arg| arg.into());
                let arg_inspect_element_at = arg_inspect_element_at
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_window_info,
                    arg_client,
                    arg_settings,
                    arg_inspect_element_at,
                );
            }
        }
    }
    fn close_dev_tools(&self) {
        unsafe {
            if let Some(f) = self.0.close_dev_tools {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn has_dev_tools(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_dev_tools
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn send_dev_tools_message(&self, message: Option<&[u8]>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .send_dev_tools_message
                .map(|f| {
                    let arg_message = message;
                    let arg_self_ = self.into_raw();
                    let arg_message_size = arg_message
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let arg_message = arg_message
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_message, arg_message_size);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn execute_dev_tools_method(
        &self,
        message_id: ::std::os::raw::c_int,
        method: Option<&CefString>,
        params: Option<&mut DictionaryValue>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .execute_dev_tools_method
                .map(|f| {
                    let (arg_message_id, arg_method, arg_params) = (message_id, method, params);
                    let arg_self_ = self.into_raw();
                    let arg_method = arg_method
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_params = arg_params
                        .map(|arg| {
                            arg.add_ref();
                            ImplDictionaryValue::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_message_id, arg_method, arg_params);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_dev_tools_message_observer(
        &self,
        observer: Option<&mut impl ImplDevToolsMessageObserver>,
    ) -> Option<Registration> {
        unsafe {
            self.0
                .add_dev_tools_message_observer
                .map(|f| {
                    let arg_observer = observer;
                    let arg_self_ = self.into_raw();
                    let arg_observer = arg_observer
                        .map(|arg| {
                            arg.add_ref();
                            ImplDevToolsMessageObserver::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_observer);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn navigation_entries(
        &self,
        visitor: Option<&mut impl ImplNavigationEntryVisitor>,
        current_only: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.get_navigation_entries {
                let (arg_visitor, arg_current_only) = (visitor, current_only);
                let arg_self_ = self.into_raw();
                let arg_visitor = arg_visitor
                    .map(|arg| {
                        arg.add_ref();
                        ImplNavigationEntryVisitor::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_visitor, arg_current_only);
            }
        }
    }
    fn replace_misspelling(&self, word: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.replace_misspelling {
                let arg_word = word;
                let arg_self_ = self.into_raw();
                let arg_word = arg_word
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_word);
            }
        }
    }
    fn add_word_to_dictionary(&self, word: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.add_word_to_dictionary {
                let arg_word = word;
                let arg_self_ = self.into_raw();
                let arg_word = arg_word
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_word);
            }
        }
    }
    fn is_window_rendering_disabled(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_window_rendering_disabled
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn was_resized(&self) {
        unsafe {
            if let Some(f) = self.0.was_resized {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn was_hidden(&self, hidden: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.was_hidden {
                let arg_hidden = hidden;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_hidden);
            }
        }
    }
    fn notify_screen_info_changed(&self) {
        unsafe {
            if let Some(f) = self.0.notify_screen_info_changed {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn invalidate(&self, type_: PaintElementType) {
        unsafe {
            if let Some(f) = self.0.invalidate {
                let arg_type_ = type_;
                let arg_self_ = self.into_raw();
                let arg_type_ = arg_type_.into_raw();
                f(arg_self_, arg_type_);
            }
        }
    }
    fn send_external_begin_frame(&self) {
        unsafe {
            if let Some(f) = self.0.send_external_begin_frame {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn send_key_event(&self, event: Option<&KeyEvent>) {
        unsafe {
            if let Some(f) = self.0.send_key_event {
                let arg_event = event;
                let arg_self_ = self.into_raw();
                let arg_event = arg_event.cloned().map(|arg| arg.into());
                let arg_event = arg_event
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_event);
            }
        }
    }
    fn send_mouse_click_event(
        &self,
        event: Option<&MouseEvent>,
        type_: MouseButtonType,
        mouse_up: ::std::os::raw::c_int,
        click_count: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.send_mouse_click_event {
                let (arg_event, arg_type_, arg_mouse_up, arg_click_count) =
                    (event, type_, mouse_up, click_count);
                let arg_self_ = self.into_raw();
                let arg_event = arg_event.cloned().map(|arg| arg.into());
                let arg_event = arg_event
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_type_ = arg_type_.into_raw();
                f(
                    arg_self_,
                    arg_event,
                    arg_type_,
                    arg_mouse_up,
                    arg_click_count,
                );
            }
        }
    }
    fn send_mouse_move_event(
        &self,
        event: Option<&MouseEvent>,
        mouse_leave: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.send_mouse_move_event {
                let (arg_event, arg_mouse_leave) = (event, mouse_leave);
                let arg_self_ = self.into_raw();
                let arg_event = arg_event.cloned().map(|arg| arg.into());
                let arg_event = arg_event
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_event, arg_mouse_leave);
            }
        }
    }
    fn send_mouse_wheel_event(
        &self,
        event: Option<&MouseEvent>,
        delta_x: ::std::os::raw::c_int,
        delta_y: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.send_mouse_wheel_event {
                let (arg_event, arg_delta_x, arg_delta_y) = (event, delta_x, delta_y);
                let arg_self_ = self.into_raw();
                let arg_event = arg_event.cloned().map(|arg| arg.into());
                let arg_event = arg_event
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_event, arg_delta_x, arg_delta_y);
            }
        }
    }
    fn send_touch_event(&self, event: Option<&TouchEvent>) {
        unsafe {
            if let Some(f) = self.0.send_touch_event {
                let arg_event = event;
                let arg_self_ = self.into_raw();
                let arg_event = arg_event.cloned().map(|arg| arg.into());
                let arg_event = arg_event
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_event);
            }
        }
    }
    fn send_capture_lost_event(&self) {
        unsafe {
            if let Some(f) = self.0.send_capture_lost_event {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn notify_move_or_resize_started(&self) {
        unsafe {
            if let Some(f) = self.0.notify_move_or_resize_started {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn windowless_frame_rate(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_windowless_frame_rate
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_windowless_frame_rate(&self, frame_rate: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_windowless_frame_rate {
                let arg_frame_rate = frame_rate;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_frame_rate);
            }
        }
    }
    fn ime_set_composition(
        &self,
        text: Option<&CefString>,
        underlines_count: usize,
        underlines: Option<&CompositionUnderline>,
        replacement_range: Option<&Range>,
        selection_range: Option<&Range>,
    ) {
        unsafe {
            if let Some(f) = self.0.ime_set_composition {
                let (
                    arg_text,
                    arg_underlines_count,
                    arg_underlines,
                    arg_replacement_range,
                    arg_selection_range,
                ) = (
                    text,
                    underlines_count,
                    underlines,
                    replacement_range,
                    selection_range,
                );
                let arg_self_ = self.into_raw();
                let arg_text = arg_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_underlines = arg_underlines.cloned().map(|arg| arg.into());
                let arg_underlines = arg_underlines
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_replacement_range = arg_replacement_range.cloned().map(|arg| arg.into());
                let arg_replacement_range = arg_replacement_range
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_selection_range = arg_selection_range.cloned().map(|arg| arg.into());
                let arg_selection_range = arg_selection_range
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_text,
                    arg_underlines_count,
                    arg_underlines,
                    arg_replacement_range,
                    arg_selection_range,
                );
            }
        }
    }
    fn ime_commit_text(
        &self,
        text: Option<&CefString>,
        replacement_range: Option<&Range>,
        relative_cursor_pos: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.ime_commit_text {
                let (arg_text, arg_replacement_range, arg_relative_cursor_pos) =
                    (text, replacement_range, relative_cursor_pos);
                let arg_self_ = self.into_raw();
                let arg_text = arg_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_replacement_range = arg_replacement_range.cloned().map(|arg| arg.into());
                let arg_replacement_range = arg_replacement_range
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_text,
                    arg_replacement_range,
                    arg_relative_cursor_pos,
                );
            }
        }
    }
    fn ime_finish_composing_text(&self, keep_selection: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.ime_finish_composing_text {
                let arg_keep_selection = keep_selection;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_keep_selection);
            }
        }
    }
    fn ime_cancel_composition(&self) {
        unsafe {
            if let Some(f) = self.0.ime_cancel_composition {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn drag_target_drag_enter(
        &self,
        drag_data: Option<&mut DragData>,
        event: Option<&MouseEvent>,
        allowed_ops: DragOperationsMask,
    ) {
        unsafe {
            if let Some(f) = self.0.drag_target_drag_enter {
                let (arg_drag_data, arg_event, arg_allowed_ops) = (drag_data, event, allowed_ops);
                let arg_self_ = self.into_raw();
                let arg_drag_data = arg_drag_data
                    .map(|arg| {
                        arg.add_ref();
                        ImplDragData::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_event = arg_event.cloned().map(|arg| arg.into());
                let arg_event = arg_event
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_allowed_ops = arg_allowed_ops.into_raw();
                f(arg_self_, arg_drag_data, arg_event, arg_allowed_ops);
            }
        }
    }
    fn drag_target_drag_over(&self, event: Option<&MouseEvent>, allowed_ops: DragOperationsMask) {
        unsafe {
            if let Some(f) = self.0.drag_target_drag_over {
                let (arg_event, arg_allowed_ops) = (event, allowed_ops);
                let arg_self_ = self.into_raw();
                let arg_event = arg_event.cloned().map(|arg| arg.into());
                let arg_event = arg_event
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_allowed_ops = arg_allowed_ops.into_raw();
                f(arg_self_, arg_event, arg_allowed_ops);
            }
        }
    }
    fn drag_target_drag_leave(&self) {
        unsafe {
            if let Some(f) = self.0.drag_target_drag_leave {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn drag_target_drop(&self, event: Option<&MouseEvent>) {
        unsafe {
            if let Some(f) = self.0.drag_target_drop {
                let arg_event = event;
                let arg_self_ = self.into_raw();
                let arg_event = arg_event.cloned().map(|arg| arg.into());
                let arg_event = arg_event
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_event);
            }
        }
    }
    fn drag_source_ended_at(
        &self,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        op: DragOperationsMask,
    ) {
        unsafe {
            if let Some(f) = self.0.drag_source_ended_at {
                let (arg_x, arg_y, arg_op) = (x, y, op);
                let arg_self_ = self.into_raw();
                let arg_op = arg_op.into_raw();
                f(arg_self_, arg_x, arg_y, arg_op);
            }
        }
    }
    fn drag_source_system_drag_ended(&self) {
        unsafe {
            if let Some(f) = self.0.drag_source_system_drag_ended {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn visible_navigation_entry(&self) -> Option<NavigationEntry> {
        unsafe {
            self.0
                .get_visible_navigation_entry
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_accessibility_state(&self, accessibility_state: State) {
        unsafe {
            if let Some(f) = self.0.set_accessibility_state {
                let arg_accessibility_state = accessibility_state;
                let arg_self_ = self.into_raw();
                let arg_accessibility_state = arg_accessibility_state.into_raw();
                f(arg_self_, arg_accessibility_state);
            }
        }
    }
    fn set_auto_resize_enabled(
        &self,
        enabled: ::std::os::raw::c_int,
        min_size: Option<&Size>,
        max_size: Option<&Size>,
    ) {
        unsafe {
            if let Some(f) = self.0.set_auto_resize_enabled {
                let (arg_enabled, arg_min_size, arg_max_size) = (enabled, min_size, max_size);
                let arg_self_ = self.into_raw();
                let arg_min_size = arg_min_size.cloned().map(|arg| arg.into());
                let arg_min_size = arg_min_size
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_max_size = arg_max_size.cloned().map(|arg| arg.into());
                let arg_max_size = arg_max_size
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_enabled, arg_min_size, arg_max_size);
            }
        }
    }
    fn set_audio_muted(&self, mute: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_audio_muted {
                let arg_mute = mute;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_mute);
            }
        }
    }
    fn is_audio_muted(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_audio_muted
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_fullscreen(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fullscreen
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn exit_fullscreen(&self, will_cause_resize: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.exit_fullscreen {
                let arg_will_cause_resize = will_cause_resize;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_will_cause_resize);
            }
        }
    }
    fn can_execute_chrome_command(
        &self,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_execute_chrome_command
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn execute_chrome_command(
        &self,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) {
        unsafe {
            if let Some(f) = self.0.execute_chrome_command {
                let (arg_command_id, arg_disposition) = (command_id, disposition);
                let arg_self_ = self.into_raw();
                let arg_disposition = arg_disposition.into_raw();
                f(arg_self_, arg_command_id, arg_disposition);
            }
        }
    }
    fn is_render_process_unresponsive(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_render_process_unresponsive
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_host_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_browser_host_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserHost {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_host_t> for &BrowserHost {
    fn into_raw(self) -> *mut _cef_browser_host_t {
        ImplBrowserHost::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_host_t> for &mut BrowserHost {
    fn into_raw(self) -> *mut _cef_browser_host_t {
        ImplBrowserHost::get_raw(self)
    }
}
impl ConvertReturnValue<BrowserHost> for *mut _cef_browser_host_t {
    fn wrap_result(self) -> BrowserHost {
        BrowserHost(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<BrowserHost> for *mut _cef_browser_host_t {
    fn from(value: BrowserHost) -> Self {
        let object = ImplBrowserHost::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for BrowserHost {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_audio_handler_t`] for more documentation.
#[derive(Clone)]
pub struct AudioHandler(RefGuard<_cef_audio_handler_t>);
impl AudioHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapAudioHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplAudioHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapAudioHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_audio_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapAudioHandler: ImplAudioHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_audio_handler_t, Self>);
}
pub trait ImplAudioHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_audio_handler_t::get_audio_parameters`] for more documentation."]
    fn audio_parameters(
        &self,
        browser: Option<&mut Browser>,
        params: Option<&mut AudioParameters>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_audio_handler_t::on_audio_stream_started`] for more documentation."]
    fn on_audio_stream_started(
        &self,
        browser: Option<&mut Browser>,
        params: Option<&AudioParameters>,
        channels: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_audio_handler_t::on_audio_stream_packet`] for more documentation."]
    fn on_audio_stream_packet(
        &self,
        browser: Option<&mut Browser>,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
    }
    #[doc = "See [`_cef_audio_handler_t::on_audio_stream_stopped`] for more documentation."]
    fn on_audio_stream_stopped(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_audio_handler_t::on_audio_stream_error`] for more documentation."]
    fn on_audio_stream_error(&self, browser: Option<&mut Browser>, message: Option<&CefString>) {}
    fn init_methods(object: &mut _cef_audio_handler_t) {
        impl_cef_audio_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_audio_handler_t;
}
mod impl_cef_audio_handler_t {
    use super::*;
    pub fn init_methods<I: ImplAudioHandler>(object: &mut _cef_audio_handler_t) {
        object.get_audio_parameters = Some(get_audio_parameters::<I>);
        object.on_audio_stream_started = Some(on_audio_stream_started::<I>);
        object.on_audio_stream_packet = Some(on_audio_stream_packet::<I>);
        object.on_audio_stream_stopped = Some(on_audio_stream_stopped::<I>);
        object.on_audio_stream_error = Some(on_audio_stream_error::<I>);
    }
    extern "C" fn get_audio_parameters<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        params: *mut _cef_audio_parameters_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_params) = (self_, browser, params);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_params = if arg_params.is_null() {
            None
        } else {
            Some(WrapParamRef::<AudioParameters, _>::from(arg_params))
        };
        let arg_params = arg_params.as_mut().map(|arg| arg.as_mut());
        ImplAudioHandler::audio_parameters(&arg_self_.interface, arg_browser, arg_params)
    }
    extern "C" fn on_audio_stream_started<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        params: *const _cef_audio_parameters_t,
        channels: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_params, arg_channels) = (self_, browser, params, channels);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_params = if arg_params.is_null() {
            None
        } else {
            Some(WrapParamRef::<AudioParameters, _>::from(arg_params))
        };
        let arg_params = arg_params.as_ref().map(|arg| arg.as_ref());
        let arg_channels = arg_channels.into_raw();
        ImplAudioHandler::on_audio_stream_started(
            &arg_self_.interface,
            arg_browser,
            arg_params,
            arg_channels,
        )
    }
    extern "C" fn on_audio_stream_packet<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
        let (arg_self_, arg_browser, arg_data, arg_frames, arg_pts) =
            (self_, browser, data, frames, pts);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_data = arg_data.into_raw();
        let arg_frames = arg_frames.into_raw();
        let arg_pts = arg_pts.into_raw();
        ImplAudioHandler::on_audio_stream_packet(
            &arg_self_.interface,
            arg_browser,
            arg_data,
            arg_frames,
            arg_pts,
        )
    }
    extern "C" fn on_audio_stream_stopped<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplAudioHandler::on_audio_stream_stopped(&arg_self_.interface, arg_browser)
    }
    extern "C" fn on_audio_stream_error<I: ImplAudioHandler>(
        self_: *mut _cef_audio_handler_t,
        browser: *mut _cef_browser_t,
        message: *const cef_string_t,
    ) {
        let (arg_self_, arg_browser, arg_message) = (self_, browser, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_message = if arg_message.is_null() {
            None
        } else {
            Some(arg_message.into())
        };
        let arg_message = arg_message.as_ref();
        ImplAudioHandler::on_audio_stream_error(&arg_self_.interface, arg_browser, arg_message)
    }
}
impl ImplAudioHandler for AudioHandler {
    fn audio_parameters(
        &self,
        browser: Option<&mut Browser>,
        params: Option<&mut AudioParameters>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_audio_parameters
                .map(|f| {
                    let (arg_browser, arg_params) = (browser, params);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_params = arg_params.cloned().map(|arg| arg.into());
                    let arg_params = arg_params
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_params);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_audio_stream_started(
        &self,
        browser: Option<&mut Browser>,
        params: Option<&AudioParameters>,
        channels: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_audio_stream_started {
                let (arg_browser, arg_params, arg_channels) = (browser, params, channels);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_params = arg_params.cloned().map(|arg| arg.into());
                let arg_params = arg_params
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_browser, arg_params, arg_channels);
            }
        }
    }
    fn on_audio_stream_packet(
        &self,
        browser: Option<&mut Browser>,
        data: *mut *const f32,
        frames: ::std::os::raw::c_int,
        pts: i64,
    ) {
        unsafe {
            if let Some(f) = self.0.on_audio_stream_packet {
                let (arg_browser, arg_data, arg_frames, arg_pts) = (browser, data, frames, pts);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_data = arg_data.cast();
                f(arg_self_, arg_browser, arg_data, arg_frames, arg_pts);
            }
        }
    }
    fn on_audio_stream_stopped(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_audio_stream_stopped {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn on_audio_stream_error(&self, browser: Option<&mut Browser>, message: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.on_audio_stream_error {
                let (arg_browser, arg_message) = (browser, message);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_message = arg_message
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_browser, arg_message);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_audio_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_audio_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AudioHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_audio_handler_t> for &AudioHandler {
    fn into_raw(self) -> *mut _cef_audio_handler_t {
        ImplAudioHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_audio_handler_t> for &mut AudioHandler {
    fn into_raw(self) -> *mut _cef_audio_handler_t {
        ImplAudioHandler::get_raw(self)
    }
}
impl ConvertReturnValue<AudioHandler> for *mut _cef_audio_handler_t {
    fn wrap_result(self) -> AudioHandler {
        AudioHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<AudioHandler> for *mut _cef_audio_handler_t {
    fn from(value: AudioHandler) -> Self {
        let object = ImplAudioHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for AudioHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_command_handler_t`] for more documentation.
#[derive(Clone)]
pub struct CommandHandler(RefGuard<_cef_command_handler_t>);
impl CommandHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCommandHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCommandHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCommandHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_command_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapCommandHandler: ImplCommandHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_command_handler_t, Self>);
}
pub trait ImplCommandHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_command_handler_t::on_chrome_command`] for more documentation."]
    fn on_chrome_command(
        &self,
        browser: Option<&mut Browser>,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_command_handler_t::is_chrome_app_menu_item_visible`] for more documentation."]
    fn is_chrome_app_menu_item_visible(
        &self,
        browser: Option<&mut Browser>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_command_handler_t::is_chrome_app_menu_item_enabled`] for more documentation."]
    fn is_chrome_app_menu_item_enabled(
        &self,
        browser: Option<&mut Browser>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_command_handler_t::is_chrome_page_action_icon_visible`] for more documentation."]
    fn is_chrome_page_action_icon_visible(
        &self,
        icon_type: ChromePageActionIconType,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_command_handler_t::is_chrome_toolbar_button_visible`] for more documentation."]
    fn is_chrome_toolbar_button_visible(
        &self,
        button_type: ChromeToolbarButtonType,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_command_handler_t) {
        impl_cef_command_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_command_handler_t;
}
mod impl_cef_command_handler_t {
    use super::*;
    pub fn init_methods<I: ImplCommandHandler>(object: &mut _cef_command_handler_t) {
        object.on_chrome_command = Some(on_chrome_command::<I>);
        object.is_chrome_app_menu_item_visible = Some(is_chrome_app_menu_item_visible::<I>);
        object.is_chrome_app_menu_item_enabled = Some(is_chrome_app_menu_item_enabled::<I>);
        object.is_chrome_page_action_icon_visible = Some(is_chrome_page_action_icon_visible::<I>);
        object.is_chrome_toolbar_button_visible = Some(is_chrome_toolbar_button_visible::<I>);
    }
    extern "C" fn on_chrome_command<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
        disposition: cef_window_open_disposition_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id, arg_disposition) =
            (self_, browser, command_id, disposition);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_command_id = arg_command_id.into_raw();
        let arg_disposition = arg_disposition.into_raw();
        ImplCommandHandler::on_chrome_command(
            &arg_self_.interface,
            arg_browser,
            arg_command_id,
            arg_disposition,
        )
    }
    extern "C" fn is_chrome_app_menu_item_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id) = (self_, browser, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_command_id = arg_command_id.into_raw();
        ImplCommandHandler::is_chrome_app_menu_item_visible(
            &arg_self_.interface,
            arg_browser,
            arg_command_id,
        )
    }
    extern "C" fn is_chrome_app_menu_item_enabled<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        browser: *mut _cef_browser_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_command_id) = (self_, browser, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_command_id = arg_command_id.into_raw();
        ImplCommandHandler::is_chrome_app_menu_item_enabled(
            &arg_self_.interface,
            arg_browser,
            arg_command_id,
        )
    }
    extern "C" fn is_chrome_page_action_icon_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        icon_type: cef_chrome_page_action_icon_type_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_icon_type) = (self_, icon_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_icon_type = arg_icon_type.into_raw();
        ImplCommandHandler::is_chrome_page_action_icon_visible(&arg_self_.interface, arg_icon_type)
    }
    extern "C" fn is_chrome_toolbar_button_visible<I: ImplCommandHandler>(
        self_: *mut _cef_command_handler_t,
        button_type: cef_chrome_toolbar_button_type_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_button_type) = (self_, button_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_button_type = arg_button_type.into_raw();
        ImplCommandHandler::is_chrome_toolbar_button_visible(&arg_self_.interface, arg_button_type)
    }
}
impl ImplCommandHandler for CommandHandler {
    fn on_chrome_command(
        &self,
        browser: Option<&mut Browser>,
        command_id: ::std::os::raw::c_int,
        disposition: WindowOpenDisposition,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_chrome_command
                .map(|f| {
                    let (arg_browser, arg_command_id, arg_disposition) =
                        (browser, command_id, disposition);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_disposition = arg_disposition.into_raw();
                    let result = f(arg_self_, arg_browser, arg_command_id, arg_disposition);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_chrome_app_menu_item_visible(
        &self,
        browser: Option<&mut Browser>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_app_menu_item_visible
                .map(|f| {
                    let (arg_browser, arg_command_id) = (browser, command_id);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_chrome_app_menu_item_enabled(
        &self,
        browser: Option<&mut Browser>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_app_menu_item_enabled
                .map(|f| {
                    let (arg_browser, arg_command_id) = (browser, command_id);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_chrome_page_action_icon_visible(
        &self,
        icon_type: ChromePageActionIconType,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_page_action_icon_visible
                .map(|f| {
                    let arg_icon_type = icon_type;
                    let arg_self_ = self.into_raw();
                    let arg_icon_type = arg_icon_type.into_raw();
                    let result = f(arg_self_, arg_icon_type);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_chrome_toolbar_button_visible(
        &self,
        button_type: ChromeToolbarButtonType,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_chrome_toolbar_button_visible
                .map(|f| {
                    let arg_button_type = button_type;
                    let arg_self_ = self.into_raw();
                    let arg_button_type = arg_button_type.into_raw();
                    let result = f(arg_self_, arg_button_type);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_command_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_command_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CommandHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_command_handler_t> for &CommandHandler {
    fn into_raw(self) -> *mut _cef_command_handler_t {
        ImplCommandHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_command_handler_t> for &mut CommandHandler {
    fn into_raw(self) -> *mut _cef_command_handler_t {
        ImplCommandHandler::get_raw(self)
    }
}
impl ConvertReturnValue<CommandHandler> for *mut _cef_command_handler_t {
    fn wrap_result(self) -> CommandHandler {
        CommandHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<CommandHandler> for *mut _cef_command_handler_t {
    fn from(value: CommandHandler) -> Self {
        let object = ImplCommandHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for CommandHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_menu_model_delegate_t`] for more documentation.
#[derive(Clone)]
pub struct MenuModelDelegate(RefGuard<_cef_menu_model_delegate_t>);
impl MenuModelDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMenuModelDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMenuModelDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMenuModelDelegate>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_menu_model_delegate_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapMenuModelDelegate: ImplMenuModelDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_menu_model_delegate_t, Self>);
}
pub trait ImplMenuModelDelegate: Clone + Sized + Rc {
    #[doc = "See [`_cef_menu_model_delegate_t::execute_command`] for more documentation."]
    fn execute_command(
        &self,
        menu_model: Option<&mut MenuModel>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) {
    }
    #[doc = "See [`_cef_menu_model_delegate_t::mouse_outside_menu`] for more documentation."]
    fn mouse_outside_menu(&self, menu_model: Option<&mut MenuModel>, screen_point: Option<&Point>) {
    }
    #[doc = "See [`_cef_menu_model_delegate_t::unhandled_open_submenu`] for more documentation."]
    fn unhandled_open_submenu(
        &self,
        menu_model: Option<&mut MenuModel>,
        is_rtl: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_menu_model_delegate_t::unhandled_close_submenu`] for more documentation."]
    fn unhandled_close_submenu(
        &self,
        menu_model: Option<&mut MenuModel>,
        is_rtl: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_menu_model_delegate_t::menu_will_show`] for more documentation."]
    fn menu_will_show(&self, menu_model: Option<&mut MenuModel>) {}
    #[doc = "See [`_cef_menu_model_delegate_t::menu_closed`] for more documentation."]
    fn menu_closed(&self, menu_model: Option<&mut MenuModel>) {}
    #[doc = "See [`_cef_menu_model_delegate_t::format_label`] for more documentation."]
    fn format_label(
        &self,
        menu_model: Option<&mut MenuModel>,
        label: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_menu_model_delegate_t) {
        impl_cef_menu_model_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_menu_model_delegate_t;
}
mod impl_cef_menu_model_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplMenuModelDelegate>(object: &mut _cef_menu_model_delegate_t) {
        object.execute_command = Some(execute_command::<I>);
        object.mouse_outside_menu = Some(mouse_outside_menu::<I>);
        object.unhandled_open_submenu = Some(unhandled_open_submenu::<I>);
        object.unhandled_close_submenu = Some(unhandled_close_submenu::<I>);
        object.menu_will_show = Some(menu_will_show::<I>);
        object.menu_closed = Some(menu_closed::<I>);
        object.format_label = Some(format_label::<I>);
    }
    extern "C" fn execute_command<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) {
        let (arg_self_, arg_menu_model, arg_command_id, arg_event_flags) =
            (self_, menu_model, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_command_id = arg_command_id.into_raw();
        let arg_event_flags = arg_event_flags.into_raw();
        ImplMenuModelDelegate::execute_command(
            &arg_self_.interface,
            arg_menu_model,
            arg_command_id,
            arg_event_flags,
        )
    }
    extern "C" fn mouse_outside_menu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        screen_point: *const _cef_point_t,
    ) {
        let (arg_self_, arg_menu_model, arg_screen_point) = (self_, menu_model, screen_point);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_screen_point = if arg_screen_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point, _>::from(arg_screen_point))
        };
        let arg_screen_point = arg_screen_point.as_ref().map(|arg| arg.as_ref());
        ImplMenuModelDelegate::mouse_outside_menu(
            &arg_self_.interface,
            arg_menu_model,
            arg_screen_point,
        )
    }
    extern "C" fn unhandled_open_submenu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        is_rtl: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_menu_model, arg_is_rtl) = (self_, menu_model, is_rtl);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_is_rtl = arg_is_rtl.into_raw();
        ImplMenuModelDelegate::unhandled_open_submenu(
            &arg_self_.interface,
            arg_menu_model,
            arg_is_rtl,
        )
    }
    extern "C" fn unhandled_close_submenu<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        is_rtl: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_menu_model, arg_is_rtl) = (self_, menu_model, is_rtl);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let arg_is_rtl = arg_is_rtl.into_raw();
        ImplMenuModelDelegate::unhandled_close_submenu(
            &arg_self_.interface,
            arg_menu_model,
            arg_is_rtl,
        )
    }
    extern "C" fn menu_will_show<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_menu_model) = (self_, menu_model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        ImplMenuModelDelegate::menu_will_show(&arg_self_.interface, arg_menu_model)
    }
    extern "C" fn menu_closed<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_menu_model) = (self_, menu_model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        ImplMenuModelDelegate::menu_closed(&arg_self_.interface, arg_menu_model)
    }
    extern "C" fn format_label<I: ImplMenuModelDelegate>(
        self_: *mut _cef_menu_model_delegate_t,
        menu_model: *mut _cef_menu_model_t,
        label: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_menu_model, arg_label) = (self_, menu_model, label);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_model = unsafe { arg_menu_model.as_mut() }
            .map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_model = arg_menu_model.as_mut();
        let mut arg_label = if arg_label.is_null() {
            None
        } else {
            Some(arg_label.into())
        };
        let arg_label = arg_label.as_mut();
        ImplMenuModelDelegate::format_label(&arg_self_.interface, arg_menu_model, arg_label)
    }
}
impl ImplMenuModelDelegate for MenuModelDelegate {
    fn execute_command(
        &self,
        menu_model: Option<&mut MenuModel>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) {
        unsafe {
            if let Some(f) = self.0.execute_command {
                let (arg_menu_model, arg_command_id, arg_event_flags) =
                    (menu_model, command_id, event_flags);
                let arg_self_ = self.into_raw();
                let arg_menu_model = arg_menu_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_event_flags = arg_event_flags.into_raw();
                f(arg_self_, arg_menu_model, arg_command_id, arg_event_flags);
            }
        }
    }
    fn mouse_outside_menu(&self, menu_model: Option<&mut MenuModel>, screen_point: Option<&Point>) {
        unsafe {
            if let Some(f) = self.0.mouse_outside_menu {
                let (arg_menu_model, arg_screen_point) = (menu_model, screen_point);
                let arg_self_ = self.into_raw();
                let arg_menu_model = arg_menu_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_screen_point = arg_screen_point.cloned().map(|arg| arg.into());
                let arg_screen_point = arg_screen_point
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_menu_model, arg_screen_point);
            }
        }
    }
    fn unhandled_open_submenu(
        &self,
        menu_model: Option<&mut MenuModel>,
        is_rtl: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.unhandled_open_submenu {
                let (arg_menu_model, arg_is_rtl) = (menu_model, is_rtl);
                let arg_self_ = self.into_raw();
                let arg_menu_model = arg_menu_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_menu_model, arg_is_rtl);
            }
        }
    }
    fn unhandled_close_submenu(
        &self,
        menu_model: Option<&mut MenuModel>,
        is_rtl: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.unhandled_close_submenu {
                let (arg_menu_model, arg_is_rtl) = (menu_model, is_rtl);
                let arg_self_ = self.into_raw();
                let arg_menu_model = arg_menu_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_menu_model, arg_is_rtl);
            }
        }
    }
    fn menu_will_show(&self, menu_model: Option<&mut MenuModel>) {
        unsafe {
            if let Some(f) = self.0.menu_will_show {
                let arg_menu_model = menu_model;
                let arg_self_ = self.into_raw();
                let arg_menu_model = arg_menu_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_menu_model);
            }
        }
    }
    fn menu_closed(&self, menu_model: Option<&mut MenuModel>) {
        unsafe {
            if let Some(f) = self.0.menu_closed {
                let arg_menu_model = menu_model;
                let arg_self_ = self.into_raw();
                let arg_menu_model = arg_menu_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_menu_model);
            }
        }
    }
    fn format_label(
        &self,
        menu_model: Option<&mut MenuModel>,
        label: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .format_label
                .map(|f| {
                    let (arg_menu_model, arg_label) = (menu_model, label);
                    let arg_self_ = self.into_raw();
                    let arg_menu_model = arg_menu_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_menu_model, arg_label);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_menu_model_delegate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_menu_model_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuModelDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_model_delegate_t> for &MenuModelDelegate {
    fn into_raw(self) -> *mut _cef_menu_model_delegate_t {
        ImplMenuModelDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_model_delegate_t> for &mut MenuModelDelegate {
    fn into_raw(self) -> *mut _cef_menu_model_delegate_t {
        ImplMenuModelDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<MenuModelDelegate> for *mut _cef_menu_model_delegate_t {
    fn wrap_result(self) -> MenuModelDelegate {
        MenuModelDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MenuModelDelegate> for *mut _cef_menu_model_delegate_t {
    fn from(value: MenuModelDelegate) -> Self {
        let object = ImplMenuModelDelegate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MenuModelDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_menu_model_t`] for more documentation.
#[derive(Clone)]
pub struct MenuModel(RefGuard<_cef_menu_model_t>);
pub trait ImplMenuModel: Clone + Sized + Rc {
    #[doc = "See [`_cef_menu_model_t::is_sub_menu`] for more documentation."]
    fn is_sub_menu(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::clear`] for more documentation."]
    fn clear(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_count`] for more documentation."]
    fn count(&self) -> usize;
    #[doc = "See [`_cef_menu_model_t::add_separator`] for more documentation."]
    fn add_separator(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::add_item`] for more documentation."]
    fn add_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::add_check_item`] for more documentation."]
    fn add_check_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::add_radio_item`] for more documentation."]
    fn add_radio_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::add_sub_menu`] for more documentation."]
    fn add_sub_menu(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> Option<MenuModel>;
    #[doc = "See [`_cef_menu_model_t::insert_separator_at`] for more documentation."]
    fn insert_separator_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::insert_item_at`] for more documentation."]
    fn insert_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::insert_check_item_at`] for more documentation."]
    fn insert_check_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::insert_radio_item_at`] for more documentation."]
    fn insert_radio_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::insert_sub_menu_at`] for more documentation."]
    fn insert_sub_menu_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> Option<MenuModel>;
    #[doc = "See [`_cef_menu_model_t::remove`] for more documentation."]
    fn remove(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::remove_at`] for more documentation."]
    fn remove_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_index_of`] for more documentation."]
    fn index_of(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_command_id_at`] for more documentation."]
    fn command_id_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_command_id_at`] for more documentation."]
    fn set_command_id_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_label`] for more documentation."]
    fn label(&self, command_id: ::std::os::raw::c_int) -> CefStringUserfree;
    #[doc = "See [`_cef_menu_model_t::get_label_at`] for more documentation."]
    fn label_at(&self, index: usize) -> CefStringUserfree;
    #[doc = "See [`_cef_menu_model_t::set_label`] for more documentation."]
    fn set_label(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_label_at`] for more documentation."]
    fn set_label_at(&self, index: usize, label: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_type`] for more documentation."]
    fn get_type(&self, command_id: ::std::os::raw::c_int) -> MenuItemType;
    #[doc = "See [`_cef_menu_model_t::get_type_at`] for more documentation."]
    fn type_at(&self, index: usize) -> MenuItemType;
    #[doc = "See [`_cef_menu_model_t::get_group_id`] for more documentation."]
    fn group_id(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_group_id_at`] for more documentation."]
    fn group_id_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_group_id`] for more documentation."]
    fn set_group_id(
        &self,
        command_id: ::std::os::raw::c_int,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_group_id_at`] for more documentation."]
    fn set_group_id_at(
        &self,
        index: usize,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_sub_menu`] for more documentation."]
    fn sub_menu(&self, command_id: ::std::os::raw::c_int) -> Option<MenuModel>;
    #[doc = "See [`_cef_menu_model_t::get_sub_menu_at`] for more documentation."]
    fn sub_menu_at(&self, index: usize) -> Option<MenuModel>;
    #[doc = "See [`_cef_menu_model_t::is_visible`] for more documentation."]
    fn is_visible(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::is_visible_at`] for more documentation."]
    fn is_visible_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_visible`] for more documentation."]
    fn set_visible(
        &self,
        command_id: ::std::os::raw::c_int,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_visible_at`] for more documentation."]
    fn set_visible_at(&self, index: usize, visible: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::is_enabled`] for more documentation."]
    fn is_enabled(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::is_enabled_at`] for more documentation."]
    fn is_enabled_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_enabled`] for more documentation."]
    fn set_enabled(
        &self,
        command_id: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_enabled_at`] for more documentation."]
    fn set_enabled_at(&self, index: usize, enabled: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::is_checked`] for more documentation."]
    fn is_checked(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::is_checked_at`] for more documentation."]
    fn is_checked_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_checked`] for more documentation."]
    fn set_checked(
        &self,
        command_id: ::std::os::raw::c_int,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_checked_at`] for more documentation."]
    fn set_checked_at(&self, index: usize, checked: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::has_accelerator`] for more documentation."]
    fn has_accelerator(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::has_accelerator_at`] for more documentation."]
    fn has_accelerator_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_accelerator`] for more documentation."]
    fn set_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_accelerator_at`] for more documentation."]
    fn set_accelerator_at(
        &self,
        index: usize,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::remove_accelerator`] for more documentation."]
    fn remove_accelerator(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::remove_accelerator_at`] for more documentation."]
    fn remove_accelerator_at(&self, index: usize) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_accelerator`] for more documentation."]
    fn accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: Option<&mut ::std::os::raw::c_int>,
        shift_pressed: Option<&mut ::std::os::raw::c_int>,
        ctrl_pressed: Option<&mut ::std::os::raw::c_int>,
        alt_pressed: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_accelerator_at`] for more documentation."]
    fn accelerator_at(
        &self,
        index: usize,
        key_code: Option<&mut ::std::os::raw::c_int>,
        shift_pressed: Option<&mut ::std::os::raw::c_int>,
        ctrl_pressed: Option<&mut ::std::os::raw::c_int>,
        alt_pressed: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_color`] for more documentation."]
    fn set_color(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_color_at`] for more documentation."]
    fn set_color_at(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_color`] for more documentation."]
    fn color(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: Option<&mut u32>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::get_color_at`] for more documentation."]
    fn color_at(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: Option<&mut u32>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_font_list`] for more documentation."]
    fn set_font_list(
        &self,
        command_id: ::std::os::raw::c_int,
        font_list: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_menu_model_t::set_font_list_at`] for more documentation."]
    fn set_font_list_at(
        &self,
        index: ::std::os::raw::c_int,
        font_list: Option<&CefString>,
    ) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_menu_model_t;
}
impl ImplMenuModel for MenuModel {
    fn is_sub_menu(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_sub_menu
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn clear(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn count(&self) -> usize {
        unsafe {
            self.0
                .get_count
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_separator(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_separator
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_item
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_check_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_check_item
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_radio_item(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .add_radio_item
                .map(|f| {
                    let (arg_command_id, arg_label, arg_group_id) = (command_id, label, group_id);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label, arg_group_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn add_sub_menu(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> Option<MenuModel> {
        unsafe {
            self.0
                .add_sub_menu
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn insert_separator_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_separator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn insert_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn insert_check_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_check_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn insert_radio_item_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .insert_radio_item_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label, arg_group_id) =
                        (index, command_id, label, group_id);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_command_id,
                        arg_label,
                        arg_group_id,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn insert_sub_menu_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> Option<MenuModel> {
        unsafe {
            self.0
                .insert_sub_menu_at
                .map(|f| {
                    let (arg_index, arg_command_id, arg_label) = (index, command_id, label);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_command_id, arg_label);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn remove(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn remove_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn index_of(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_index_of
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn command_id_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_command_id_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_command_id_at(
        &self,
        index: usize,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_command_id_at
                .map(|f| {
                    let (arg_index, arg_command_id) = (index, command_id);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn label(&self, command_id: ::std::os::raw::c_int) -> CefStringUserfree {
        unsafe {
            self.0
                .get_label
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn label_at(&self, index: usize) -> CefStringUserfree {
        unsafe {
            self.0
                .get_label_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_label(
        &self,
        command_id: ::std::os::raw::c_int,
        label: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_label
                .map(|f| {
                    let (arg_command_id, arg_label) = (command_id, label);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_label);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_label_at(&self, index: usize, label: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_label_at
                .map(|f| {
                    let (arg_index, arg_label) = (index, label);
                    let arg_self_ = self.into_raw();
                    let arg_label = arg_label
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_label);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_type(&self, command_id: ::std::os::raw::c_int) -> MenuItemType {
        unsafe {
            self.0
                .get_type
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn type_at(&self, index: usize) -> MenuItemType {
        unsafe {
            self.0
                .get_type_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn group_id(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn group_id_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_group_id(
        &self,
        command_id: ::std::os::raw::c_int,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_group_id
                .map(|f| {
                    let (arg_command_id, arg_group_id) = (command_id, group_id);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id, arg_group_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_group_id_at(
        &self,
        index: usize,
        group_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_group_id_at
                .map(|f| {
                    let (arg_index, arg_group_id) = (index, group_id);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index, arg_group_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn sub_menu(&self, command_id: ::std::os::raw::c_int) -> Option<MenuModel> {
        unsafe {
            self.0
                .get_sub_menu
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn sub_menu_at(&self, index: usize) -> Option<MenuModel> {
        unsafe {
            self.0
                .get_sub_menu_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_visible(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_visible_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_visible(
        &self,
        command_id: ::std::os::raw::c_int,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_visible
                .map(|f| {
                    let (arg_command_id, arg_visible) = (command_id, visible);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id, arg_visible);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_visible_at(
        &self,
        index: usize,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_visible_at
                .map(|f| {
                    let (arg_index, arg_visible) = (index, visible);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index, arg_visible);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_enabled(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_enabled_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_enabled(
        &self,
        command_id: ::std::os::raw::c_int,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_enabled
                .map(|f| {
                    let (arg_command_id, arg_enabled) = (command_id, enabled);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id, arg_enabled);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_enabled_at(
        &self,
        index: usize,
        enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_enabled_at
                .map(|f| {
                    let (arg_index, arg_enabled) = (index, enabled);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index, arg_enabled);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_checked(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_checked
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_checked_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_checked_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_checked(
        &self,
        command_id: ::std::os::raw::c_int,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_checked
                .map(|f| {
                    let (arg_command_id, arg_checked) = (command_id, checked);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id, arg_checked);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_checked_at(
        &self,
        index: usize,
        checked: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_checked_at
                .map(|f| {
                    let (arg_index, arg_checked) = (index, checked);
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index, arg_checked);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_accelerator(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_accelerator
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_accelerator_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_accelerator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_accelerator
                .map(|f| {
                    let (
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (
                        command_id,
                        key_code,
                        shift_pressed,
                        ctrl_pressed,
                        alt_pressed,
                    );
                    let arg_self_ = self.into_raw();
                    let result = f(
                        arg_self_,
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_accelerator_at(
        &self,
        index: usize,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_accelerator_at
                .map(|f| {
                    let (
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (index, key_code, shift_pressed, ctrl_pressed, alt_pressed);
                    let arg_self_ = self.into_raw();
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn remove_accelerator(&self, command_id: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_accelerator
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn remove_accelerator_at(&self, index: usize) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .remove_accelerator_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: Option<&mut ::std::os::raw::c_int>,
        shift_pressed: Option<&mut ::std::os::raw::c_int>,
        ctrl_pressed: Option<&mut ::std::os::raw::c_int>,
        alt_pressed: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_accelerator
                .map(|f| {
                    let (
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (
                        command_id,
                        key_code,
                        shift_pressed,
                        ctrl_pressed,
                        alt_pressed,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_key_code = arg_key_code
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_shift_pressed = arg_shift_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_ctrl_pressed = arg_ctrl_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_alt_pressed = arg_alt_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_command_id,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn accelerator_at(
        &self,
        index: usize,
        key_code: Option<&mut ::std::os::raw::c_int>,
        shift_pressed: Option<&mut ::std::os::raw::c_int>,
        ctrl_pressed: Option<&mut ::std::os::raw::c_int>,
        alt_pressed: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_accelerator_at
                .map(|f| {
                    let (
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    ) = (index, key_code, shift_pressed, ctrl_pressed, alt_pressed);
                    let arg_self_ = self.into_raw();
                    let arg_key_code = arg_key_code
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_shift_pressed = arg_shift_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_ctrl_pressed = arg_ctrl_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_alt_pressed = arg_alt_pressed
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_index,
                        arg_key_code,
                        arg_shift_pressed,
                        arg_ctrl_pressed,
                        arg_alt_pressed,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_color(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_color
                .map(|f| {
                    let (arg_command_id, arg_color_type, arg_color) =
                        (command_id, color_type, color);
                    let arg_self_ = self.into_raw();
                    let arg_color_type = arg_color_type.into_raw();
                    let result = f(arg_self_, arg_command_id, arg_color_type, arg_color);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_color_at(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: u32,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_color_at
                .map(|f| {
                    let (arg_index, arg_color_type, arg_color) = (index, color_type, color);
                    let arg_self_ = self.into_raw();
                    let arg_color_type = arg_color_type.into_raw();
                    let result = f(arg_self_, arg_index, arg_color_type, arg_color);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn color(
        &self,
        command_id: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: Option<&mut u32>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_color
                .map(|f| {
                    let (arg_command_id, arg_color_type, arg_color) =
                        (command_id, color_type, color);
                    let arg_self_ = self.into_raw();
                    let arg_color_type = arg_color_type.into_raw();
                    let arg_color = arg_color
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_command_id, arg_color_type, arg_color);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn color_at(
        &self,
        index: ::std::os::raw::c_int,
        color_type: MenuColorType,
        color: Option<&mut u32>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_color_at
                .map(|f| {
                    let (arg_index, arg_color_type, arg_color) = (index, color_type, color);
                    let arg_self_ = self.into_raw();
                    let arg_color_type = arg_color_type.into_raw();
                    let arg_color = arg_color
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_color_type, arg_color);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_font_list(
        &self,
        command_id: ::std::os::raw::c_int,
        font_list: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_font_list
                .map(|f| {
                    let (arg_command_id, arg_font_list) = (command_id, font_list);
                    let arg_self_ = self.into_raw();
                    let arg_font_list = arg_font_list
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_id, arg_font_list);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_font_list_at(
        &self,
        index: ::std::os::raw::c_int,
        font_list: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_font_list_at
                .map(|f| {
                    let (arg_index, arg_font_list) = (index, font_list);
                    let arg_self_ = self.into_raw();
                    let arg_font_list = arg_font_list
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_index, arg_font_list);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_menu_model_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_menu_model_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuModel {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_model_t> for &MenuModel {
    fn into_raw(self) -> *mut _cef_menu_model_t {
        ImplMenuModel::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_model_t> for &mut MenuModel {
    fn into_raw(self) -> *mut _cef_menu_model_t {
        ImplMenuModel::get_raw(self)
    }
}
impl ConvertReturnValue<MenuModel> for *mut _cef_menu_model_t {
    fn wrap_result(self) -> MenuModel {
        MenuModel(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MenuModel> for *mut _cef_menu_model_t {
    fn from(value: MenuModel) -> Self {
        let object = ImplMenuModel::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MenuModel {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_run_context_menu_callback_t`] for more documentation.
#[derive(Clone)]
pub struct RunContextMenuCallback(RefGuard<_cef_run_context_menu_callback_t>);
pub trait ImplRunContextMenuCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_run_context_menu_callback_t::cont`] for more documentation."]
    fn cont(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags);
    #[doc = "See [`_cef_run_context_menu_callback_t::cancel`] for more documentation."]
    fn cancel(&self);
    fn get_raw(&self) -> *mut _cef_run_context_menu_callback_t;
}
impl ImplRunContextMenuCallback for RunContextMenuCallback {
    fn cont(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {
        unsafe {
            if let Some(f) = self.0.cont {
                let (arg_command_id, arg_event_flags) = (command_id, event_flags);
                let arg_self_ = self.into_raw();
                let arg_event_flags = arg_event_flags.into_raw();
                f(arg_self_, arg_command_id, arg_event_flags);
            }
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_run_context_menu_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_run_context_menu_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunContextMenuCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_context_menu_callback_t> for &RunContextMenuCallback {
    fn into_raw(self) -> *mut _cef_run_context_menu_callback_t {
        ImplRunContextMenuCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_run_context_menu_callback_t> for &mut RunContextMenuCallback {
    fn into_raw(self) -> *mut _cef_run_context_menu_callback_t {
        ImplRunContextMenuCallback::get_raw(self)
    }
}
impl ConvertReturnValue<RunContextMenuCallback> for *mut _cef_run_context_menu_callback_t {
    fn wrap_result(self) -> RunContextMenuCallback {
        RunContextMenuCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<RunContextMenuCallback> for *mut _cef_run_context_menu_callback_t {
    fn from(value: RunContextMenuCallback) -> Self {
        let object = ImplRunContextMenuCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for RunContextMenuCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_run_quick_menu_callback_t`] for more documentation.
#[derive(Clone)]
pub struct RunQuickMenuCallback(RefGuard<_cef_run_quick_menu_callback_t>);
pub trait ImplRunQuickMenuCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_run_quick_menu_callback_t::cont`] for more documentation."]
    fn cont(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags);
    #[doc = "See [`_cef_run_quick_menu_callback_t::cancel`] for more documentation."]
    fn cancel(&self);
    fn get_raw(&self) -> *mut _cef_run_quick_menu_callback_t;
}
impl ImplRunQuickMenuCallback for RunQuickMenuCallback {
    fn cont(&self, command_id: ::std::os::raw::c_int, event_flags: EventFlags) {
        unsafe {
            if let Some(f) = self.0.cont {
                let (arg_command_id, arg_event_flags) = (command_id, event_flags);
                let arg_self_ = self.into_raw();
                let arg_event_flags = arg_event_flags.into_raw();
                f(arg_self_, arg_command_id, arg_event_flags);
            }
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_run_quick_menu_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_run_quick_menu_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RunQuickMenuCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_run_quick_menu_callback_t> for &RunQuickMenuCallback {
    fn into_raw(self) -> *mut _cef_run_quick_menu_callback_t {
        ImplRunQuickMenuCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_run_quick_menu_callback_t> for &mut RunQuickMenuCallback {
    fn into_raw(self) -> *mut _cef_run_quick_menu_callback_t {
        ImplRunQuickMenuCallback::get_raw(self)
    }
}
impl ConvertReturnValue<RunQuickMenuCallback> for *mut _cef_run_quick_menu_callback_t {
    fn wrap_result(self) -> RunQuickMenuCallback {
        RunQuickMenuCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<RunQuickMenuCallback> for *mut _cef_run_quick_menu_callback_t {
    fn from(value: RunQuickMenuCallback) -> Self {
        let object = ImplRunQuickMenuCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for RunQuickMenuCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_context_menu_handler_t`] for more documentation.
#[derive(Clone)]
pub struct ContextMenuHandler(RefGuard<_cef_context_menu_handler_t>);
impl ContextMenuHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapContextMenuHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplContextMenuHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapContextMenuHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_context_menu_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapContextMenuHandler: ImplContextMenuHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_context_menu_handler_t, Self>);
}
pub trait ImplContextMenuHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_context_menu_handler_t::on_before_context_menu`] for more documentation."]
    fn on_before_context_menu(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        params: Option<&mut ContextMenuParams>,
        model: Option<&mut MenuModel>,
    ) {
    }
    #[doc = "See [`_cef_context_menu_handler_t::run_context_menu`] for more documentation."]
    fn run_context_menu(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        params: Option<&mut ContextMenuParams>,
        model: Option<&mut MenuModel>,
        callback: Option<&mut RunContextMenuCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_context_menu_handler_t::on_context_menu_command`] for more documentation."]
    fn on_context_menu_command(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        params: Option<&mut ContextMenuParams>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_context_menu_handler_t::on_context_menu_dismissed`] for more documentation."]
    fn on_context_menu_dismissed(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {}
    #[doc = "See [`_cef_context_menu_handler_t::run_quick_menu`] for more documentation."]
    fn run_quick_menu(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        location: Option<&Point>,
        size: Option<&Size>,
        edit_state_flags: QuickMenuEditStateFlags,
        callback: Option<&mut RunQuickMenuCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_context_menu_handler_t::on_quick_menu_command`] for more documentation."]
    fn on_quick_menu_command(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_context_menu_handler_t::on_quick_menu_dismissed`] for more documentation."]
    fn on_quick_menu_dismissed(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {}
    fn init_methods(object: &mut _cef_context_menu_handler_t) {
        impl_cef_context_menu_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_context_menu_handler_t;
}
mod impl_cef_context_menu_handler_t {
    use super::*;
    pub fn init_methods<I: ImplContextMenuHandler>(object: &mut _cef_context_menu_handler_t) {
        object.on_before_context_menu = Some(on_before_context_menu::<I>);
        object.run_context_menu = Some(run_context_menu::<I>);
        object.on_context_menu_command = Some(on_context_menu_command::<I>);
        object.on_context_menu_dismissed = Some(on_context_menu_dismissed::<I>);
        object.run_quick_menu = Some(run_quick_menu::<I>);
        object.on_quick_menu_command = Some(on_quick_menu_command::<I>);
        object.on_quick_menu_dismissed = Some(on_quick_menu_dismissed::<I>);
    }
    extern "C" fn on_before_context_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        model: *mut _cef_menu_model_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_model) =
            (self_, browser, frame, params, model);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_params = unsafe { arg_params.as_mut() }
            .map(|arg| ContextMenuParams(unsafe { RefGuard::from_raw(arg) }));
        let arg_params = arg_params.as_mut();
        let mut arg_model =
            unsafe { arg_model.as_mut() }.map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_model = arg_model.as_mut();
        ImplContextMenuHandler::on_before_context_menu(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_params,
            arg_model,
        )
    }
    extern "C" fn run_context_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        model: *mut _cef_menu_model_t,
        callback: *mut _cef_run_context_menu_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_model, arg_callback) =
            (self_, browser, frame, params, model, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_params = unsafe { arg_params.as_mut() }
            .map(|arg| ContextMenuParams(unsafe { RefGuard::from_raw(arg) }));
        let arg_params = arg_params.as_mut();
        let mut arg_model =
            unsafe { arg_model.as_mut() }.map(|arg| MenuModel(unsafe { RefGuard::from_raw(arg) }));
        let arg_model = arg_model.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| RunContextMenuCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplContextMenuHandler::run_context_menu(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_params,
            arg_model,
            arg_callback,
        )
    }
    extern "C" fn on_context_menu_command<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        params: *mut _cef_context_menu_params_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_params, arg_command_id, arg_event_flags) =
            (self_, browser, frame, params, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_params = unsafe { arg_params.as_mut() }
            .map(|arg| ContextMenuParams(unsafe { RefGuard::from_raw(arg) }));
        let arg_params = arg_params.as_mut();
        let arg_command_id = arg_command_id.into_raw();
        let arg_event_flags = arg_event_flags.into_raw();
        ImplContextMenuHandler::on_context_menu_command(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_params,
            arg_command_id,
            arg_event_flags,
        )
    }
    extern "C" fn on_context_menu_dismissed<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        ImplContextMenuHandler::on_context_menu_dismissed(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
        )
    }
    extern "C" fn run_quick_menu<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        location: *const _cef_point_t,
        size: *const _cef_size_t,
        edit_state_flags: cef_quick_menu_edit_state_flags_t,
        callback: *mut _cef_run_quick_menu_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_location,
            arg_size,
            arg_edit_state_flags,
            arg_callback,
        ) = (
            self_,
            browser,
            frame,
            location,
            size,
            edit_state_flags,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_location = if arg_location.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point, _>::from(arg_location))
        };
        let arg_location = arg_location.as_ref().map(|arg| arg.as_ref());
        let arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size, _>::from(arg_size))
        };
        let arg_size = arg_size.as_ref().map(|arg| arg.as_ref());
        let arg_edit_state_flags = arg_edit_state_flags.into_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| RunQuickMenuCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplContextMenuHandler::run_quick_menu(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_location,
            arg_size,
            arg_edit_state_flags,
            arg_callback,
        )
    }
    extern "C" fn on_quick_menu_command<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        command_id: ::std::os::raw::c_int,
        event_flags: cef_event_flags_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_command_id, arg_event_flags) =
            (self_, browser, frame, command_id, event_flags);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_command_id = arg_command_id.into_raw();
        let arg_event_flags = arg_event_flags.into_raw();
        ImplContextMenuHandler::on_quick_menu_command(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_command_id,
            arg_event_flags,
        )
    }
    extern "C" fn on_quick_menu_dismissed<I: ImplContextMenuHandler>(
        self_: *mut _cef_context_menu_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        ImplContextMenuHandler::on_quick_menu_dismissed(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
        )
    }
}
impl ImplContextMenuHandler for ContextMenuHandler {
    fn on_before_context_menu(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        params: Option<&mut ContextMenuParams>,
        model: Option<&mut MenuModel>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_before_context_menu {
                let (arg_browser, arg_frame, arg_params, arg_model) =
                    (browser, frame, params, model);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_params = arg_params
                    .map(|arg| {
                        arg.add_ref();
                        ImplContextMenuParams::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_model = arg_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame, arg_params, arg_model);
            }
        }
    }
    fn run_context_menu(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        params: Option<&mut ContextMenuParams>,
        model: Option<&mut MenuModel>,
        callback: Option<&mut RunContextMenuCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .run_context_menu
                .map(|f| {
                    let (arg_browser, arg_frame, arg_params, arg_model, arg_callback) =
                        (browser, frame, params, model, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_params = arg_params
                        .map(|arg| {
                            arg.add_ref();
                            ImplContextMenuParams::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_model = arg_model
                        .map(|arg| {
                            arg.add_ref();
                            ImplMenuModel::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplRunContextMenuCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_params,
                        arg_model,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_context_menu_command(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        params: Option<&mut ContextMenuParams>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_context_menu_command
                .map(|f| {
                    let (arg_browser, arg_frame, arg_params, arg_command_id, arg_event_flags) =
                        (browser, frame, params, command_id, event_flags);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_params = arg_params
                        .map(|arg| {
                            arg.add_ref();
                            ImplContextMenuParams::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event_flags = arg_event_flags.into_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_params,
                        arg_command_id,
                        arg_event_flags,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_context_menu_dismissed(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {
        unsafe {
            if let Some(f) = self.0.on_context_menu_dismissed {
                let (arg_browser, arg_frame) = (browser, frame);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame);
            }
        }
    }
    fn run_quick_menu(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        location: Option<&Point>,
        size: Option<&Size>,
        edit_state_flags: QuickMenuEditStateFlags,
        callback: Option<&mut RunQuickMenuCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .run_quick_menu
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_location,
                        arg_size,
                        arg_edit_state_flags,
                        arg_callback,
                    ) = (browser, frame, location, size, edit_state_flags, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_location = arg_location.cloned().map(|arg| arg.into());
                    let arg_location = arg_location
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_size = arg_size.cloned().map(|arg| arg.into());
                    let arg_size = arg_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_edit_state_flags = arg_edit_state_flags.into_raw();
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplRunQuickMenuCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_location,
                        arg_size,
                        arg_edit_state_flags,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_quick_menu_command(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        command_id: ::std::os::raw::c_int,
        event_flags: EventFlags,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_quick_menu_command
                .map(|f| {
                    let (arg_browser, arg_frame, arg_command_id, arg_event_flags) =
                        (browser, frame, command_id, event_flags);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event_flags = arg_event_flags.into_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_command_id,
                        arg_event_flags,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_quick_menu_dismissed(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {
        unsafe {
            if let Some(f) = self.0.on_quick_menu_dismissed {
                let (arg_browser, arg_frame) = (browser, frame);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_context_menu_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_context_menu_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ContextMenuHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_context_menu_handler_t> for &ContextMenuHandler {
    fn into_raw(self) -> *mut _cef_context_menu_handler_t {
        ImplContextMenuHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_context_menu_handler_t> for &mut ContextMenuHandler {
    fn into_raw(self) -> *mut _cef_context_menu_handler_t {
        ImplContextMenuHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ContextMenuHandler> for *mut _cef_context_menu_handler_t {
    fn wrap_result(self) -> ContextMenuHandler {
        ContextMenuHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ContextMenuHandler> for *mut _cef_context_menu_handler_t {
    fn from(value: ContextMenuHandler) -> Self {
        let object = ImplContextMenuHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ContextMenuHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_context_menu_params_t`] for more documentation.
#[derive(Clone)]
pub struct ContextMenuParams(RefGuard<_cef_context_menu_params_t>);
pub trait ImplContextMenuParams: Clone + Sized + Rc {
    #[doc = "See [`_cef_context_menu_params_t::get_xcoord`] for more documentation."]
    fn xcoord(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_context_menu_params_t::get_ycoord`] for more documentation."]
    fn ycoord(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_context_menu_params_t::get_type_flags`] for more documentation."]
    fn type_flags(&self) -> ContextMenuTypeFlags;
    #[doc = "See [`_cef_context_menu_params_t::get_link_url`] for more documentation."]
    fn link_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::get_unfiltered_link_url`] for more documentation."]
    fn unfiltered_link_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::get_source_url`] for more documentation."]
    fn source_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::has_image_contents`] for more documentation."]
    fn has_image_contents(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_context_menu_params_t::get_title_text`] for more documentation."]
    fn title_text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::get_page_url`] for more documentation."]
    fn page_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::get_frame_url`] for more documentation."]
    fn frame_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::get_frame_charset`] for more documentation."]
    fn frame_charset(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::get_media_type`] for more documentation."]
    fn media_type(&self) -> ContextMenuMediaType;
    #[doc = "See [`_cef_context_menu_params_t::get_media_state_flags`] for more documentation."]
    fn media_state_flags(&self) -> ContextMenuMediaStateFlags;
    #[doc = "See [`_cef_context_menu_params_t::get_selection_text`] for more documentation."]
    fn selection_text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::get_misspelled_word`] for more documentation."]
    fn misspelled_word(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_context_menu_params_t::get_dictionary_suggestions`] for more documentation."]
    fn dictionary_suggestions(
        &self,
        suggestions: Option<&mut CefStringList>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_context_menu_params_t::is_editable`] for more documentation."]
    fn is_editable(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_context_menu_params_t::is_spell_check_enabled`] for more documentation."]
    fn is_spell_check_enabled(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_context_menu_params_t::get_edit_state_flags`] for more documentation."]
    fn edit_state_flags(&self) -> ContextMenuEditStateFlags;
    #[doc = "See [`_cef_context_menu_params_t::is_custom_menu`] for more documentation."]
    fn is_custom_menu(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_context_menu_params_t;
}
impl ImplContextMenuParams for ContextMenuParams {
    fn xcoord(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_xcoord
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn ycoord(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_ycoord
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn type_flags(&self) -> ContextMenuTypeFlags {
        unsafe {
            self.0
                .get_type_flags
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn link_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_link_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn unfiltered_link_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_unfiltered_link_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn source_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_source_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_image_contents(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_image_contents
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn title_text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_title_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn page_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_page_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn frame_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_frame_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn frame_charset(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_frame_charset
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn media_type(&self) -> ContextMenuMediaType {
        unsafe {
            self.0
                .get_media_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn media_state_flags(&self) -> ContextMenuMediaStateFlags {
        unsafe {
            self.0
                .get_media_state_flags
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn selection_text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_selection_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn misspelled_word(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_misspelled_word
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn dictionary_suggestions(
        &self,
        suggestions: Option<&mut CefStringList>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_dictionary_suggestions
                .map(|f| {
                    let arg_suggestions = suggestions;
                    let arg_self_ = self.into_raw();
                    let arg_suggestions = arg_suggestions
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_suggestions);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_editable(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_editable
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_spell_check_enabled(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_spell_check_enabled
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn edit_state_flags(&self) -> ContextMenuEditStateFlags {
        unsafe {
            self.0
                .get_edit_state_flags
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_custom_menu(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_custom_menu
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_context_menu_params_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_context_menu_params_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ContextMenuParams {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_context_menu_params_t> for &ContextMenuParams {
    fn into_raw(self) -> *mut _cef_context_menu_params_t {
        ImplContextMenuParams::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_context_menu_params_t> for &mut ContextMenuParams {
    fn into_raw(self) -> *mut _cef_context_menu_params_t {
        ImplContextMenuParams::get_raw(self)
    }
}
impl ConvertReturnValue<ContextMenuParams> for *mut _cef_context_menu_params_t {
    fn wrap_result(self) -> ContextMenuParams {
        ContextMenuParams(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ContextMenuParams> for *mut _cef_context_menu_params_t {
    fn from(value: ContextMenuParams) -> Self {
        let object = ImplContextMenuParams::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ContextMenuParams {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_file_dialog_callback_t`] for more documentation.
#[derive(Clone)]
pub struct FileDialogCallback(RefGuard<_cef_file_dialog_callback_t>);
pub trait ImplFileDialogCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_file_dialog_callback_t::cont`] for more documentation."]
    fn cont(&self, file_paths: Option<&mut CefStringList>);
    #[doc = "See [`_cef_file_dialog_callback_t::cancel`] for more documentation."]
    fn cancel(&self);
    fn get_raw(&self) -> *mut _cef_file_dialog_callback_t;
}
impl ImplFileDialogCallback for FileDialogCallback {
    fn cont(&self, file_paths: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.cont {
                let arg_file_paths = file_paths;
                let arg_self_ = self.into_raw();
                let arg_file_paths = arg_file_paths
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_file_paths);
            }
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_file_dialog_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_file_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FileDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_file_dialog_callback_t> for &FileDialogCallback {
    fn into_raw(self) -> *mut _cef_file_dialog_callback_t {
        ImplFileDialogCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_file_dialog_callback_t> for &mut FileDialogCallback {
    fn into_raw(self) -> *mut _cef_file_dialog_callback_t {
        ImplFileDialogCallback::get_raw(self)
    }
}
impl ConvertReturnValue<FileDialogCallback> for *mut _cef_file_dialog_callback_t {
    fn wrap_result(self) -> FileDialogCallback {
        FileDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<FileDialogCallback> for *mut _cef_file_dialog_callback_t {
    fn from(value: FileDialogCallback) -> Self {
        let object = ImplFileDialogCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for FileDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_dialog_handler_t`] for more documentation.
#[derive(Clone)]
pub struct DialogHandler(RefGuard<_cef_dialog_handler_t>);
impl DialogHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDialogHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDialogHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDialogHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_dialog_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapDialogHandler: ImplDialogHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_dialog_handler_t, Self>);
}
pub trait ImplDialogHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_dialog_handler_t::on_file_dialog`] for more documentation."]
    fn on_file_dialog(
        &self,
        browser: Option<&mut Browser>,
        mode: FileDialogMode,
        title: Option<&CefString>,
        default_file_path: Option<&CefString>,
        accept_filters: Option<&mut CefStringList>,
        accept_extensions: Option<&mut CefStringList>,
        accept_descriptions: Option<&mut CefStringList>,
        callback: Option<&mut FileDialogCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_dialog_handler_t) {
        impl_cef_dialog_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_dialog_handler_t;
}
mod impl_cef_dialog_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDialogHandler>(object: &mut _cef_dialog_handler_t) {
        object.on_file_dialog = Some(on_file_dialog::<I>);
    }
    extern "C" fn on_file_dialog<I: ImplDialogHandler>(
        self_: *mut _cef_dialog_handler_t,
        browser: *mut _cef_browser_t,
        mode: cef_file_dialog_mode_t,
        title: *const cef_string_t,
        default_file_path: *const cef_string_t,
        accept_filters: *mut _cef_string_list_t,
        accept_extensions: *mut _cef_string_list_t,
        accept_descriptions: *mut _cef_string_list_t,
        callback: *mut _cef_file_dialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_accept_extensions,
            arg_accept_descriptions,
            arg_callback,
        ) = (
            self_,
            browser,
            mode,
            title,
            default_file_path,
            accept_filters,
            accept_extensions,
            accept_descriptions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_mode = arg_mode.into_raw();
        let arg_title = if arg_title.is_null() {
            None
        } else {
            Some(arg_title.into())
        };
        let arg_title = arg_title.as_ref();
        let arg_default_file_path = if arg_default_file_path.is_null() {
            None
        } else {
            Some(arg_default_file_path.into())
        };
        let arg_default_file_path = arg_default_file_path.as_ref();
        let mut arg_accept_filters = if arg_accept_filters.is_null() {
            None
        } else {
            Some(arg_accept_filters.into())
        };
        let arg_accept_filters = arg_accept_filters.as_mut();
        let mut arg_accept_extensions = if arg_accept_extensions.is_null() {
            None
        } else {
            Some(arg_accept_extensions.into())
        };
        let arg_accept_extensions = arg_accept_extensions.as_mut();
        let mut arg_accept_descriptions = if arg_accept_descriptions.is_null() {
            None
        } else {
            Some(arg_accept_descriptions.into())
        };
        let arg_accept_descriptions = arg_accept_descriptions.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| FileDialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplDialogHandler::on_file_dialog(
            &arg_self_.interface,
            arg_browser,
            arg_mode,
            arg_title,
            arg_default_file_path,
            arg_accept_filters,
            arg_accept_extensions,
            arg_accept_descriptions,
            arg_callback,
        )
    }
}
impl ImplDialogHandler for DialogHandler {
    fn on_file_dialog(
        &self,
        browser: Option<&mut Browser>,
        mode: FileDialogMode,
        title: Option<&CefString>,
        default_file_path: Option<&CefString>,
        accept_filters: Option<&mut CefStringList>,
        accept_extensions: Option<&mut CefStringList>,
        accept_descriptions: Option<&mut CefStringList>,
        callback: Option<&mut FileDialogCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_file_dialog
                .map(|f| {
                    let (
                        arg_browser,
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_accept_extensions,
                        arg_accept_descriptions,
                        arg_callback,
                    ) = (
                        browser,
                        mode,
                        title,
                        default_file_path,
                        accept_filters,
                        accept_extensions,
                        accept_descriptions,
                        callback,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_mode = arg_mode.into_raw();
                    let arg_title = arg_title
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_default_file_path = arg_default_file_path
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_accept_filters = arg_accept_filters
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let arg_accept_extensions = arg_accept_extensions
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let arg_accept_descriptions = arg_accept_descriptions
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplFileDialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_mode,
                        arg_title,
                        arg_default_file_path,
                        arg_accept_filters,
                        arg_accept_extensions,
                        arg_accept_descriptions,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_dialog_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_dialog_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DialogHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_dialog_handler_t> for &DialogHandler {
    fn into_raw(self) -> *mut _cef_dialog_handler_t {
        ImplDialogHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_dialog_handler_t> for &mut DialogHandler {
    fn into_raw(self) -> *mut _cef_dialog_handler_t {
        ImplDialogHandler::get_raw(self)
    }
}
impl ConvertReturnValue<DialogHandler> for *mut _cef_dialog_handler_t {
    fn wrap_result(self) -> DialogHandler {
        DialogHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DialogHandler> for *mut _cef_dialog_handler_t {
    fn from(value: DialogHandler) -> Self {
        let object = ImplDialogHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DialogHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_display_handler_t`] for more documentation.
#[derive(Clone)]
pub struct DisplayHandler(RefGuard<_cef_display_handler_t>);
impl DisplayHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDisplayHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDisplayHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDisplayHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_display_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapDisplayHandler: ImplDisplayHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_display_handler_t, Self>);
}
pub trait ImplDisplayHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_display_handler_t::on_address_change`] for more documentation."]
    fn on_address_change(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        url: Option<&CefString>,
    ) {
    }
    #[doc = "See [`_cef_display_handler_t::on_title_change`] for more documentation."]
    fn on_title_change(&self, browser: Option<&mut Browser>, title: Option<&CefString>) {}
    #[doc = "See [`_cef_display_handler_t::on_favicon_urlchange`] for more documentation."]
    fn on_favicon_urlchange(
        &self,
        browser: Option<&mut Browser>,
        icon_urls: Option<&mut CefStringList>,
    ) {
    }
    #[doc = "See [`_cef_display_handler_t::on_fullscreen_mode_change`] for more documentation."]
    fn on_fullscreen_mode_change(
        &self,
        browser: Option<&mut Browser>,
        fullscreen: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_display_handler_t::on_tooltip`] for more documentation."]
    fn on_tooltip(
        &self,
        browser: Option<&mut Browser>,
        text: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_display_handler_t::on_status_message`] for more documentation."]
    fn on_status_message(&self, browser: Option<&mut Browser>, value: Option<&CefString>) {}
    #[doc = "See [`_cef_display_handler_t::on_console_message`] for more documentation."]
    fn on_console_message(
        &self,
        browser: Option<&mut Browser>,
        level: LogSeverity,
        message: Option<&CefString>,
        source: Option<&CefString>,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_display_handler_t::on_auto_resize`] for more documentation."]
    fn on_auto_resize(
        &self,
        browser: Option<&mut Browser>,
        new_size: Option<&Size>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_display_handler_t::on_loading_progress_change`] for more documentation."]
    fn on_loading_progress_change(&self, browser: Option<&mut Browser>, progress: f64) {}
    #[doc = "See [`_cef_display_handler_t::on_cursor_change`] for more documentation."]
    fn on_cursor_change(
        &self,
        browser: Option<&mut Browser>,
        cursor: *mut u8,
        type_: CursorType,
        custom_cursor_info: Option<&CursorInfo>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_display_handler_t::on_media_access_change`] for more documentation."]
    fn on_media_access_change(
        &self,
        browser: Option<&mut Browser>,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
    }
    fn init_methods(object: &mut _cef_display_handler_t) {
        impl_cef_display_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_display_handler_t;
}
mod impl_cef_display_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDisplayHandler>(object: &mut _cef_display_handler_t) {
        object.on_address_change = Some(on_address_change::<I>);
        object.on_title_change = Some(on_title_change::<I>);
        object.on_favicon_urlchange = Some(on_favicon_urlchange::<I>);
        object.on_fullscreen_mode_change = Some(on_fullscreen_mode_change::<I>);
        object.on_tooltip = Some(on_tooltip::<I>);
        object.on_status_message = Some(on_status_message::<I>);
        object.on_console_message = Some(on_console_message::<I>);
        object.on_auto_resize = Some(on_auto_resize::<I>);
        object.on_loading_progress_change = Some(on_loading_progress_change::<I>);
        object.on_cursor_change = Some(on_cursor_change::<I>);
        object.on_media_access_change = Some(on_media_access_change::<I>);
    }
    extern "C" fn on_address_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        url: *const cef_string_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_url) = (self_, browser, frame, url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        ImplDisplayHandler::on_address_change(&arg_self_.interface, arg_browser, arg_frame, arg_url)
    }
    extern "C" fn on_title_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        title: *const cef_string_t,
    ) {
        let (arg_self_, arg_browser, arg_title) = (self_, browser, title);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_title = if arg_title.is_null() {
            None
        } else {
            Some(arg_title.into())
        };
        let arg_title = arg_title.as_ref();
        ImplDisplayHandler::on_title_change(&arg_self_.interface, arg_browser, arg_title)
    }
    extern "C" fn on_favicon_urlchange<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        icon_urls: *mut _cef_string_list_t,
    ) {
        let (arg_self_, arg_browser, arg_icon_urls) = (self_, browser, icon_urls);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_icon_urls = if arg_icon_urls.is_null() {
            None
        } else {
            Some(arg_icon_urls.into())
        };
        let arg_icon_urls = arg_icon_urls.as_mut();
        ImplDisplayHandler::on_favicon_urlchange(&arg_self_.interface, arg_browser, arg_icon_urls)
    }
    extern "C" fn on_fullscreen_mode_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        fullscreen: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_fullscreen) = (self_, browser, fullscreen);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_fullscreen = arg_fullscreen.into_raw();
        ImplDisplayHandler::on_fullscreen_mode_change(
            &arg_self_.interface,
            arg_browser,
            arg_fullscreen,
        )
    }
    extern "C" fn on_tooltip<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        text: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_text) = (self_, browser, text);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_text = if arg_text.is_null() {
            None
        } else {
            Some(arg_text.into())
        };
        let arg_text = arg_text.as_mut();
        ImplDisplayHandler::on_tooltip(&arg_self_.interface, arg_browser, arg_text)
    }
    extern "C" fn on_status_message<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        value: *const cef_string_t,
    ) {
        let (arg_self_, arg_browser, arg_value) = (self_, browser, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_value = if arg_value.is_null() {
            None
        } else {
            Some(arg_value.into())
        };
        let arg_value = arg_value.as_ref();
        ImplDisplayHandler::on_status_message(&arg_self_.interface, arg_browser, arg_value)
    }
    extern "C" fn on_console_message<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        level: cef_log_severity_t,
        message: *const cef_string_t,
        source: *const cef_string_t,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_level, arg_message, arg_source, arg_line) =
            (self_, browser, level, message, source, line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_level = arg_level.into_raw();
        let arg_message = if arg_message.is_null() {
            None
        } else {
            Some(arg_message.into())
        };
        let arg_message = arg_message.as_ref();
        let arg_source = if arg_source.is_null() {
            None
        } else {
            Some(arg_source.into())
        };
        let arg_source = arg_source.as_ref();
        let arg_line = arg_line.into_raw();
        ImplDisplayHandler::on_console_message(
            &arg_self_.interface,
            arg_browser,
            arg_level,
            arg_message,
            arg_source,
            arg_line,
        )
    }
    extern "C" fn on_auto_resize<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        new_size: *const _cef_size_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_new_size) = (self_, browser, new_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_new_size = if arg_new_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size, _>::from(arg_new_size))
        };
        let arg_new_size = arg_new_size.as_ref().map(|arg| arg.as_ref());
        ImplDisplayHandler::on_auto_resize(&arg_self_.interface, arg_browser, arg_new_size)
    }
    extern "C" fn on_loading_progress_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        progress: f64,
    ) {
        let (arg_self_, arg_browser, arg_progress) = (self_, browser, progress);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_progress = arg_progress.into_raw();
        ImplDisplayHandler::on_loading_progress_change(
            &arg_self_.interface,
            arg_browser,
            arg_progress,
        )
    }
    extern "C" fn on_cursor_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        cursor: *mut ::std::os::raw::c_void,
        type_: cef_cursor_type_t,
        custom_cursor_info: *const _cef_cursor_info_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_cursor, arg_type_, arg_custom_cursor_info) =
            (self_, browser, cursor, type_, custom_cursor_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_cursor = arg_cursor.cast();
        let arg_type_ = arg_type_.into_raw();
        let arg_custom_cursor_info = if arg_custom_cursor_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<CursorInfo, _>::from(arg_custom_cursor_info))
        };
        let arg_custom_cursor_info = arg_custom_cursor_info.as_ref().map(|arg| arg.as_ref());
        ImplDisplayHandler::on_cursor_change(
            &arg_self_.interface,
            arg_browser,
            arg_cursor,
            arg_type_,
            arg_custom_cursor_info,
        )
    }
    extern "C" fn on_media_access_change<I: ImplDisplayHandler>(
        self_: *mut _cef_display_handler_t,
        browser: *mut _cef_browser_t,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_has_video_access, arg_has_audio_access) =
            (self_, browser, has_video_access, has_audio_access);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_has_video_access = arg_has_video_access.into_raw();
        let arg_has_audio_access = arg_has_audio_access.into_raw();
        ImplDisplayHandler::on_media_access_change(
            &arg_self_.interface,
            arg_browser,
            arg_has_video_access,
            arg_has_audio_access,
        )
    }
}
impl ImplDisplayHandler for DisplayHandler {
    fn on_address_change(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        url: Option<&CefString>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_address_change {
                let (arg_browser, arg_frame, arg_url) = (browser, frame, url);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_url = arg_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_browser, arg_frame, arg_url);
            }
        }
    }
    fn on_title_change(&self, browser: Option<&mut Browser>, title: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.on_title_change {
                let (arg_browser, arg_title) = (browser, title);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_title = arg_title
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_browser, arg_title);
            }
        }
    }
    fn on_favicon_urlchange(
        &self,
        browser: Option<&mut Browser>,
        icon_urls: Option<&mut CefStringList>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_favicon_urlchange {
                let (arg_browser, arg_icon_urls) = (browser, icon_urls);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_icon_urls = arg_icon_urls
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_icon_urls);
            }
        }
    }
    fn on_fullscreen_mode_change(
        &self,
        browser: Option<&mut Browser>,
        fullscreen: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_fullscreen_mode_change {
                let (arg_browser, arg_fullscreen) = (browser, fullscreen);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_fullscreen);
            }
        }
    }
    fn on_tooltip(
        &self,
        browser: Option<&mut Browser>,
        text: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_tooltip
                .map(|f| {
                    let (arg_browser, arg_text) = (browser, text);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_text = arg_text
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_text);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_status_message(&self, browser: Option<&mut Browser>, value: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.on_status_message {
                let (arg_browser, arg_value) = (browser, value);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_value = arg_value
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_browser, arg_value);
            }
        }
    }
    fn on_console_message(
        &self,
        browser: Option<&mut Browser>,
        level: LogSeverity,
        message: Option<&CefString>,
        source: Option<&CefString>,
        line: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_console_message
                .map(|f| {
                    let (arg_browser, arg_level, arg_message, arg_source, arg_line) =
                        (browser, level, message, source, line);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_level = arg_level.into_raw();
                    let arg_message = arg_message
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_source = arg_source
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_level,
                        arg_message,
                        arg_source,
                        arg_line,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_auto_resize(
        &self,
        browser: Option<&mut Browser>,
        new_size: Option<&Size>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_auto_resize
                .map(|f| {
                    let (arg_browser, arg_new_size) = (browser, new_size);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_new_size = arg_new_size.cloned().map(|arg| arg.into());
                    let arg_new_size = arg_new_size
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_new_size);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_loading_progress_change(&self, browser: Option<&mut Browser>, progress: f64) {
        unsafe {
            if let Some(f) = self.0.on_loading_progress_change {
                let (arg_browser, arg_progress) = (browser, progress);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_progress);
            }
        }
    }
    fn on_cursor_change(
        &self,
        browser: Option<&mut Browser>,
        cursor: *mut u8,
        type_: CursorType,
        custom_cursor_info: Option<&CursorInfo>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_cursor_change
                .map(|f| {
                    let (arg_browser, arg_cursor, arg_type_, arg_custom_cursor_info) =
                        (browser, cursor, type_, custom_cursor_info);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_cursor = arg_cursor.cast();
                    let arg_type_ = arg_type_.into_raw();
                    let arg_custom_cursor_info =
                        arg_custom_cursor_info.cloned().map(|arg| arg.into());
                    let arg_custom_cursor_info = arg_custom_cursor_info
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_cursor,
                        arg_type_,
                        arg_custom_cursor_info,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_media_access_change(
        &self,
        browser: Option<&mut Browser>,
        has_video_access: ::std::os::raw::c_int,
        has_audio_access: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_media_access_change {
                let (arg_browser, arg_has_video_access, arg_has_audio_access) =
                    (browser, has_video_access, has_audio_access);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_browser,
                    arg_has_video_access,
                    arg_has_audio_access,
                );
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_display_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_display_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DisplayHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_display_handler_t> for &DisplayHandler {
    fn into_raw(self) -> *mut _cef_display_handler_t {
        ImplDisplayHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_display_handler_t> for &mut DisplayHandler {
    fn into_raw(self) -> *mut _cef_display_handler_t {
        ImplDisplayHandler::get_raw(self)
    }
}
impl ConvertReturnValue<DisplayHandler> for *mut _cef_display_handler_t {
    fn wrap_result(self) -> DisplayHandler {
        DisplayHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DisplayHandler> for *mut _cef_display_handler_t {
    fn from(value: DisplayHandler) -> Self {
        let object = ImplDisplayHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DisplayHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_download_item_t`] for more documentation.
#[derive(Clone)]
pub struct DownloadItem(RefGuard<_cef_download_item_t>);
pub trait ImplDownloadItem: Clone + Sized + Rc {
    #[doc = "See [`_cef_download_item_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_download_item_t::is_in_progress`] for more documentation."]
    fn is_in_progress(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_download_item_t::is_complete`] for more documentation."]
    fn is_complete(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_download_item_t::is_canceled`] for more documentation."]
    fn is_canceled(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_download_item_t::is_interrupted`] for more documentation."]
    fn is_interrupted(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_download_item_t::get_interrupt_reason`] for more documentation."]
    fn interrupt_reason(&self) -> DownloadInterruptReason;
    #[doc = "See [`_cef_download_item_t::get_current_speed`] for more documentation."]
    fn current_speed(&self) -> i64;
    #[doc = "See [`_cef_download_item_t::get_percent_complete`] for more documentation."]
    fn percent_complete(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_download_item_t::get_total_bytes`] for more documentation."]
    fn total_bytes(&self) -> i64;
    #[doc = "See [`_cef_download_item_t::get_received_bytes`] for more documentation."]
    fn received_bytes(&self) -> i64;
    #[doc = "See [`_cef_download_item_t::get_start_time`] for more documentation."]
    fn start_time(&self) -> Basetime;
    #[doc = "See [`_cef_download_item_t::get_end_time`] for more documentation."]
    fn end_time(&self) -> Basetime;
    #[doc = "See [`_cef_download_item_t::get_full_path`] for more documentation."]
    fn full_path(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_download_item_t::get_id`] for more documentation."]
    fn id(&self) -> u32;
    #[doc = "See [`_cef_download_item_t::get_url`] for more documentation."]
    fn url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_download_item_t::get_original_url`] for more documentation."]
    fn original_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_download_item_t::get_suggested_file_name`] for more documentation."]
    fn suggested_file_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_download_item_t::get_content_disposition`] for more documentation."]
    fn content_disposition(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_download_item_t::get_mime_type`] for more documentation."]
    fn mime_type(&self) -> CefStringUserfree;
    fn get_raw(&self) -> *mut _cef_download_item_t;
}
impl ImplDownloadItem for DownloadItem {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_in_progress(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_in_progress
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_complete(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_complete
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_canceled(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_canceled
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_interrupted(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_interrupted
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn interrupt_reason(&self) -> DownloadInterruptReason {
        unsafe {
            self.0
                .get_interrupt_reason
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn current_speed(&self) -> i64 {
        unsafe {
            self.0
                .get_current_speed
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn percent_complete(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_percent_complete
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn total_bytes(&self) -> i64 {
        unsafe {
            self.0
                .get_total_bytes
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn received_bytes(&self) -> i64 {
        unsafe {
            self.0
                .get_received_bytes
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn start_time(&self) -> Basetime {
        unsafe {
            self.0
                .get_start_time
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn end_time(&self) -> Basetime {
        unsafe {
            self.0
                .get_end_time
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn full_path(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_full_path
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn id(&self) -> u32 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn original_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_original_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn suggested_file_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_suggested_file_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn content_disposition(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_content_disposition
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn mime_type(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_mime_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_download_item_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_download_item_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadItem {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_item_t> for &DownloadItem {
    fn into_raw(self) -> *mut _cef_download_item_t {
        ImplDownloadItem::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_download_item_t> for &mut DownloadItem {
    fn into_raw(self) -> *mut _cef_download_item_t {
        ImplDownloadItem::get_raw(self)
    }
}
impl ConvertReturnValue<DownloadItem> for *mut _cef_download_item_t {
    fn wrap_result(self) -> DownloadItem {
        DownloadItem(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DownloadItem> for *mut _cef_download_item_t {
    fn from(value: DownloadItem) -> Self {
        let object = ImplDownloadItem::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DownloadItem {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_before_download_callback_t`] for more documentation.
#[derive(Clone)]
pub struct BeforeDownloadCallback(RefGuard<_cef_before_download_callback_t>);
pub trait ImplBeforeDownloadCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_before_download_callback_t::cont`] for more documentation."]
    fn cont(&self, download_path: Option<&CefString>, show_dialog: ::std::os::raw::c_int);
    fn get_raw(&self) -> *mut _cef_before_download_callback_t;
}
impl ImplBeforeDownloadCallback for BeforeDownloadCallback {
    fn cont(&self, download_path: Option<&CefString>, show_dialog: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.cont {
                let (arg_download_path, arg_show_dialog) = (download_path, show_dialog);
                let arg_self_ = self.into_raw();
                let arg_download_path = arg_download_path
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_download_path, arg_show_dialog);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_before_download_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_before_download_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BeforeDownloadCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_before_download_callback_t> for &BeforeDownloadCallback {
    fn into_raw(self) -> *mut _cef_before_download_callback_t {
        ImplBeforeDownloadCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_before_download_callback_t> for &mut BeforeDownloadCallback {
    fn into_raw(self) -> *mut _cef_before_download_callback_t {
        ImplBeforeDownloadCallback::get_raw(self)
    }
}
impl ConvertReturnValue<BeforeDownloadCallback> for *mut _cef_before_download_callback_t {
    fn wrap_result(self) -> BeforeDownloadCallback {
        BeforeDownloadCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<BeforeDownloadCallback> for *mut _cef_before_download_callback_t {
    fn from(value: BeforeDownloadCallback) -> Self {
        let object = ImplBeforeDownloadCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for BeforeDownloadCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_download_item_callback_t`] for more documentation.
#[derive(Clone)]
pub struct DownloadItemCallback(RefGuard<_cef_download_item_callback_t>);
pub trait ImplDownloadItemCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_download_item_callback_t::cancel`] for more documentation."]
    fn cancel(&self);
    #[doc = "See [`_cef_download_item_callback_t::pause`] for more documentation."]
    fn pause(&self);
    #[doc = "See [`_cef_download_item_callback_t::resume`] for more documentation."]
    fn resume(&self);
    fn get_raw(&self) -> *mut _cef_download_item_callback_t;
}
impl ImplDownloadItemCallback for DownloadItemCallback {
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn pause(&self) {
        unsafe {
            if let Some(f) = self.0.pause {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn resume(&self) {
        unsafe {
            if let Some(f) = self.0.resume {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_download_item_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_download_item_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadItemCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_item_callback_t> for &DownloadItemCallback {
    fn into_raw(self) -> *mut _cef_download_item_callback_t {
        ImplDownloadItemCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_download_item_callback_t> for &mut DownloadItemCallback {
    fn into_raw(self) -> *mut _cef_download_item_callback_t {
        ImplDownloadItemCallback::get_raw(self)
    }
}
impl ConvertReturnValue<DownloadItemCallback> for *mut _cef_download_item_callback_t {
    fn wrap_result(self) -> DownloadItemCallback {
        DownloadItemCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DownloadItemCallback> for *mut _cef_download_item_callback_t {
    fn from(value: DownloadItemCallback) -> Self {
        let object = ImplDownloadItemCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DownloadItemCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_download_handler_t`] for more documentation.
#[derive(Clone)]
pub struct DownloadHandler(RefGuard<_cef_download_handler_t>);
impl DownloadHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDownloadHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDownloadHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDownloadHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_download_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapDownloadHandler: ImplDownloadHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_download_handler_t, Self>);
}
pub trait ImplDownloadHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_download_handler_t::can_download`] for more documentation."]
    fn can_download(
        &self,
        browser: Option<&mut Browser>,
        url: Option<&CefString>,
        request_method: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_download_handler_t::on_before_download`] for more documentation."]
    fn on_before_download(
        &self,
        browser: Option<&mut Browser>,
        download_item: Option<&mut DownloadItem>,
        suggested_name: Option<&CefString>,
        callback: Option<&mut BeforeDownloadCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_download_handler_t::on_download_updated`] for more documentation."]
    fn on_download_updated(
        &self,
        browser: Option<&mut Browser>,
        download_item: Option<&mut DownloadItem>,
        callback: Option<&mut DownloadItemCallback>,
    ) {
    }
    fn init_methods(object: &mut _cef_download_handler_t) {
        impl_cef_download_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_download_handler_t;
}
mod impl_cef_download_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDownloadHandler>(object: &mut _cef_download_handler_t) {
        object.can_download = Some(can_download::<I>);
        object.on_before_download = Some(on_before_download::<I>);
        object.on_download_updated = Some(on_download_updated::<I>);
    }
    extern "C" fn can_download<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        url: *const cef_string_t,
        request_method: *const cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_url, arg_request_method) =
            (self_, browser, url, request_method);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_url = if arg_url.is_null() {
            None
        } else {
            Some(arg_url.into())
        };
        let arg_url = arg_url.as_ref();
        let arg_request_method = if arg_request_method.is_null() {
            None
        } else {
            Some(arg_request_method.into())
        };
        let arg_request_method = arg_request_method.as_ref();
        ImplDownloadHandler::can_download(
            &arg_self_.interface,
            arg_browser,
            arg_url,
            arg_request_method,
        )
    }
    extern "C" fn on_before_download<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        download_item: *mut _cef_download_item_t,
        suggested_name: *const cef_string_t,
        callback: *mut _cef_before_download_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_download_item, arg_suggested_name, arg_callback) =
            (self_, browser, download_item, suggested_name, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_download_item = unsafe { arg_download_item.as_mut() }
            .map(|arg| DownloadItem(unsafe { RefGuard::from_raw(arg) }));
        let arg_download_item = arg_download_item.as_mut();
        let arg_suggested_name = if arg_suggested_name.is_null() {
            None
        } else {
            Some(arg_suggested_name.into())
        };
        let arg_suggested_name = arg_suggested_name.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| BeforeDownloadCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplDownloadHandler::on_before_download(
            &arg_self_.interface,
            arg_browser,
            arg_download_item,
            arg_suggested_name,
            arg_callback,
        )
    }
    extern "C" fn on_download_updated<I: ImplDownloadHandler>(
        self_: *mut _cef_download_handler_t,
        browser: *mut _cef_browser_t,
        download_item: *mut _cef_download_item_t,
        callback: *mut _cef_download_item_callback_t,
    ) {
        let (arg_self_, arg_browser, arg_download_item, arg_callback) =
            (self_, browser, download_item, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_download_item = unsafe { arg_download_item.as_mut() }
            .map(|arg| DownloadItem(unsafe { RefGuard::from_raw(arg) }));
        let arg_download_item = arg_download_item.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| DownloadItemCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplDownloadHandler::on_download_updated(
            &arg_self_.interface,
            arg_browser,
            arg_download_item,
            arg_callback,
        )
    }
}
impl ImplDownloadHandler for DownloadHandler {
    fn can_download(
        &self,
        browser: Option<&mut Browser>,
        url: Option<&CefString>,
        request_method: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_download
                .map(|f| {
                    let (arg_browser, arg_url, arg_request_method) = (browser, url, request_method);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_url = arg_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_request_method = arg_request_method
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_url, arg_request_method);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_before_download(
        &self,
        browser: Option<&mut Browser>,
        download_item: Option<&mut DownloadItem>,
        suggested_name: Option<&CefString>,
        callback: Option<&mut BeforeDownloadCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_download
                .map(|f| {
                    let (arg_browser, arg_download_item, arg_suggested_name, arg_callback) =
                        (browser, download_item, suggested_name, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_download_item = arg_download_item
                        .map(|arg| {
                            arg.add_ref();
                            ImplDownloadItem::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_suggested_name = arg_suggested_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplBeforeDownloadCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_download_item,
                        arg_suggested_name,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_download_updated(
        &self,
        browser: Option<&mut Browser>,
        download_item: Option<&mut DownloadItem>,
        callback: Option<&mut DownloadItemCallback>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_download_updated {
                let (arg_browser, arg_download_item, arg_callback) =
                    (browser, download_item, callback);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_download_item = arg_download_item
                    .map(|arg| {
                        arg.add_ref();
                        ImplDownloadItem::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_callback = arg_callback
                    .map(|arg| {
                        arg.add_ref();
                        ImplDownloadItemCallback::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_download_item, arg_callback);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_download_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_download_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DownloadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_download_handler_t> for &DownloadHandler {
    fn into_raw(self) -> *mut _cef_download_handler_t {
        ImplDownloadHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_download_handler_t> for &mut DownloadHandler {
    fn into_raw(self) -> *mut _cef_download_handler_t {
        ImplDownloadHandler::get_raw(self)
    }
}
impl ConvertReturnValue<DownloadHandler> for *mut _cef_download_handler_t {
    fn wrap_result(self) -> DownloadHandler {
        DownloadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DownloadHandler> for *mut _cef_download_handler_t {
    fn from(value: DownloadHandler) -> Self {
        let object = ImplDownloadHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DownloadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_drag_handler_t`] for more documentation.
#[derive(Clone)]
pub struct DragHandler(RefGuard<_cef_drag_handler_t>);
impl DragHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapDragHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplDragHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapDragHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_drag_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapDragHandler: ImplDragHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_drag_handler_t, Self>);
}
pub trait ImplDragHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_drag_handler_t::on_drag_enter`] for more documentation."]
    fn on_drag_enter(
        &self,
        browser: Option<&mut Browser>,
        drag_data: Option<&mut DragData>,
        mask: DragOperationsMask,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_drag_handler_t::on_draggable_regions_changed`] for more documentation."]
    fn on_draggable_regions_changed(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        regions_count: usize,
        regions: Option<&DraggableRegion>,
    ) {
    }
    fn init_methods(object: &mut _cef_drag_handler_t) {
        impl_cef_drag_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_drag_handler_t;
}
mod impl_cef_drag_handler_t {
    use super::*;
    pub fn init_methods<I: ImplDragHandler>(object: &mut _cef_drag_handler_t) {
        object.on_drag_enter = Some(on_drag_enter::<I>);
        object.on_draggable_regions_changed = Some(on_draggable_regions_changed::<I>);
    }
    extern "C" fn on_drag_enter<I: ImplDragHandler>(
        self_: *mut _cef_drag_handler_t,
        browser: *mut _cef_browser_t,
        drag_data: *mut _cef_drag_data_t,
        mask: cef_drag_operations_mask_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_drag_data, arg_mask) = (self_, browser, drag_data, mask);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_drag_data = unsafe { arg_drag_data.as_mut() }
            .map(|arg| DragData(unsafe { RefGuard::from_raw(arg) }));
        let arg_drag_data = arg_drag_data.as_mut();
        let arg_mask = arg_mask.into_raw();
        ImplDragHandler::on_drag_enter(&arg_self_.interface, arg_browser, arg_drag_data, arg_mask)
    }
    extern "C" fn on_draggable_regions_changed<I: ImplDragHandler>(
        self_: *mut _cef_drag_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        regions_count: usize,
        regions: *const _cef_draggable_region_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_regions_count, arg_regions) =
            (self_, browser, frame, regions_count, regions);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_regions_count = arg_regions_count.into_raw();
        let arg_regions = if arg_regions.is_null() {
            None
        } else {
            Some(WrapParamRef::<DraggableRegion, _>::from(arg_regions))
        };
        let arg_regions = arg_regions.as_ref().map(|arg| arg.as_ref());
        ImplDragHandler::on_draggable_regions_changed(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_regions_count,
            arg_regions,
        )
    }
}
impl ImplDragHandler for DragHandler {
    fn on_drag_enter(
        &self,
        browser: Option<&mut Browser>,
        drag_data: Option<&mut DragData>,
        mask: DragOperationsMask,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_drag_enter
                .map(|f| {
                    let (arg_browser, arg_drag_data, arg_mask) = (browser, drag_data, mask);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_drag_data = arg_drag_data
                        .map(|arg| {
                            arg.add_ref();
                            ImplDragData::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_mask = arg_mask.into_raw();
                    let result = f(arg_self_, arg_browser, arg_drag_data, arg_mask);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_draggable_regions_changed(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        regions_count: usize,
        regions: Option<&DraggableRegion>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_draggable_regions_changed {
                let (arg_browser, arg_frame, arg_regions_count, arg_regions) =
                    (browser, frame, regions_count, regions);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_regions = arg_regions.cloned().map(|arg| arg.into());
                let arg_regions = arg_regions
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_frame,
                    arg_regions_count,
                    arg_regions,
                );
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_drag_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_drag_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for DragHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_drag_handler_t> for &DragHandler {
    fn into_raw(self) -> *mut _cef_drag_handler_t {
        ImplDragHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_drag_handler_t> for &mut DragHandler {
    fn into_raw(self) -> *mut _cef_drag_handler_t {
        ImplDragHandler::get_raw(self)
    }
}
impl ConvertReturnValue<DragHandler> for *mut _cef_drag_handler_t {
    fn wrap_result(self) -> DragHandler {
        DragHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<DragHandler> for *mut _cef_drag_handler_t {
    fn from(value: DragHandler) -> Self {
        let object = ImplDragHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for DragHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_find_handler_t`] for more documentation.
#[derive(Clone)]
pub struct FindHandler(RefGuard<_cef_find_handler_t>);
impl FindHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFindHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFindHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFindHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_find_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapFindHandler: ImplFindHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_find_handler_t, Self>);
}
pub trait ImplFindHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_find_handler_t::on_find_result`] for more documentation."]
    fn on_find_result(
        &self,
        browser: Option<&mut Browser>,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: Option<&Rect>,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
    }
    fn init_methods(object: &mut _cef_find_handler_t) {
        impl_cef_find_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_find_handler_t;
}
mod impl_cef_find_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFindHandler>(object: &mut _cef_find_handler_t) {
        object.on_find_result = Some(on_find_result::<I>);
    }
    extern "C" fn on_find_result<I: ImplFindHandler>(
        self_: *mut _cef_find_handler_t,
        browser: *mut _cef_browser_t,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: *const _cef_rect_t,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_identifier,
            arg_count,
            arg_selection_rect,
            arg_active_match_ordinal,
            arg_final_update,
        ) = (
            self_,
            browser,
            identifier,
            count,
            selection_rect,
            active_match_ordinal,
            final_update,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_identifier = arg_identifier.into_raw();
        let arg_count = arg_count.into_raw();
        let arg_selection_rect = if arg_selection_rect.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_selection_rect))
        };
        let arg_selection_rect = arg_selection_rect.as_ref().map(|arg| arg.as_ref());
        let arg_active_match_ordinal = arg_active_match_ordinal.into_raw();
        let arg_final_update = arg_final_update.into_raw();
        ImplFindHandler::on_find_result(
            &arg_self_.interface,
            arg_browser,
            arg_identifier,
            arg_count,
            arg_selection_rect,
            arg_active_match_ordinal,
            arg_final_update,
        )
    }
}
impl ImplFindHandler for FindHandler {
    fn on_find_result(
        &self,
        browser: Option<&mut Browser>,
        identifier: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        selection_rect: Option<&Rect>,
        active_match_ordinal: ::std::os::raw::c_int,
        final_update: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_find_result {
                let (
                    arg_browser,
                    arg_identifier,
                    arg_count,
                    arg_selection_rect,
                    arg_active_match_ordinal,
                    arg_final_update,
                ) = (
                    browser,
                    identifier,
                    count,
                    selection_rect,
                    active_match_ordinal,
                    final_update,
                );
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_selection_rect = arg_selection_rect.cloned().map(|arg| arg.into());
                let arg_selection_rect = arg_selection_rect
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_identifier,
                    arg_count,
                    arg_selection_rect,
                    arg_active_match_ordinal,
                    arg_final_update,
                );
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_find_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_find_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FindHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_find_handler_t> for &FindHandler {
    fn into_raw(self) -> *mut _cef_find_handler_t {
        ImplFindHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_find_handler_t> for &mut FindHandler {
    fn into_raw(self) -> *mut _cef_find_handler_t {
        ImplFindHandler::get_raw(self)
    }
}
impl ConvertReturnValue<FindHandler> for *mut _cef_find_handler_t {
    fn wrap_result(self) -> FindHandler {
        FindHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<FindHandler> for *mut _cef_find_handler_t {
    fn from(value: FindHandler) -> Self {
        let object = ImplFindHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for FindHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_focus_handler_t`] for more documentation.
#[derive(Clone)]
pub struct FocusHandler(RefGuard<_cef_focus_handler_t>);
impl FocusHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFocusHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFocusHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFocusHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_focus_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapFocusHandler: ImplFocusHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_focus_handler_t, Self>);
}
pub trait ImplFocusHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_focus_handler_t::on_take_focus`] for more documentation."]
    fn on_take_focus(&self, browser: Option<&mut Browser>, next: ::std::os::raw::c_int) {}
    #[doc = "See [`_cef_focus_handler_t::on_set_focus`] for more documentation."]
    fn on_set_focus(
        &self,
        browser: Option<&mut Browser>,
        source: FocusSource,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_focus_handler_t::on_got_focus`] for more documentation."]
    fn on_got_focus(&self, browser: Option<&mut Browser>) {}
    fn init_methods(object: &mut _cef_focus_handler_t) {
        impl_cef_focus_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_focus_handler_t;
}
mod impl_cef_focus_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFocusHandler>(object: &mut _cef_focus_handler_t) {
        object.on_take_focus = Some(on_take_focus::<I>);
        object.on_set_focus = Some(on_set_focus::<I>);
        object.on_got_focus = Some(on_got_focus::<I>);
    }
    extern "C" fn on_take_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
        next: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_next) = (self_, browser, next);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_next = arg_next.into_raw();
        ImplFocusHandler::on_take_focus(&arg_self_.interface, arg_browser, arg_next)
    }
    extern "C" fn on_set_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
        source: cef_focus_source_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_source) = (self_, browser, source);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_source = arg_source.into_raw();
        ImplFocusHandler::on_set_focus(&arg_self_.interface, arg_browser, arg_source)
    }
    extern "C" fn on_got_focus<I: ImplFocusHandler>(
        self_: *mut _cef_focus_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplFocusHandler::on_got_focus(&arg_self_.interface, arg_browser)
    }
}
impl ImplFocusHandler for FocusHandler {
    fn on_take_focus(&self, browser: Option<&mut Browser>, next: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.on_take_focus {
                let (arg_browser, arg_next) = (browser, next);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_next);
            }
        }
    }
    fn on_set_focus(
        &self,
        browser: Option<&mut Browser>,
        source: FocusSource,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_set_focus
                .map(|f| {
                    let (arg_browser, arg_source) = (browser, source);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_source = arg_source.into_raw();
                    let result = f(arg_self_, arg_browser, arg_source);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_got_focus(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_got_focus {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_focus_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_focus_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FocusHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_focus_handler_t> for &FocusHandler {
    fn into_raw(self) -> *mut _cef_focus_handler_t {
        ImplFocusHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_focus_handler_t> for &mut FocusHandler {
    fn into_raw(self) -> *mut _cef_focus_handler_t {
        ImplFocusHandler::get_raw(self)
    }
}
impl ConvertReturnValue<FocusHandler> for *mut _cef_focus_handler_t {
    fn wrap_result(self) -> FocusHandler {
        FocusHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<FocusHandler> for *mut _cef_focus_handler_t {
    fn from(value: FocusHandler) -> Self {
        let object = ImplFocusHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for FocusHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_frame_handler_t`] for more documentation.
#[derive(Clone)]
pub struct FrameHandler(RefGuard<_cef_frame_handler_t>);
impl FrameHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapFrameHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplFrameHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapFrameHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_frame_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapFrameHandler: ImplFrameHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_frame_handler_t, Self>);
}
pub trait ImplFrameHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_frame_handler_t::on_frame_created`] for more documentation."]
    fn on_frame_created(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {}
    #[doc = "See [`_cef_frame_handler_t::on_frame_destroyed`] for more documentation."]
    fn on_frame_destroyed(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {}
    #[doc = "See [`_cef_frame_handler_t::on_frame_attached`] for more documentation."]
    fn on_frame_attached(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        reattached: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_frame_handler_t::on_frame_detached`] for more documentation."]
    fn on_frame_detached(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {}
    #[doc = "See [`_cef_frame_handler_t::on_main_frame_changed`] for more documentation."]
    fn on_main_frame_changed(
        &self,
        browser: Option<&mut Browser>,
        old_frame: Option<&mut Frame>,
        new_frame: Option<&mut Frame>,
    ) {
    }
    fn init_methods(object: &mut _cef_frame_handler_t) {
        impl_cef_frame_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_frame_handler_t;
}
mod impl_cef_frame_handler_t {
    use super::*;
    pub fn init_methods<I: ImplFrameHandler>(object: &mut _cef_frame_handler_t) {
        object.on_frame_created = Some(on_frame_created::<I>);
        object.on_frame_destroyed = Some(on_frame_destroyed::<I>);
        object.on_frame_attached = Some(on_frame_attached::<I>);
        object.on_frame_detached = Some(on_frame_detached::<I>);
        object.on_main_frame_changed = Some(on_main_frame_changed::<I>);
    }
    extern "C" fn on_frame_created<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        ImplFrameHandler::on_frame_created(&arg_self_.interface, arg_browser, arg_frame)
    }
    extern "C" fn on_frame_destroyed<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        ImplFrameHandler::on_frame_destroyed(&arg_self_.interface, arg_browser, arg_frame)
    }
    extern "C" fn on_frame_attached<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        reattached: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_reattached) =
            (self_, browser, frame, reattached);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_reattached = arg_reattached.into_raw();
        ImplFrameHandler::on_frame_attached(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_reattached,
        )
    }
    extern "C" fn on_frame_detached<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_frame) = (self_, browser, frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        ImplFrameHandler::on_frame_detached(&arg_self_.interface, arg_browser, arg_frame)
    }
    extern "C" fn on_main_frame_changed<I: ImplFrameHandler>(
        self_: *mut _cef_frame_handler_t,
        browser: *mut _cef_browser_t,
        old_frame: *mut _cef_frame_t,
        new_frame: *mut _cef_frame_t,
    ) {
        let (arg_self_, arg_browser, arg_old_frame, arg_new_frame) =
            (self_, browser, old_frame, new_frame);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_old_frame =
            unsafe { arg_old_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_old_frame = arg_old_frame.as_mut();
        let mut arg_new_frame =
            unsafe { arg_new_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_new_frame = arg_new_frame.as_mut();
        ImplFrameHandler::on_main_frame_changed(
            &arg_self_.interface,
            arg_browser,
            arg_old_frame,
            arg_new_frame,
        )
    }
}
impl ImplFrameHandler for FrameHandler {
    fn on_frame_created(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {
        unsafe {
            if let Some(f) = self.0.on_frame_created {
                let (arg_browser, arg_frame) = (browser, frame);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame);
            }
        }
    }
    fn on_frame_destroyed(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {
        unsafe {
            if let Some(f) = self.0.on_frame_destroyed {
                let (arg_browser, arg_frame) = (browser, frame);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame);
            }
        }
    }
    fn on_frame_attached(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        reattached: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_frame_attached {
                let (arg_browser, arg_frame, arg_reattached) = (browser, frame, reattached);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame, arg_reattached);
            }
        }
    }
    fn on_frame_detached(&self, browser: Option<&mut Browser>, frame: Option<&mut Frame>) {
        unsafe {
            if let Some(f) = self.0.on_frame_detached {
                let (arg_browser, arg_frame) = (browser, frame);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame);
            }
        }
    }
    fn on_main_frame_changed(
        &self,
        browser: Option<&mut Browser>,
        old_frame: Option<&mut Frame>,
        new_frame: Option<&mut Frame>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_main_frame_changed {
                let (arg_browser, arg_old_frame, arg_new_frame) = (browser, old_frame, new_frame);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_old_frame = arg_old_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_new_frame = arg_new_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_old_frame, arg_new_frame);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_frame_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_frame_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FrameHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_frame_handler_t> for &FrameHandler {
    fn into_raw(self) -> *mut _cef_frame_handler_t {
        ImplFrameHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_frame_handler_t> for &mut FrameHandler {
    fn into_raw(self) -> *mut _cef_frame_handler_t {
        ImplFrameHandler::get_raw(self)
    }
}
impl ConvertReturnValue<FrameHandler> for *mut _cef_frame_handler_t {
    fn wrap_result(self) -> FrameHandler {
        FrameHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<FrameHandler> for *mut _cef_frame_handler_t {
    fn from(value: FrameHandler) -> Self {
        let object = ImplFrameHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for FrameHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_jsdialog_callback_t`] for more documentation.
#[derive(Clone)]
pub struct JsdialogCallback(RefGuard<_cef_jsdialog_callback_t>);
pub trait ImplJsdialogCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_jsdialog_callback_t::cont`] for more documentation."]
    fn cont(&self, success: ::std::os::raw::c_int, user_input: Option<&CefString>);
    fn get_raw(&self) -> *mut _cef_jsdialog_callback_t;
}
impl ImplJsdialogCallback for JsdialogCallback {
    fn cont(&self, success: ::std::os::raw::c_int, user_input: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.cont {
                let (arg_success, arg_user_input) = (success, user_input);
                let arg_self_ = self.into_raw();
                let arg_user_input = arg_user_input
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_success, arg_user_input);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_jsdialog_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_jsdialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for JsdialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_jsdialog_callback_t> for &JsdialogCallback {
    fn into_raw(self) -> *mut _cef_jsdialog_callback_t {
        ImplJsdialogCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_jsdialog_callback_t> for &mut JsdialogCallback {
    fn into_raw(self) -> *mut _cef_jsdialog_callback_t {
        ImplJsdialogCallback::get_raw(self)
    }
}
impl ConvertReturnValue<JsdialogCallback> for *mut _cef_jsdialog_callback_t {
    fn wrap_result(self) -> JsdialogCallback {
        JsdialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<JsdialogCallback> for *mut _cef_jsdialog_callback_t {
    fn from(value: JsdialogCallback) -> Self {
        let object = ImplJsdialogCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for JsdialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_jsdialog_handler_t`] for more documentation.
#[derive(Clone)]
pub struct JsdialogHandler(RefGuard<_cef_jsdialog_handler_t>);
impl JsdialogHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapJsdialogHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplJsdialogHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapJsdialogHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_jsdialog_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapJsdialogHandler: ImplJsdialogHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_jsdialog_handler_t, Self>);
}
pub trait ImplJsdialogHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_jsdialog_handler_t::on_jsdialog`] for more documentation."]
    fn on_jsdialog(
        &self,
        browser: Option<&mut Browser>,
        origin_url: Option<&CefString>,
        dialog_type: JsdialogType,
        message_text: Option<&CefString>,
        default_prompt_text: Option<&CefString>,
        callback: Option<&mut JsdialogCallback>,
        suppress_message: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_jsdialog_handler_t::on_before_unload_dialog`] for more documentation."]
    fn on_before_unload_dialog(
        &self,
        browser: Option<&mut Browser>,
        message_text: Option<&CefString>,
        is_reload: ::std::os::raw::c_int,
        callback: Option<&mut JsdialogCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_jsdialog_handler_t::on_reset_dialog_state`] for more documentation."]
    fn on_reset_dialog_state(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_jsdialog_handler_t::on_dialog_closed`] for more documentation."]
    fn on_dialog_closed(&self, browser: Option<&mut Browser>) {}
    fn init_methods(object: &mut _cef_jsdialog_handler_t) {
        impl_cef_jsdialog_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_jsdialog_handler_t;
}
mod impl_cef_jsdialog_handler_t {
    use super::*;
    pub fn init_methods<I: ImplJsdialogHandler>(object: &mut _cef_jsdialog_handler_t) {
        object.on_jsdialog = Some(on_jsdialog::<I>);
        object.on_before_unload_dialog = Some(on_before_unload_dialog::<I>);
        object.on_reset_dialog_state = Some(on_reset_dialog_state::<I>);
        object.on_dialog_closed = Some(on_dialog_closed::<I>);
    }
    extern "C" fn on_jsdialog<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
        origin_url: *const cef_string_t,
        dialog_type: cef_jsdialog_type_t,
        message_text: *const cef_string_t,
        default_prompt_text: *const cef_string_t,
        callback: *mut _cef_jsdialog_callback_t,
        suppress_message: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_origin_url,
            arg_dialog_type,
            arg_message_text,
            arg_default_prompt_text,
            arg_callback,
            arg_suppress_message,
        ) = (
            self_,
            browser,
            origin_url,
            dialog_type,
            message_text,
            default_prompt_text,
            callback,
            suppress_message,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_origin_url = if arg_origin_url.is_null() {
            None
        } else {
            Some(arg_origin_url.into())
        };
        let arg_origin_url = arg_origin_url.as_ref();
        let arg_dialog_type = arg_dialog_type.into_raw();
        let arg_message_text = if arg_message_text.is_null() {
            None
        } else {
            Some(arg_message_text.into())
        };
        let arg_message_text = arg_message_text.as_ref();
        let arg_default_prompt_text = if arg_default_prompt_text.is_null() {
            None
        } else {
            Some(arg_default_prompt_text.into())
        };
        let arg_default_prompt_text = arg_default_prompt_text.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| JsdialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let mut arg_suppress_message = if arg_suppress_message.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_suppress_message,
            ))
        };
        let arg_suppress_message = arg_suppress_message.as_mut().map(|arg| arg.as_mut());
        ImplJsdialogHandler::on_jsdialog(
            &arg_self_.interface,
            arg_browser,
            arg_origin_url,
            arg_dialog_type,
            arg_message_text,
            arg_default_prompt_text,
            arg_callback,
            arg_suppress_message,
        )
    }
    extern "C" fn on_before_unload_dialog<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
        message_text: *const cef_string_t,
        is_reload: ::std::os::raw::c_int,
        callback: *mut _cef_jsdialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_message_text, arg_is_reload, arg_callback) =
            (self_, browser, message_text, is_reload, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_message_text = if arg_message_text.is_null() {
            None
        } else {
            Some(arg_message_text.into())
        };
        let arg_message_text = arg_message_text.as_ref();
        let arg_is_reload = arg_is_reload.into_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| JsdialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplJsdialogHandler::on_before_unload_dialog(
            &arg_self_.interface,
            arg_browser,
            arg_message_text,
            arg_is_reload,
            arg_callback,
        )
    }
    extern "C" fn on_reset_dialog_state<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplJsdialogHandler::on_reset_dialog_state(&arg_self_.interface, arg_browser)
    }
    extern "C" fn on_dialog_closed<I: ImplJsdialogHandler>(
        self_: *mut _cef_jsdialog_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplJsdialogHandler::on_dialog_closed(&arg_self_.interface, arg_browser)
    }
}
impl ImplJsdialogHandler for JsdialogHandler {
    fn on_jsdialog(
        &self,
        browser: Option<&mut Browser>,
        origin_url: Option<&CefString>,
        dialog_type: JsdialogType,
        message_text: Option<&CefString>,
        default_prompt_text: Option<&CefString>,
        callback: Option<&mut JsdialogCallback>,
        suppress_message: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_jsdialog
                .map(|f| {
                    let (
                        arg_browser,
                        arg_origin_url,
                        arg_dialog_type,
                        arg_message_text,
                        arg_default_prompt_text,
                        arg_callback,
                        arg_suppress_message,
                    ) = (
                        browser,
                        origin_url,
                        dialog_type,
                        message_text,
                        default_prompt_text,
                        callback,
                        suppress_message,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_origin_url = arg_origin_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_dialog_type = arg_dialog_type.into_raw();
                    let arg_message_text = arg_message_text
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_default_prompt_text = arg_default_prompt_text
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplJsdialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_suppress_message = arg_suppress_message
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_origin_url,
                        arg_dialog_type,
                        arg_message_text,
                        arg_default_prompt_text,
                        arg_callback,
                        arg_suppress_message,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_before_unload_dialog(
        &self,
        browser: Option<&mut Browser>,
        message_text: Option<&CefString>,
        is_reload: ::std::os::raw::c_int,
        callback: Option<&mut JsdialogCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_unload_dialog
                .map(|f| {
                    let (arg_browser, arg_message_text, arg_is_reload, arg_callback) =
                        (browser, message_text, is_reload, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_message_text = arg_message_text
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplJsdialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_message_text,
                        arg_is_reload,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_reset_dialog_state(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_reset_dialog_state {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn on_dialog_closed(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_dialog_closed {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_jsdialog_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_jsdialog_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for JsdialogHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_jsdialog_handler_t> for &JsdialogHandler {
    fn into_raw(self) -> *mut _cef_jsdialog_handler_t {
        ImplJsdialogHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_jsdialog_handler_t> for &mut JsdialogHandler {
    fn into_raw(self) -> *mut _cef_jsdialog_handler_t {
        ImplJsdialogHandler::get_raw(self)
    }
}
impl ConvertReturnValue<JsdialogHandler> for *mut _cef_jsdialog_handler_t {
    fn wrap_result(self) -> JsdialogHandler {
        JsdialogHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<JsdialogHandler> for *mut _cef_jsdialog_handler_t {
    fn from(value: JsdialogHandler) -> Self {
        let object = ImplJsdialogHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for JsdialogHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_keyboard_handler_t`] for more documentation.
#[derive(Clone)]
pub struct KeyboardHandler(RefGuard<_cef_keyboard_handler_t>);
impl KeyboardHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapKeyboardHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplKeyboardHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapKeyboardHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_keyboard_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapKeyboardHandler: ImplKeyboardHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_keyboard_handler_t, Self>);
}
pub trait ImplKeyboardHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_keyboard_handler_t::on_pre_key_event`] for more documentation."]
    fn on_pre_key_event(
        &self,
        browser: Option<&mut Browser>,
        event: Option<&KeyEvent>,
        os_event: *mut u8,
        is_keyboard_shortcut: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_keyboard_handler_t::on_key_event`] for more documentation."]
    fn on_key_event(
        &self,
        browser: Option<&mut Browser>,
        event: Option<&KeyEvent>,
        os_event: *mut u8,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_keyboard_handler_t) {
        impl_cef_keyboard_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_keyboard_handler_t;
}
mod impl_cef_keyboard_handler_t {
    use super::*;
    pub fn init_methods<I: ImplKeyboardHandler>(object: &mut _cef_keyboard_handler_t) {
        object.on_pre_key_event = Some(on_pre_key_event::<I>);
        object.on_key_event = Some(on_key_event::<I>);
    }
    extern "C" fn on_pre_key_event<I: ImplKeyboardHandler>(
        self_: *mut _cef_keyboard_handler_t,
        browser: *mut _cef_browser_t,
        event: *const _cef_key_event_t,
        os_event: *mut ::std::os::raw::c_void,
        is_keyboard_shortcut: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_event, arg_os_event, arg_is_keyboard_shortcut) =
            (self_, browser, event, os_event, is_keyboard_shortcut);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent, _>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let arg_os_event = arg_os_event.cast();
        let mut arg_is_keyboard_shortcut = if arg_is_keyboard_shortcut.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_is_keyboard_shortcut,
            ))
        };
        let arg_is_keyboard_shortcut = arg_is_keyboard_shortcut.as_mut().map(|arg| arg.as_mut());
        ImplKeyboardHandler::on_pre_key_event(
            &arg_self_.interface,
            arg_browser,
            arg_event,
            arg_os_event,
            arg_is_keyboard_shortcut,
        )
    }
    extern "C" fn on_key_event<I: ImplKeyboardHandler>(
        self_: *mut _cef_keyboard_handler_t,
        browser: *mut _cef_browser_t,
        event: *const _cef_key_event_t,
        os_event: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_event, arg_os_event) = (self_, browser, event, os_event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent, _>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        let arg_os_event = arg_os_event.cast();
        ImplKeyboardHandler::on_key_event(
            &arg_self_.interface,
            arg_browser,
            arg_event,
            arg_os_event,
        )
    }
}
impl ImplKeyboardHandler for KeyboardHandler {
    fn on_pre_key_event(
        &self,
        browser: Option<&mut Browser>,
        event: Option<&KeyEvent>,
        os_event: *mut u8,
        is_keyboard_shortcut: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_pre_key_event
                .map(|f| {
                    let (arg_browser, arg_event, arg_os_event, arg_is_keyboard_shortcut) =
                        (browser, event, os_event, is_keyboard_shortcut);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_os_event = arg_os_event.cast();
                    let arg_is_keyboard_shortcut = arg_is_keyboard_shortcut
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_event,
                        arg_os_event,
                        arg_is_keyboard_shortcut,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_key_event(
        &self,
        browser: Option<&mut Browser>,
        event: Option<&KeyEvent>,
        os_event: *mut u8,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_browser, arg_event, arg_os_event) = (browser, event, os_event);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_os_event = arg_os_event.cast();
                    let result = f(arg_self_, arg_browser, arg_event, arg_os_event);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_keyboard_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_keyboard_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for KeyboardHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_keyboard_handler_t> for &KeyboardHandler {
    fn into_raw(self) -> *mut _cef_keyboard_handler_t {
        ImplKeyboardHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_keyboard_handler_t> for &mut KeyboardHandler {
    fn into_raw(self) -> *mut _cef_keyboard_handler_t {
        ImplKeyboardHandler::get_raw(self)
    }
}
impl ConvertReturnValue<KeyboardHandler> for *mut _cef_keyboard_handler_t {
    fn wrap_result(self) -> KeyboardHandler {
        KeyboardHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<KeyboardHandler> for *mut _cef_keyboard_handler_t {
    fn from(value: KeyboardHandler) -> Self {
        let object = ImplKeyboardHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for KeyboardHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_life_span_handler_t`] for more documentation.
#[derive(Clone)]
pub struct LifeSpanHandler(RefGuard<_cef_life_span_handler_t>);
impl LifeSpanHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapLifeSpanHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplLifeSpanHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapLifeSpanHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_life_span_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapLifeSpanHandler: ImplLifeSpanHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_life_span_handler_t, Self>);
}
pub trait ImplLifeSpanHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_life_span_handler_t::on_before_popup`] for more documentation."]
    fn on_before_popup(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        popup_id: ::std::os::raw::c_int,
        target_url: Option<&CefString>,
        target_frame_name: Option<&CefString>,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
        popup_features: Option<&PopupFeatures>,
        window_info: Option<&mut WindowInfo>,
        client: Option<&mut Option<impl ImplClient>>,
        settings: Option<&mut BrowserSettings>,
        extra_info: Option<&mut Option<DictionaryValue>>,
        no_javascript_access: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_life_span_handler_t::on_before_popup_aborted`] for more documentation."]
    fn on_before_popup_aborted(
        &self,
        browser: Option<&mut Browser>,
        popup_id: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_life_span_handler_t::on_before_dev_tools_popup`] for more documentation."]
    fn on_before_dev_tools_popup(
        &self,
        browser: Option<&mut Browser>,
        window_info: Option<&mut WindowInfo>,
        client: Option<&mut Option<impl ImplClient>>,
        settings: Option<&mut BrowserSettings>,
        extra_info: Option<&mut Option<DictionaryValue>>,
        use_default_window: Option<&mut ::std::os::raw::c_int>,
    ) {
    }
    #[doc = "See [`_cef_life_span_handler_t::on_after_created`] for more documentation."]
    fn on_after_created(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_life_span_handler_t::do_close`] for more documentation."]
    fn do_close(&self, browser: Option<&mut Browser>) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_life_span_handler_t::on_before_close`] for more documentation."]
    fn on_before_close(&self, browser: Option<&mut Browser>) {}
    fn init_methods(object: &mut _cef_life_span_handler_t) {
        impl_cef_life_span_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_life_span_handler_t;
}
mod impl_cef_life_span_handler_t {
    use super::*;
    pub fn init_methods<I: ImplLifeSpanHandler>(object: &mut _cef_life_span_handler_t) {
        object.on_before_popup = Some(on_before_popup::<I>);
        object.on_before_popup_aborted = Some(on_before_popup_aborted::<I>);
        object.on_before_dev_tools_popup = Some(on_before_dev_tools_popup::<I>);
        object.on_after_created = Some(on_after_created::<I>);
        object.do_close = Some(do_close::<I>);
        object.on_before_close = Some(on_before_close::<I>);
    }
    extern "C" fn on_before_popup<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        popup_id: ::std::os::raw::c_int,
        target_url: *const cef_string_t,
        target_frame_name: *const cef_string_t,
        target_disposition: cef_window_open_disposition_t,
        user_gesture: ::std::os::raw::c_int,
        popup_features: *const _cef_popup_features_t,
        window_info: *mut _cef_window_info_t,
        client: *mut *mut _cef_client_t,
        settings: *mut _cef_browser_settings_t,
        extra_info: *mut *mut _cef_dictionary_value_t,
        no_javascript_access: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_popup_id,
            arg_target_url,
            arg_target_frame_name,
            arg_target_disposition,
            arg_user_gesture,
            arg_popup_features,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_no_javascript_access,
        ) = (
            self_,
            browser,
            frame,
            popup_id,
            target_url,
            target_frame_name,
            target_disposition,
            user_gesture,
            popup_features,
            window_info,
            client,
            settings,
            extra_info,
            no_javascript_access,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_popup_id = arg_popup_id.into_raw();
        let arg_target_url = if arg_target_url.is_null() {
            None
        } else {
            Some(arg_target_url.into())
        };
        let arg_target_url = arg_target_url.as_ref();
        let arg_target_frame_name = if arg_target_frame_name.is_null() {
            None
        } else {
            Some(arg_target_frame_name.into())
        };
        let arg_target_frame_name = arg_target_frame_name.as_ref();
        let arg_target_disposition = arg_target_disposition.into_raw();
        let arg_user_gesture = arg_user_gesture.into_raw();
        let arg_popup_features = if arg_popup_features.is_null() {
            None
        } else {
            Some(WrapParamRef::<PopupFeatures, _>::from(arg_popup_features))
        };
        let arg_popup_features = arg_popup_features.as_ref().map(|arg| arg.as_ref());
        let mut arg_window_info = if arg_window_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<WindowInfo, _>::from(arg_window_info))
        };
        let arg_window_info = arg_window_info.as_mut().map(|arg| arg.as_mut());
        let mut arg_client = unsafe { arg_client.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(Client(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_client = Some(&mut arg_client);
        let mut arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<BrowserSettings, _>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_mut().map(|arg| arg.as_mut());
        let mut arg_extra_info = unsafe { arg_extra_info.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(DictionaryValue(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_extra_info = Some(&mut arg_extra_info);
        let mut arg_no_javascript_access = if arg_no_javascript_access.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_no_javascript_access,
            ))
        };
        let arg_no_javascript_access = arg_no_javascript_access.as_mut().map(|arg| arg.as_mut());
        ImplLifeSpanHandler::on_before_popup(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_popup_id,
            arg_target_url,
            arg_target_frame_name,
            arg_target_disposition,
            arg_user_gesture,
            arg_popup_features,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_no_javascript_access,
        )
    }
    extern "C" fn on_before_popup_aborted<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        popup_id: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_popup_id) = (self_, browser, popup_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_popup_id = arg_popup_id.into_raw();
        ImplLifeSpanHandler::on_before_popup_aborted(
            &arg_self_.interface,
            arg_browser,
            arg_popup_id,
        )
    }
    extern "C" fn on_before_dev_tools_popup<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
        window_info: *mut _cef_window_info_t,
        client: *mut *mut _cef_client_t,
        settings: *mut _cef_browser_settings_t,
        extra_info: *mut *mut _cef_dictionary_value_t,
        use_default_window: *mut ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_use_default_window,
        ) = (
            self_,
            browser,
            window_info,
            client,
            settings,
            extra_info,
            use_default_window,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_window_info = if arg_window_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<WindowInfo, _>::from(arg_window_info))
        };
        let arg_window_info = arg_window_info.as_mut().map(|arg| arg.as_mut());
        let mut arg_client = unsafe { arg_client.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(Client(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_client = Some(&mut arg_client);
        let mut arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<BrowserSettings, _>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_mut().map(|arg| arg.as_mut());
        let mut arg_extra_info = unsafe { arg_extra_info.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(DictionaryValue(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_extra_info = Some(&mut arg_extra_info);
        let mut arg_use_default_window = if arg_use_default_window.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_use_default_window,
            ))
        };
        let arg_use_default_window = arg_use_default_window.as_mut().map(|arg| arg.as_mut());
        ImplLifeSpanHandler::on_before_dev_tools_popup(
            &arg_self_.interface,
            arg_browser,
            arg_window_info,
            arg_client,
            arg_settings,
            arg_extra_info,
            arg_use_default_window,
        )
    }
    extern "C" fn on_after_created<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplLifeSpanHandler::on_after_created(&arg_self_.interface, arg_browser)
    }
    extern "C" fn do_close<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplLifeSpanHandler::do_close(&arg_self_.interface, arg_browser)
    }
    extern "C" fn on_before_close<I: ImplLifeSpanHandler>(
        self_: *mut _cef_life_span_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplLifeSpanHandler::on_before_close(&arg_self_.interface, arg_browser)
    }
}
impl ImplLifeSpanHandler for LifeSpanHandler {
    fn on_before_popup(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        popup_id: ::std::os::raw::c_int,
        target_url: Option<&CefString>,
        target_frame_name: Option<&CefString>,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
        popup_features: Option<&PopupFeatures>,
        window_info: Option<&mut WindowInfo>,
        client: Option<&mut Option<impl ImplClient>>,
        settings: Option<&mut BrowserSettings>,
        extra_info: Option<&mut Option<DictionaryValue>>,
        no_javascript_access: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_popup
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_popup_id,
                        arg_target_url,
                        arg_target_frame_name,
                        arg_target_disposition,
                        arg_user_gesture,
                        arg_popup_features,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_no_javascript_access,
                    ) = (
                        browser,
                        frame,
                        popup_id,
                        target_url,
                        target_frame_name,
                        target_disposition,
                        user_gesture,
                        popup_features,
                        window_info,
                        client,
                        settings,
                        extra_info,
                        no_javascript_access,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_target_url = arg_target_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_target_frame_name = arg_target_frame_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_target_disposition = arg_target_disposition.into_raw();
                    let arg_popup_features = arg_popup_features.cloned().map(|arg| arg.into());
                    let arg_popup_features = arg_popup_features
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let mut arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
                    let arg_window_info = arg_window_info
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let mut ptr = std::ptr::null_mut();
                    let arg_client = arg_client
                        .map(|arg| {
                            if let Some(arg) = arg.as_mut() {
                                arg.add_ref();
                                ptr = arg.get_raw();
                            }
                            std::ptr::from_mut(&mut ptr)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let mut ptr = std::ptr::null_mut();
                    let arg_extra_info = arg_extra_info
                        .map(|arg| {
                            if let Some(arg) = arg.as_mut() {
                                arg.add_ref();
                                ptr = arg.get_raw();
                            }
                            std::ptr::from_mut(&mut ptr)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_no_javascript_access = arg_no_javascript_access
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_popup_id,
                        arg_target_url,
                        arg_target_frame_name,
                        arg_target_disposition,
                        arg_user_gesture,
                        arg_popup_features,
                        arg_window_info,
                        arg_client,
                        arg_settings,
                        arg_extra_info,
                        arg_no_javascript_access,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_before_popup_aborted(
        &self,
        browser: Option<&mut Browser>,
        popup_id: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_before_popup_aborted {
                let (arg_browser, arg_popup_id) = (browser, popup_id);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_popup_id);
            }
        }
    }
    fn on_before_dev_tools_popup(
        &self,
        browser: Option<&mut Browser>,
        window_info: Option<&mut WindowInfo>,
        client: Option<&mut Option<impl ImplClient>>,
        settings: Option<&mut BrowserSettings>,
        extra_info: Option<&mut Option<DictionaryValue>>,
        use_default_window: Option<&mut ::std::os::raw::c_int>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_before_dev_tools_popup {
                let (
                    arg_browser,
                    arg_window_info,
                    arg_client,
                    arg_settings,
                    arg_extra_info,
                    arg_use_default_window,
                ) = (
                    browser,
                    window_info,
                    client,
                    settings,
                    extra_info,
                    use_default_window,
                );
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let mut arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
                let arg_window_info = arg_window_info
                    .as_mut()
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                let mut ptr = std::ptr::null_mut();
                let arg_client = arg_client
                    .map(|arg| {
                        if let Some(arg) = arg.as_mut() {
                            arg.add_ref();
                            ptr = arg.get_raw();
                        }
                        std::ptr::from_mut(&mut ptr)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let mut arg_settings = arg_settings.cloned().map(|arg| arg.into());
                let arg_settings = arg_settings
                    .as_mut()
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                let mut ptr = std::ptr::null_mut();
                let arg_extra_info = arg_extra_info
                    .map(|arg| {
                        if let Some(arg) = arg.as_mut() {
                            arg.add_ref();
                            ptr = arg.get_raw();
                        }
                        std::ptr::from_mut(&mut ptr)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_use_default_window = arg_use_default_window
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_browser,
                    arg_window_info,
                    arg_client,
                    arg_settings,
                    arg_extra_info,
                    arg_use_default_window,
                );
            }
        }
    }
    fn on_after_created(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_after_created {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn do_close(&self, browser: Option<&mut Browser>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .do_close
                .map(|f| {
                    let arg_browser = browser;
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_before_close(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_before_close {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_life_span_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_life_span_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LifeSpanHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_life_span_handler_t> for &LifeSpanHandler {
    fn into_raw(self) -> *mut _cef_life_span_handler_t {
        ImplLifeSpanHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_life_span_handler_t> for &mut LifeSpanHandler {
    fn into_raw(self) -> *mut _cef_life_span_handler_t {
        ImplLifeSpanHandler::get_raw(self)
    }
}
impl ConvertReturnValue<LifeSpanHandler> for *mut _cef_life_span_handler_t {
    fn wrap_result(self) -> LifeSpanHandler {
        LifeSpanHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<LifeSpanHandler> for *mut _cef_life_span_handler_t {
    fn from(value: LifeSpanHandler) -> Self {
        let object = ImplLifeSpanHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for LifeSpanHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_load_handler_t`] for more documentation.
#[derive(Clone)]
pub struct LoadHandler(RefGuard<_cef_load_handler_t>);
impl LoadHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapLoadHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplLoadHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapLoadHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_load_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapLoadHandler: ImplLoadHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_load_handler_t, Self>);
}
pub trait ImplLoadHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_load_handler_t::on_loading_state_change`] for more documentation."]
    fn on_loading_state_change(
        &self,
        browser: Option<&mut Browser>,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_load_handler_t::on_load_start`] for more documentation."]
    fn on_load_start(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        transition_type: TransitionType,
    ) {
    }
    #[doc = "See [`_cef_load_handler_t::on_load_end`] for more documentation."]
    fn on_load_end(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        http_status_code: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_load_handler_t::on_load_error`] for more documentation."]
    fn on_load_error(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        error_code: Errorcode,
        error_text: Option<&CefString>,
        failed_url: Option<&CefString>,
    ) {
    }
    fn init_methods(object: &mut _cef_load_handler_t) {
        impl_cef_load_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_load_handler_t;
}
mod impl_cef_load_handler_t {
    use super::*;
    pub fn init_methods<I: ImplLoadHandler>(object: &mut _cef_load_handler_t) {
        object.on_loading_state_change = Some(on_loading_state_change::<I>);
        object.on_load_start = Some(on_load_start::<I>);
        object.on_load_end = Some(on_load_end::<I>);
        object.on_load_error = Some(on_load_error::<I>);
    }
    extern "C" fn on_loading_state_change<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_is_loading, arg_can_go_back, arg_can_go_forward) =
            (self_, browser, is_loading, can_go_back, can_go_forward);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_is_loading = arg_is_loading.into_raw();
        let arg_can_go_back = arg_can_go_back.into_raw();
        let arg_can_go_forward = arg_can_go_forward.into_raw();
        ImplLoadHandler::on_loading_state_change(
            &arg_self_.interface,
            arg_browser,
            arg_is_loading,
            arg_can_go_back,
            arg_can_go_forward,
        )
    }
    extern "C" fn on_load_start<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        transition_type: cef_transition_type_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_transition_type) =
            (self_, browser, frame, transition_type);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_transition_type = arg_transition_type.into_raw();
        ImplLoadHandler::on_load_start(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_transition_type,
        )
    }
    extern "C" fn on_load_end<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        http_status_code: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_http_status_code) =
            (self_, browser, frame, http_status_code);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_http_status_code = arg_http_status_code.into_raw();
        ImplLoadHandler::on_load_end(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_http_status_code,
        )
    }
    extern "C" fn on_load_error<I: ImplLoadHandler>(
        self_: *mut _cef_load_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        error_code: cef_errorcode_t,
        error_text: *const cef_string_t,
        failed_url: *const cef_string_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_error_code, arg_error_text, arg_failed_url) =
            (self_, browser, frame, error_code, error_text, failed_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_error_code = arg_error_code.into_raw();
        let arg_error_text = if arg_error_text.is_null() {
            None
        } else {
            Some(arg_error_text.into())
        };
        let arg_error_text = arg_error_text.as_ref();
        let arg_failed_url = if arg_failed_url.is_null() {
            None
        } else {
            Some(arg_failed_url.into())
        };
        let arg_failed_url = arg_failed_url.as_ref();
        ImplLoadHandler::on_load_error(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_error_code,
            arg_error_text,
            arg_failed_url,
        )
    }
}
impl ImplLoadHandler for LoadHandler {
    fn on_loading_state_change(
        &self,
        browser: Option<&mut Browser>,
        is_loading: ::std::os::raw::c_int,
        can_go_back: ::std::os::raw::c_int,
        can_go_forward: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_loading_state_change {
                let (arg_browser, arg_is_loading, arg_can_go_back, arg_can_go_forward) =
                    (browser, is_loading, can_go_back, can_go_forward);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_browser,
                    arg_is_loading,
                    arg_can_go_back,
                    arg_can_go_forward,
                );
            }
        }
    }
    fn on_load_start(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        transition_type: TransitionType,
    ) {
        unsafe {
            if let Some(f) = self.0.on_load_start {
                let (arg_browser, arg_frame, arg_transition_type) =
                    (browser, frame, transition_type);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_transition_type = arg_transition_type.into_raw();
                f(arg_self_, arg_browser, arg_frame, arg_transition_type);
            }
        }
    }
    fn on_load_end(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        http_status_code: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_load_end {
                let (arg_browser, arg_frame, arg_http_status_code) =
                    (browser, frame, http_status_code);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame, arg_http_status_code);
            }
        }
    }
    fn on_load_error(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        error_code: Errorcode,
        error_text: Option<&CefString>,
        failed_url: Option<&CefString>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_load_error {
                let (arg_browser, arg_frame, arg_error_code, arg_error_text, arg_failed_url) =
                    (browser, frame, error_code, error_text, failed_url);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_error_code = arg_error_code.into_raw();
                let arg_error_text = arg_error_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_failed_url = arg_failed_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_frame,
                    arg_error_code,
                    arg_error_text,
                    arg_failed_url,
                );
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_load_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_load_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LoadHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_load_handler_t> for &LoadHandler {
    fn into_raw(self) -> *mut _cef_load_handler_t {
        ImplLoadHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_load_handler_t> for &mut LoadHandler {
    fn into_raw(self) -> *mut _cef_load_handler_t {
        ImplLoadHandler::get_raw(self)
    }
}
impl ConvertReturnValue<LoadHandler> for *mut _cef_load_handler_t {
    fn wrap_result(self) -> LoadHandler {
        LoadHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<LoadHandler> for *mut _cef_load_handler_t {
    fn from(value: LoadHandler) -> Self {
        let object = ImplLoadHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for LoadHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_media_access_callback_t`] for more documentation.
#[derive(Clone)]
pub struct MediaAccessCallback(RefGuard<_cef_media_access_callback_t>);
pub trait ImplMediaAccessCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_media_access_callback_t::cont`] for more documentation."]
    fn cont(&self, allowed_permissions: u32);
    #[doc = "See [`_cef_media_access_callback_t::cancel`] for more documentation."]
    fn cancel(&self);
    fn get_raw(&self) -> *mut _cef_media_access_callback_t;
}
impl ImplMediaAccessCallback for MediaAccessCallback {
    fn cont(&self, allowed_permissions: u32) {
        unsafe {
            if let Some(f) = self.0.cont {
                let arg_allowed_permissions = allowed_permissions;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_allowed_permissions);
            }
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_media_access_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_media_access_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MediaAccessCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_media_access_callback_t> for &MediaAccessCallback {
    fn into_raw(self) -> *mut _cef_media_access_callback_t {
        ImplMediaAccessCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_media_access_callback_t> for &mut MediaAccessCallback {
    fn into_raw(self) -> *mut _cef_media_access_callback_t {
        ImplMediaAccessCallback::get_raw(self)
    }
}
impl ConvertReturnValue<MediaAccessCallback> for *mut _cef_media_access_callback_t {
    fn wrap_result(self) -> MediaAccessCallback {
        MediaAccessCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MediaAccessCallback> for *mut _cef_media_access_callback_t {
    fn from(value: MediaAccessCallback) -> Self {
        let object = ImplMediaAccessCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MediaAccessCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_permission_prompt_callback_t`] for more documentation.
#[derive(Clone)]
pub struct PermissionPromptCallback(RefGuard<_cef_permission_prompt_callback_t>);
pub trait ImplPermissionPromptCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_permission_prompt_callback_t::cont`] for more documentation."]
    fn cont(&self, result: PermissionRequestResult);
    fn get_raw(&self) -> *mut _cef_permission_prompt_callback_t;
}
impl ImplPermissionPromptCallback for PermissionPromptCallback {
    fn cont(&self, result: PermissionRequestResult) {
        unsafe {
            if let Some(f) = self.0.cont {
                let arg_result = result;
                let arg_self_ = self.into_raw();
                let arg_result = arg_result.into_raw();
                f(arg_self_, arg_result);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_permission_prompt_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_permission_prompt_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PermissionPromptCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_permission_prompt_callback_t> for &PermissionPromptCallback {
    fn into_raw(self) -> *mut _cef_permission_prompt_callback_t {
        ImplPermissionPromptCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_permission_prompt_callback_t> for &mut PermissionPromptCallback {
    fn into_raw(self) -> *mut _cef_permission_prompt_callback_t {
        ImplPermissionPromptCallback::get_raw(self)
    }
}
impl ConvertReturnValue<PermissionPromptCallback> for *mut _cef_permission_prompt_callback_t {
    fn wrap_result(self) -> PermissionPromptCallback {
        PermissionPromptCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PermissionPromptCallback> for *mut _cef_permission_prompt_callback_t {
    fn from(value: PermissionPromptCallback) -> Self {
        let object = ImplPermissionPromptCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PermissionPromptCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_permission_handler_t`] for more documentation.
#[derive(Clone)]
pub struct PermissionHandler(RefGuard<_cef_permission_handler_t>);
impl PermissionHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPermissionHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPermissionHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPermissionHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_permission_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapPermissionHandler: ImplPermissionHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_permission_handler_t, Self>);
}
pub trait ImplPermissionHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_permission_handler_t::on_request_media_access_permission`] for more documentation."]
    fn on_request_media_access_permission(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        requesting_origin: Option<&CefString>,
        requested_permissions: u32,
        callback: Option<&mut MediaAccessCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_permission_handler_t::on_show_permission_prompt`] for more documentation."]
    fn on_show_permission_prompt(
        &self,
        browser: Option<&mut Browser>,
        prompt_id: u64,
        requesting_origin: Option<&CefString>,
        requested_permissions: u32,
        callback: Option<&mut PermissionPromptCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_permission_handler_t::on_dismiss_permission_prompt`] for more documentation."]
    fn on_dismiss_permission_prompt(
        &self,
        browser: Option<&mut Browser>,
        prompt_id: u64,
        result: PermissionRequestResult,
    ) {
    }
    fn init_methods(object: &mut _cef_permission_handler_t) {
        impl_cef_permission_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_permission_handler_t;
}
mod impl_cef_permission_handler_t {
    use super::*;
    pub fn init_methods<I: ImplPermissionHandler>(object: &mut _cef_permission_handler_t) {
        object.on_request_media_access_permission = Some(on_request_media_access_permission::<I>);
        object.on_show_permission_prompt = Some(on_show_permission_prompt::<I>);
        object.on_dismiss_permission_prompt = Some(on_dismiss_permission_prompt::<I>);
    }
    extern "C" fn on_request_media_access_permission<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        requesting_origin: *const cef_string_t,
        requested_permissions: u32,
        callback: *mut _cef_media_access_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        ) = (
            self_,
            browser,
            frame,
            requesting_origin,
            requested_permissions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_requesting_origin = if arg_requesting_origin.is_null() {
            None
        } else {
            Some(arg_requesting_origin.into())
        };
        let arg_requesting_origin = arg_requesting_origin.as_ref();
        let arg_requested_permissions = arg_requested_permissions.into_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| MediaAccessCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplPermissionHandler::on_request_media_access_permission(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        )
    }
    extern "C" fn on_show_permission_prompt<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        prompt_id: u64,
        requesting_origin: *const cef_string_t,
        requested_permissions: u32,
        callback: *mut _cef_permission_prompt_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_prompt_id,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        ) = (
            self_,
            browser,
            prompt_id,
            requesting_origin,
            requested_permissions,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_prompt_id = arg_prompt_id.into_raw();
        let arg_requesting_origin = if arg_requesting_origin.is_null() {
            None
        } else {
            Some(arg_requesting_origin.into())
        };
        let arg_requesting_origin = arg_requesting_origin.as_ref();
        let arg_requested_permissions = arg_requested_permissions.into_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| PermissionPromptCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplPermissionHandler::on_show_permission_prompt(
            &arg_self_.interface,
            arg_browser,
            arg_prompt_id,
            arg_requesting_origin,
            arg_requested_permissions,
            arg_callback,
        )
    }
    extern "C" fn on_dismiss_permission_prompt<I: ImplPermissionHandler>(
        self_: *mut _cef_permission_handler_t,
        browser: *mut _cef_browser_t,
        prompt_id: u64,
        result: cef_permission_request_result_t,
    ) {
        let (arg_self_, arg_browser, arg_prompt_id, arg_result) =
            (self_, browser, prompt_id, result);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_prompt_id = arg_prompt_id.into_raw();
        let arg_result = arg_result.into_raw();
        ImplPermissionHandler::on_dismiss_permission_prompt(
            &arg_self_.interface,
            arg_browser,
            arg_prompt_id,
            arg_result,
        )
    }
}
impl ImplPermissionHandler for PermissionHandler {
    fn on_request_media_access_permission(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        requesting_origin: Option<&CefString>,
        requested_permissions: u32,
        callback: Option<&mut MediaAccessCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_request_media_access_permission
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    ) = (
                        browser,
                        frame,
                        requesting_origin,
                        requested_permissions,
                        callback,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_requesting_origin = arg_requesting_origin
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplMediaAccessCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_show_permission_prompt(
        &self,
        browser: Option<&mut Browser>,
        prompt_id: u64,
        requesting_origin: Option<&CefString>,
        requested_permissions: u32,
        callback: Option<&mut PermissionPromptCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_show_permission_prompt
                .map(|f| {
                    let (
                        arg_browser,
                        arg_prompt_id,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    ) = (
                        browser,
                        prompt_id,
                        requesting_origin,
                        requested_permissions,
                        callback,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_requesting_origin = arg_requesting_origin
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplPermissionPromptCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_prompt_id,
                        arg_requesting_origin,
                        arg_requested_permissions,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_dismiss_permission_prompt(
        &self,
        browser: Option<&mut Browser>,
        prompt_id: u64,
        result: PermissionRequestResult,
    ) {
        unsafe {
            if let Some(f) = self.0.on_dismiss_permission_prompt {
                let (arg_browser, arg_prompt_id, arg_result) = (browser, prompt_id, result);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_result = arg_result.into_raw();
                f(arg_self_, arg_browser, arg_prompt_id, arg_result);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_permission_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_permission_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PermissionHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_permission_handler_t> for &PermissionHandler {
    fn into_raw(self) -> *mut _cef_permission_handler_t {
        ImplPermissionHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_permission_handler_t> for &mut PermissionHandler {
    fn into_raw(self) -> *mut _cef_permission_handler_t {
        ImplPermissionHandler::get_raw(self)
    }
}
impl ConvertReturnValue<PermissionHandler> for *mut _cef_permission_handler_t {
    fn wrap_result(self) -> PermissionHandler {
        PermissionHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PermissionHandler> for *mut _cef_permission_handler_t {
    fn from(value: PermissionHandler) -> Self {
        let object = ImplPermissionHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PermissionHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_print_settings_t`] for more documentation.
#[derive(Clone)]
pub struct PrintSettings(RefGuard<_cef_print_settings_t>);
pub trait ImplPrintSettings: Clone + Sized + Rc {
    #[doc = "See [`_cef_print_settings_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_print_settings_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_print_settings_t::set_orientation`] for more documentation."]
    fn set_orientation(&self, landscape: ::std::os::raw::c_int);
    #[doc = "See [`_cef_print_settings_t::is_landscape`] for more documentation."]
    fn is_landscape(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_print_settings_t::set_printer_printable_area`] for more documentation."]
    fn set_printer_printable_area(
        &self,
        physical_size_device_units: Option<&Size>,
        printable_area_device_units: Option<&Rect>,
        landscape_needs_flip: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_print_settings_t::set_device_name`] for more documentation."]
    fn set_device_name(&self, name: Option<&CefString>);
    #[doc = "See [`_cef_print_settings_t::get_device_name`] for more documentation."]
    fn device_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_print_settings_t::set_dpi`] for more documentation."]
    fn set_dpi(&self, dpi: ::std::os::raw::c_int);
    #[doc = "See [`_cef_print_settings_t::get_dpi`] for more documentation."]
    fn dpi(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_print_settings_t::set_page_ranges`] for more documentation."]
    fn set_page_ranges(&self, ranges_count: usize, ranges: Option<&Range>);
    #[doc = "See [`_cef_print_settings_t::get_page_ranges_count`] for more documentation."]
    fn page_ranges_count(&self) -> usize;
    #[doc = "See [`_cef_print_settings_t::get_page_ranges`] for more documentation."]
    fn page_ranges(&self, ranges_count: Option<&mut usize>, ranges: Option<&mut Range>);
    #[doc = "See [`_cef_print_settings_t::set_selection_only`] for more documentation."]
    fn set_selection_only(&self, selection_only: ::std::os::raw::c_int);
    #[doc = "See [`_cef_print_settings_t::is_selection_only`] for more documentation."]
    fn is_selection_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_print_settings_t::set_collate`] for more documentation."]
    fn set_collate(&self, collate: ::std::os::raw::c_int);
    #[doc = "See [`_cef_print_settings_t::will_collate`] for more documentation."]
    fn will_collate(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_print_settings_t::set_color_model`] for more documentation."]
    fn set_color_model(&self, model: ColorModel);
    #[doc = "See [`_cef_print_settings_t::get_color_model`] for more documentation."]
    fn color_model(&self) -> ColorModel;
    #[doc = "See [`_cef_print_settings_t::set_copies`] for more documentation."]
    fn set_copies(&self, copies: ::std::os::raw::c_int);
    #[doc = "See [`_cef_print_settings_t::get_copies`] for more documentation."]
    fn copies(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_print_settings_t::set_duplex_mode`] for more documentation."]
    fn set_duplex_mode(&self, mode: DuplexMode);
    #[doc = "See [`_cef_print_settings_t::get_duplex_mode`] for more documentation."]
    fn duplex_mode(&self) -> DuplexMode;
    fn get_raw(&self) -> *mut _cef_print_settings_t;
}
impl ImplPrintSettings for PrintSettings {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_orientation(&self, landscape: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_orientation {
                let arg_landscape = landscape;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_landscape);
            }
        }
    }
    fn is_landscape(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_landscape
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_printer_printable_area(
        &self,
        physical_size_device_units: Option<&Size>,
        printable_area_device_units: Option<&Rect>,
        landscape_needs_flip: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.set_printer_printable_area {
                let (
                    arg_physical_size_device_units,
                    arg_printable_area_device_units,
                    arg_landscape_needs_flip,
                ) = (
                    physical_size_device_units,
                    printable_area_device_units,
                    landscape_needs_flip,
                );
                let arg_self_ = self.into_raw();
                let arg_physical_size_device_units = arg_physical_size_device_units
                    .cloned()
                    .map(|arg| arg.into());
                let arg_physical_size_device_units = arg_physical_size_device_units
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_printable_area_device_units = arg_printable_area_device_units
                    .cloned()
                    .map(|arg| arg.into());
                let arg_printable_area_device_units = arg_printable_area_device_units
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_physical_size_device_units,
                    arg_printable_area_device_units,
                    arg_landscape_needs_flip,
                );
            }
        }
    }
    fn set_device_name(&self, name: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_device_name {
                let arg_name = name;
                let arg_self_ = self.into_raw();
                let arg_name = arg_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_name);
            }
        }
    }
    fn device_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_device_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_dpi(&self, dpi: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_dpi {
                let arg_dpi = dpi;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_dpi);
            }
        }
    }
    fn dpi(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_dpi
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_page_ranges(&self, ranges_count: usize, ranges: Option<&Range>) {
        unsafe {
            if let Some(f) = self.0.set_page_ranges {
                let (arg_ranges_count, arg_ranges) = (ranges_count, ranges);
                let arg_self_ = self.into_raw();
                let arg_ranges = arg_ranges.cloned().map(|arg| arg.into());
                let arg_ranges = arg_ranges
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_ranges_count, arg_ranges);
            }
        }
    }
    fn page_ranges_count(&self) -> usize {
        unsafe {
            self.0
                .get_page_ranges_count
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn page_ranges(&self, ranges_count: Option<&mut usize>, ranges: Option<&mut Range>) {
        unsafe {
            if let Some(f) = self.0.get_page_ranges {
                let (arg_ranges_count, arg_ranges) = (ranges_count, ranges);
                let arg_self_ = self.into_raw();
                let arg_ranges_count = arg_ranges_count
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                let mut arg_ranges = arg_ranges.cloned().map(|arg| arg.into());
                let arg_ranges = arg_ranges
                    .as_mut()
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_ranges_count, arg_ranges);
            }
        }
    }
    fn set_selection_only(&self, selection_only: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_selection_only {
                let arg_selection_only = selection_only;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_selection_only);
            }
        }
    }
    fn is_selection_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_selection_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_collate(&self, collate: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_collate {
                let arg_collate = collate;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_collate);
            }
        }
    }
    fn will_collate(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .will_collate
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_color_model(&self, model: ColorModel) {
        unsafe {
            if let Some(f) = self.0.set_color_model {
                let arg_model = model;
                let arg_self_ = self.into_raw();
                let arg_model = arg_model.into_raw();
                f(arg_self_, arg_model);
            }
        }
    }
    fn color_model(&self) -> ColorModel {
        unsafe {
            self.0
                .get_color_model
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_copies(&self, copies: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_copies {
                let arg_copies = copies;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_copies);
            }
        }
    }
    fn copies(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_copies
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_duplex_mode(&self, mode: DuplexMode) {
        unsafe {
            if let Some(f) = self.0.set_duplex_mode {
                let arg_mode = mode;
                let arg_self_ = self.into_raw();
                let arg_mode = arg_mode.into_raw();
                f(arg_self_, arg_mode);
            }
        }
    }
    fn duplex_mode(&self) -> DuplexMode {
        unsafe {
            self.0
                .get_duplex_mode
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_print_settings_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_print_settings_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintSettings {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_settings_t> for &PrintSettings {
    fn into_raw(self) -> *mut _cef_print_settings_t {
        ImplPrintSettings::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_print_settings_t> for &mut PrintSettings {
    fn into_raw(self) -> *mut _cef_print_settings_t {
        ImplPrintSettings::get_raw(self)
    }
}
impl ConvertReturnValue<PrintSettings> for *mut _cef_print_settings_t {
    fn wrap_result(self) -> PrintSettings {
        PrintSettings(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PrintSettings> for *mut _cef_print_settings_t {
    fn from(value: PrintSettings) -> Self {
        let object = ImplPrintSettings::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PrintSettings {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_print_dialog_callback_t`] for more documentation.
#[derive(Clone)]
pub struct PrintDialogCallback(RefGuard<_cef_print_dialog_callback_t>);
pub trait ImplPrintDialogCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_print_dialog_callback_t::cont`] for more documentation."]
    fn cont(&self, settings: Option<&mut PrintSettings>);
    #[doc = "See [`_cef_print_dialog_callback_t::cancel`] for more documentation."]
    fn cancel(&self);
    fn get_raw(&self) -> *mut _cef_print_dialog_callback_t;
}
impl ImplPrintDialogCallback for PrintDialogCallback {
    fn cont(&self, settings: Option<&mut PrintSettings>) {
        unsafe {
            if let Some(f) = self.0.cont {
                let arg_settings = settings;
                let arg_self_ = self.into_raw();
                let arg_settings = arg_settings
                    .map(|arg| {
                        arg.add_ref();
                        ImplPrintSettings::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_settings);
            }
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_print_dialog_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_print_dialog_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintDialogCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_dialog_callback_t> for &PrintDialogCallback {
    fn into_raw(self) -> *mut _cef_print_dialog_callback_t {
        ImplPrintDialogCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_print_dialog_callback_t> for &mut PrintDialogCallback {
    fn into_raw(self) -> *mut _cef_print_dialog_callback_t {
        ImplPrintDialogCallback::get_raw(self)
    }
}
impl ConvertReturnValue<PrintDialogCallback> for *mut _cef_print_dialog_callback_t {
    fn wrap_result(self) -> PrintDialogCallback {
        PrintDialogCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PrintDialogCallback> for *mut _cef_print_dialog_callback_t {
    fn from(value: PrintDialogCallback) -> Self {
        let object = ImplPrintDialogCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PrintDialogCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_print_job_callback_t`] for more documentation.
#[derive(Clone)]
pub struct PrintJobCallback(RefGuard<_cef_print_job_callback_t>);
pub trait ImplPrintJobCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_print_job_callback_t::cont`] for more documentation."]
    fn cont(&self);
    fn get_raw(&self) -> *mut _cef_print_job_callback_t;
}
impl ImplPrintJobCallback for PrintJobCallback {
    fn cont(&self) {
        unsafe {
            if let Some(f) = self.0.cont {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_print_job_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_print_job_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintJobCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_job_callback_t> for &PrintJobCallback {
    fn into_raw(self) -> *mut _cef_print_job_callback_t {
        ImplPrintJobCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_print_job_callback_t> for &mut PrintJobCallback {
    fn into_raw(self) -> *mut _cef_print_job_callback_t {
        ImplPrintJobCallback::get_raw(self)
    }
}
impl ConvertReturnValue<PrintJobCallback> for *mut _cef_print_job_callback_t {
    fn wrap_result(self) -> PrintJobCallback {
        PrintJobCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PrintJobCallback> for *mut _cef_print_job_callback_t {
    fn from(value: PrintJobCallback) -> Self {
        let object = ImplPrintJobCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PrintJobCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_print_handler_t`] for more documentation.
#[derive(Clone)]
pub struct PrintHandler(RefGuard<_cef_print_handler_t>);
impl PrintHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPrintHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPrintHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPrintHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_print_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapPrintHandler: ImplPrintHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_print_handler_t, Self>);
}
pub trait ImplPrintHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_print_handler_t::on_print_start`] for more documentation."]
    fn on_print_start(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_print_handler_t::on_print_settings`] for more documentation."]
    fn on_print_settings(
        &self,
        browser: Option<&mut Browser>,
        settings: Option<&mut PrintSettings>,
        get_defaults: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_print_handler_t::on_print_dialog`] for more documentation."]
    fn on_print_dialog(
        &self,
        browser: Option<&mut Browser>,
        has_selection: ::std::os::raw::c_int,
        callback: Option<&mut PrintDialogCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_print_handler_t::on_print_job`] for more documentation."]
    fn on_print_job(
        &self,
        browser: Option<&mut Browser>,
        document_name: Option<&CefString>,
        pdf_file_path: Option<&CefString>,
        callback: Option<&mut PrintJobCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_print_handler_t::on_print_reset`] for more documentation."]
    fn on_print_reset(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_print_handler_t::get_pdf_paper_size`] for more documentation."]
    fn pdf_paper_size(
        &self,
        browser: Option<&mut Browser>,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> Size {
        Default::default()
    }
    fn init_methods(object: &mut _cef_print_handler_t) {
        impl_cef_print_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_print_handler_t;
}
mod impl_cef_print_handler_t {
    use super::*;
    pub fn init_methods<I: ImplPrintHandler>(object: &mut _cef_print_handler_t) {
        object.on_print_start = Some(on_print_start::<I>);
        object.on_print_settings = Some(on_print_settings::<I>);
        object.on_print_dialog = Some(on_print_dialog::<I>);
        object.on_print_job = Some(on_print_job::<I>);
        object.on_print_reset = Some(on_print_reset::<I>);
        object.get_pdf_paper_size = Some(get_pdf_paper_size::<I>);
    }
    extern "C" fn on_print_start<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplPrintHandler::on_print_start(&arg_self_.interface, arg_browser)
    }
    extern "C" fn on_print_settings<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        settings: *mut _cef_print_settings_t,
        get_defaults: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_settings, arg_get_defaults) =
            (self_, browser, settings, get_defaults);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_settings = unsafe { arg_settings.as_mut() }
            .map(|arg| PrintSettings(unsafe { RefGuard::from_raw(arg) }));
        let arg_settings = arg_settings.as_mut();
        let arg_get_defaults = arg_get_defaults.into_raw();
        ImplPrintHandler::on_print_settings(
            &arg_self_.interface,
            arg_browser,
            arg_settings,
            arg_get_defaults,
        )
    }
    extern "C" fn on_print_dialog<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        has_selection: ::std::os::raw::c_int,
        callback: *mut _cef_print_dialog_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_has_selection, arg_callback) =
            (self_, browser, has_selection, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_has_selection = arg_has_selection.into_raw();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| PrintDialogCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplPrintHandler::on_print_dialog(
            &arg_self_.interface,
            arg_browser,
            arg_has_selection,
            arg_callback,
        )
    }
    extern "C" fn on_print_job<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        document_name: *const cef_string_t,
        pdf_file_path: *const cef_string_t,
        callback: *mut _cef_print_job_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_document_name, arg_pdf_file_path, arg_callback) =
            (self_, browser, document_name, pdf_file_path, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_document_name = if arg_document_name.is_null() {
            None
        } else {
            Some(arg_document_name.into())
        };
        let arg_document_name = arg_document_name.as_ref();
        let arg_pdf_file_path = if arg_pdf_file_path.is_null() {
            None
        } else {
            Some(arg_pdf_file_path.into())
        };
        let arg_pdf_file_path = arg_pdf_file_path.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| PrintJobCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplPrintHandler::on_print_job(
            &arg_self_.interface,
            arg_browser,
            arg_document_name,
            arg_pdf_file_path,
            arg_callback,
        )
    }
    extern "C" fn on_print_reset<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplPrintHandler::on_print_reset(&arg_self_.interface, arg_browser)
    }
    extern "C" fn get_pdf_paper_size<I: ImplPrintHandler>(
        self_: *mut _cef_print_handler_t,
        browser: *mut _cef_browser_t,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> _cef_size_t {
        let (arg_self_, arg_browser, arg_device_units_per_inch) =
            (self_, browser, device_units_per_inch);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_device_units_per_inch = arg_device_units_per_inch.into_raw();
        let result = ImplPrintHandler::pdf_paper_size(
            &arg_self_.interface,
            arg_browser,
            arg_device_units_per_inch,
        );
        result.into()
    }
}
impl ImplPrintHandler for PrintHandler {
    fn on_print_start(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_print_start {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn on_print_settings(
        &self,
        browser: Option<&mut Browser>,
        settings: Option<&mut PrintSettings>,
        get_defaults: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_print_settings {
                let (arg_browser, arg_settings, arg_get_defaults) =
                    (browser, settings, get_defaults);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_settings = arg_settings
                    .map(|arg| {
                        arg.add_ref();
                        ImplPrintSettings::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_settings, arg_get_defaults);
            }
        }
    }
    fn on_print_dialog(
        &self,
        browser: Option<&mut Browser>,
        has_selection: ::std::os::raw::c_int,
        callback: Option<&mut PrintDialogCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_print_dialog
                .map(|f| {
                    let (arg_browser, arg_has_selection, arg_callback) =
                        (browser, has_selection, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplPrintDialogCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_has_selection, arg_callback);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_print_job(
        &self,
        browser: Option<&mut Browser>,
        document_name: Option<&CefString>,
        pdf_file_path: Option<&CefString>,
        callback: Option<&mut PrintJobCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_print_job
                .map(|f| {
                    let (arg_browser, arg_document_name, arg_pdf_file_path, arg_callback) =
                        (browser, document_name, pdf_file_path, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_document_name = arg_document_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_pdf_file_path = arg_pdf_file_path
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplPrintJobCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_document_name,
                        arg_pdf_file_path,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_print_reset(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_print_reset {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn pdf_paper_size(
        &self,
        browser: Option<&mut Browser>,
        device_units_per_inch: ::std::os::raw::c_int,
    ) -> Size {
        unsafe {
            self.0
                .get_pdf_paper_size
                .map(|f| {
                    let (arg_browser, arg_device_units_per_inch) = (browser, device_units_per_inch);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_device_units_per_inch);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_print_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_print_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PrintHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_print_handler_t> for &PrintHandler {
    fn into_raw(self) -> *mut _cef_print_handler_t {
        ImplPrintHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_print_handler_t> for &mut PrintHandler {
    fn into_raw(self) -> *mut _cef_print_handler_t {
        ImplPrintHandler::get_raw(self)
    }
}
impl ConvertReturnValue<PrintHandler> for *mut _cef_print_handler_t {
    fn wrap_result(self) -> PrintHandler {
        PrintHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PrintHandler> for *mut _cef_print_handler_t {
    fn from(value: PrintHandler) -> Self {
        let object = ImplPrintHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PrintHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_accessibility_handler_t`] for more documentation.
#[derive(Clone)]
pub struct AccessibilityHandler(RefGuard<_cef_accessibility_handler_t>);
impl AccessibilityHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapAccessibilityHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplAccessibilityHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapAccessibilityHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_accessibility_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapAccessibilityHandler: ImplAccessibilityHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_accessibility_handler_t, Self>);
}
pub trait ImplAccessibilityHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_accessibility_handler_t::on_accessibility_tree_change`] for more documentation."]
    fn on_accessibility_tree_change(&self, value: Option<&mut Value>) {}
    #[doc = "See [`_cef_accessibility_handler_t::on_accessibility_location_change`] for more documentation."]
    fn on_accessibility_location_change(&self, value: Option<&mut Value>) {}
    fn init_methods(object: &mut _cef_accessibility_handler_t) {
        impl_cef_accessibility_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_accessibility_handler_t;
}
mod impl_cef_accessibility_handler_t {
    use super::*;
    pub fn init_methods<I: ImplAccessibilityHandler>(object: &mut _cef_accessibility_handler_t) {
        object.on_accessibility_tree_change = Some(on_accessibility_tree_change::<I>);
        object.on_accessibility_location_change = Some(on_accessibility_location_change::<I>);
    }
    extern "C" fn on_accessibility_tree_change<I: ImplAccessibilityHandler>(
        self_: *mut _cef_accessibility_handler_t,
        value: *mut _cef_value_t,
    ) {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        ImplAccessibilityHandler::on_accessibility_tree_change(&arg_self_.interface, arg_value)
    }
    extern "C" fn on_accessibility_location_change<I: ImplAccessibilityHandler>(
        self_: *mut _cef_accessibility_handler_t,
        value: *mut _cef_value_t,
    ) {
        let (arg_self_, arg_value) = (self_, value);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        ImplAccessibilityHandler::on_accessibility_location_change(&arg_self_.interface, arg_value)
    }
}
impl ImplAccessibilityHandler for AccessibilityHandler {
    fn on_accessibility_tree_change(&self, value: Option<&mut Value>) {
        unsafe {
            if let Some(f) = self.0.on_accessibility_tree_change {
                let arg_value = value;
                let arg_self_ = self.into_raw();
                let arg_value = arg_value
                    .map(|arg| {
                        arg.add_ref();
                        ImplValue::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_value);
            }
        }
    }
    fn on_accessibility_location_change(&self, value: Option<&mut Value>) {
        unsafe {
            if let Some(f) = self.0.on_accessibility_location_change {
                let arg_value = value;
                let arg_self_ = self.into_raw();
                let arg_value = arg_value
                    .map(|arg| {
                        arg.add_ref();
                        ImplValue::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_value);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_accessibility_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_accessibility_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AccessibilityHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_accessibility_handler_t> for &AccessibilityHandler {
    fn into_raw(self) -> *mut _cef_accessibility_handler_t {
        ImplAccessibilityHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_accessibility_handler_t> for &mut AccessibilityHandler {
    fn into_raw(self) -> *mut _cef_accessibility_handler_t {
        ImplAccessibilityHandler::get_raw(self)
    }
}
impl ConvertReturnValue<AccessibilityHandler> for *mut _cef_accessibility_handler_t {
    fn wrap_result(self) -> AccessibilityHandler {
        AccessibilityHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<AccessibilityHandler> for *mut _cef_accessibility_handler_t {
    fn from(value: AccessibilityHandler) -> Self {
        let object = ImplAccessibilityHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for AccessibilityHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_render_handler_t`] for more documentation.
#[derive(Clone)]
pub struct RenderHandler(RefGuard<_cef_render_handler_t>);
impl RenderHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRenderHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRenderHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRenderHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_render_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapRenderHandler: ImplRenderHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_render_handler_t, Self>);
}
pub trait ImplRenderHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_render_handler_t::get_accessibility_handler`] for more documentation."]
    fn accessibility_handler(&self) -> Option<AccessibilityHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_render_handler_t::get_root_screen_rect`] for more documentation."]
    fn root_screen_rect(
        &self,
        browser: Option<&mut Browser>,
        rect: Option<&mut Rect>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_render_handler_t::get_view_rect`] for more documentation."]
    fn view_rect(&self, browser: Option<&mut Browser>, rect: Option<&mut Rect>) {}
    #[doc = "See [`_cef_render_handler_t::get_screen_point`] for more documentation."]
    fn screen_point(
        &self,
        browser: Option<&mut Browser>,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: Option<&mut ::std::os::raw::c_int>,
        screen_y: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_render_handler_t::get_screen_info`] for more documentation."]
    fn screen_info(
        &self,
        browser: Option<&mut Browser>,
        screen_info: Option<&mut ScreenInfo>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_render_handler_t::on_popup_show`] for more documentation."]
    fn on_popup_show(&self, browser: Option<&mut Browser>, show: ::std::os::raw::c_int) {}
    #[doc = "See [`_cef_render_handler_t::on_popup_size`] for more documentation."]
    fn on_popup_size(&self, browser: Option<&mut Browser>, rect: Option<&Rect>) {}
    #[doc = "See [`_cef_render_handler_t::on_paint`] for more documentation."]
    fn on_paint(
        &self,
        browser: Option<&mut Browser>,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: Option<&Rect>,
        buffer: *const u8,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_render_handler_t::on_accelerated_paint`] for more documentation."]
    fn on_accelerated_paint(
        &self,
        browser: Option<&mut Browser>,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: Option<&Rect>,
        info: Option<&AcceleratedPaintInfo>,
    ) {
    }
    #[doc = "See [`_cef_render_handler_t::get_touch_handle_size`] for more documentation."]
    fn touch_handle_size(
        &self,
        browser: Option<&mut Browser>,
        orientation: HorizontalAlignment,
        size: Option<&mut Size>,
    ) {
    }
    #[doc = "See [`_cef_render_handler_t::on_touch_handle_state_changed`] for more documentation."]
    fn on_touch_handle_state_changed(
        &self,
        browser: Option<&mut Browser>,
        state: Option<&TouchHandleState>,
    ) {
    }
    #[doc = "See [`_cef_render_handler_t::start_dragging`] for more documentation."]
    fn start_dragging(
        &self,
        browser: Option<&mut Browser>,
        drag_data: Option<&mut DragData>,
        allowed_ops: DragOperationsMask,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_render_handler_t::update_drag_cursor`] for more documentation."]
    fn update_drag_cursor(&self, browser: Option<&mut Browser>, operation: DragOperationsMask) {}
    #[doc = "See [`_cef_render_handler_t::on_scroll_offset_changed`] for more documentation."]
    fn on_scroll_offset_changed(&self, browser: Option<&mut Browser>, x: f64, y: f64) {}
    #[doc = "See [`_cef_render_handler_t::on_ime_composition_range_changed`] for more documentation."]
    fn on_ime_composition_range_changed(
        &self,
        browser: Option<&mut Browser>,
        selected_range: Option<&Range>,
        character_bounds_count: usize,
        character_bounds: Option<&Rect>,
    ) {
    }
    #[doc = "See [`_cef_render_handler_t::on_text_selection_changed`] for more documentation."]
    fn on_text_selection_changed(
        &self,
        browser: Option<&mut Browser>,
        selected_text: Option<&CefString>,
        selected_range: Option<&Range>,
    ) {
    }
    #[doc = "See [`_cef_render_handler_t::on_virtual_keyboard_requested`] for more documentation."]
    fn on_virtual_keyboard_requested(
        &self,
        browser: Option<&mut Browser>,
        input_mode: TextInputMode,
    ) {
    }
    fn init_methods(object: &mut _cef_render_handler_t) {
        impl_cef_render_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_render_handler_t;
}
mod impl_cef_render_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRenderHandler>(object: &mut _cef_render_handler_t) {
        object.get_accessibility_handler = Some(get_accessibility_handler::<I>);
        object.get_root_screen_rect = Some(get_root_screen_rect::<I>);
        object.get_view_rect = Some(get_view_rect::<I>);
        object.get_screen_point = Some(get_screen_point::<I>);
        object.get_screen_info = Some(get_screen_info::<I>);
        object.on_popup_show = Some(on_popup_show::<I>);
        object.on_popup_size = Some(on_popup_size::<I>);
        object.on_paint = Some(on_paint::<I>);
        object.on_accelerated_paint = Some(on_accelerated_paint::<I>);
        object.get_touch_handle_size = Some(get_touch_handle_size::<I>);
        object.on_touch_handle_state_changed = Some(on_touch_handle_state_changed::<I>);
        object.start_dragging = Some(start_dragging::<I>);
        object.update_drag_cursor = Some(update_drag_cursor::<I>);
        object.on_scroll_offset_changed = Some(on_scroll_offset_changed::<I>);
        object.on_ime_composition_range_changed = Some(on_ime_composition_range_changed::<I>);
        object.on_text_selection_changed = Some(on_text_selection_changed::<I>);
        object.on_virtual_keyboard_requested = Some(on_virtual_keyboard_requested::<I>);
    }
    extern "C" fn get_accessibility_handler<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
    ) -> *mut _cef_accessibility_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRenderHandler::accessibility_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_root_screen_rect<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *mut _cef_rect_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_rect = if arg_rect.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_rect))
        };
        let arg_rect = arg_rect.as_mut().map(|arg| arg.as_mut());
        ImplRenderHandler::root_screen_rect(&arg_self_.interface, arg_browser, arg_rect)
    }
    extern "C" fn get_view_rect<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *mut _cef_rect_t,
    ) {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_rect = if arg_rect.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_rect))
        };
        let arg_rect = arg_rect.as_mut().map(|arg| arg.as_mut());
        ImplRenderHandler::view_rect(&arg_self_.interface, arg_browser, arg_rect)
    }
    extern "C" fn get_screen_point<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: *mut ::std::os::raw::c_int,
        screen_y: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_view_x, arg_view_y, arg_screen_x, arg_screen_y) =
            (self_, browser, view_x, view_y, screen_x, screen_y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_view_x = arg_view_x.into_raw();
        let arg_view_y = arg_view_y.into_raw();
        let mut arg_screen_x = if arg_screen_x.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(arg_screen_x))
        };
        let arg_screen_x = arg_screen_x.as_mut().map(|arg| arg.as_mut());
        let mut arg_screen_y = if arg_screen_y.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(arg_screen_y))
        };
        let arg_screen_y = arg_screen_y.as_mut().map(|arg| arg.as_mut());
        ImplRenderHandler::screen_point(
            &arg_self_.interface,
            arg_browser,
            arg_view_x,
            arg_view_y,
            arg_screen_x,
            arg_screen_y,
        )
    }
    extern "C" fn get_screen_info<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        screen_info: *mut _cef_screen_info_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_screen_info) = (self_, browser, screen_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_screen_info = if arg_screen_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<ScreenInfo, _>::from(arg_screen_info))
        };
        let arg_screen_info = arg_screen_info.as_mut().map(|arg| arg.as_mut());
        ImplRenderHandler::screen_info(&arg_self_.interface, arg_browser, arg_screen_info)
    }
    extern "C" fn on_popup_show<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        show: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_show) = (self_, browser, show);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_show = arg_show.into_raw();
        ImplRenderHandler::on_popup_show(&arg_self_.interface, arg_browser, arg_show)
    }
    extern "C" fn on_popup_size<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        rect: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_browser, arg_rect) = (self_, browser, rect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_rect = if arg_rect.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_rect))
        };
        let arg_rect = arg_rect.as_ref().map(|arg| arg.as_ref());
        ImplRenderHandler::on_popup_size(&arg_self_.interface, arg_browser, arg_rect)
    }
    extern "C" fn on_paint<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        type_: cef_paint_element_type_t,
        dirty_rects_count: usize,
        dirty_rects: *const _cef_rect_t,
        buffer: *const ::std::os::raw::c_void,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_buffer,
            arg_width,
            arg_height,
        ) = (
            self_,
            browser,
            type_,
            dirty_rects_count,
            dirty_rects,
            buffer,
            width,
            height,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_type_ = arg_type_.into_raw();
        let arg_dirty_rects_count = arg_dirty_rects_count.into_raw();
        let arg_dirty_rects = if arg_dirty_rects.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_dirty_rects))
        };
        let arg_dirty_rects = arg_dirty_rects.as_ref().map(|arg| arg.as_ref());
        let arg_buffer = arg_buffer.cast();
        let arg_width = arg_width.into_raw();
        let arg_height = arg_height.into_raw();
        ImplRenderHandler::on_paint(
            &arg_self_.interface,
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_buffer,
            arg_width,
            arg_height,
        )
    }
    extern "C" fn on_accelerated_paint<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        type_: cef_paint_element_type_t,
        dirty_rects_count: usize,
        dirty_rects: *const _cef_rect_t,
        info: *const _cef_accelerated_paint_info_t,
    ) {
        let (arg_self_, arg_browser, arg_type_, arg_dirty_rects_count, arg_dirty_rects, arg_info) =
            (self_, browser, type_, dirty_rects_count, dirty_rects, info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_type_ = arg_type_.into_raw();
        let arg_dirty_rects_count = arg_dirty_rects_count.into_raw();
        let arg_dirty_rects = if arg_dirty_rects.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_dirty_rects))
        };
        let arg_dirty_rects = arg_dirty_rects.as_ref().map(|arg| arg.as_ref());
        let arg_info = if arg_info.is_null() {
            None
        } else {
            Some(WrapParamRef::<AcceleratedPaintInfo, _>::from(arg_info))
        };
        let arg_info = arg_info.as_ref().map(|arg| arg.as_ref());
        ImplRenderHandler::on_accelerated_paint(
            &arg_self_.interface,
            arg_browser,
            arg_type_,
            arg_dirty_rects_count,
            arg_dirty_rects,
            arg_info,
        )
    }
    extern "C" fn get_touch_handle_size<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        orientation: cef_horizontal_alignment_t,
        size: *mut _cef_size_t,
    ) {
        let (arg_self_, arg_browser, arg_orientation, arg_size) =
            (self_, browser, orientation, size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_orientation = arg_orientation.into_raw();
        let mut arg_size = if arg_size.is_null() {
            None
        } else {
            Some(WrapParamRef::<Size, _>::from(arg_size))
        };
        let arg_size = arg_size.as_mut().map(|arg| arg.as_mut());
        ImplRenderHandler::touch_handle_size(
            &arg_self_.interface,
            arg_browser,
            arg_orientation,
            arg_size,
        )
    }
    extern "C" fn on_touch_handle_state_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        state: *const _cef_touch_handle_state_t,
    ) {
        let (arg_self_, arg_browser, arg_state) = (self_, browser, state);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_state = if arg_state.is_null() {
            None
        } else {
            Some(WrapParamRef::<TouchHandleState, _>::from(arg_state))
        };
        let arg_state = arg_state.as_ref().map(|arg| arg.as_ref());
        ImplRenderHandler::on_touch_handle_state_changed(
            &arg_self_.interface,
            arg_browser,
            arg_state,
        )
    }
    extern "C" fn start_dragging<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        drag_data: *mut _cef_drag_data_t,
        allowed_ops: cef_drag_operations_mask_t,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_drag_data, arg_allowed_ops, arg_x, arg_y) =
            (self_, browser, drag_data, allowed_ops, x, y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_drag_data = unsafe { arg_drag_data.as_mut() }
            .map(|arg| DragData(unsafe { RefGuard::from_raw(arg) }));
        let arg_drag_data = arg_drag_data.as_mut();
        let arg_allowed_ops = arg_allowed_ops.into_raw();
        let arg_x = arg_x.into_raw();
        let arg_y = arg_y.into_raw();
        ImplRenderHandler::start_dragging(
            &arg_self_.interface,
            arg_browser,
            arg_drag_data,
            arg_allowed_ops,
            arg_x,
            arg_y,
        )
    }
    extern "C" fn update_drag_cursor<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        operation: cef_drag_operations_mask_t,
    ) {
        let (arg_self_, arg_browser, arg_operation) = (self_, browser, operation);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_operation = arg_operation.into_raw();
        ImplRenderHandler::update_drag_cursor(&arg_self_.interface, arg_browser, arg_operation)
    }
    extern "C" fn on_scroll_offset_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        x: f64,
        y: f64,
    ) {
        let (arg_self_, arg_browser, arg_x, arg_y) = (self_, browser, x, y);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_x = arg_x.into_raw();
        let arg_y = arg_y.into_raw();
        ImplRenderHandler::on_scroll_offset_changed(&arg_self_.interface, arg_browser, arg_x, arg_y)
    }
    extern "C" fn on_ime_composition_range_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        selected_range: *const _cef_range_t,
        character_bounds_count: usize,
        character_bounds: *const _cef_rect_t,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_selected_range,
            arg_character_bounds_count,
            arg_character_bounds,
        ) = (
            self_,
            browser,
            selected_range,
            character_bounds_count,
            character_bounds,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_selected_range = if arg_selected_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range, _>::from(arg_selected_range))
        };
        let arg_selected_range = arg_selected_range.as_ref().map(|arg| arg.as_ref());
        let arg_character_bounds_count = arg_character_bounds_count.into_raw();
        let arg_character_bounds = if arg_character_bounds.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_character_bounds))
        };
        let arg_character_bounds = arg_character_bounds.as_ref().map(|arg| arg.as_ref());
        ImplRenderHandler::on_ime_composition_range_changed(
            &arg_self_.interface,
            arg_browser,
            arg_selected_range,
            arg_character_bounds_count,
            arg_character_bounds,
        )
    }
    extern "C" fn on_text_selection_changed<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        selected_text: *const cef_string_t,
        selected_range: *const _cef_range_t,
    ) {
        let (arg_self_, arg_browser, arg_selected_text, arg_selected_range) =
            (self_, browser, selected_text, selected_range);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_selected_text = if arg_selected_text.is_null() {
            None
        } else {
            Some(arg_selected_text.into())
        };
        let arg_selected_text = arg_selected_text.as_ref();
        let arg_selected_range = if arg_selected_range.is_null() {
            None
        } else {
            Some(WrapParamRef::<Range, _>::from(arg_selected_range))
        };
        let arg_selected_range = arg_selected_range.as_ref().map(|arg| arg.as_ref());
        ImplRenderHandler::on_text_selection_changed(
            &arg_self_.interface,
            arg_browser,
            arg_selected_text,
            arg_selected_range,
        )
    }
    extern "C" fn on_virtual_keyboard_requested<I: ImplRenderHandler>(
        self_: *mut _cef_render_handler_t,
        browser: *mut _cef_browser_t,
        input_mode: cef_text_input_mode_t,
    ) {
        let (arg_self_, arg_browser, arg_input_mode) = (self_, browser, input_mode);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_input_mode = arg_input_mode.into_raw();
        ImplRenderHandler::on_virtual_keyboard_requested(
            &arg_self_.interface,
            arg_browser,
            arg_input_mode,
        )
    }
}
impl ImplRenderHandler for RenderHandler {
    fn accessibility_handler(&self) -> Option<AccessibilityHandler> {
        unsafe {
            self.0
                .get_accessibility_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn root_screen_rect(
        &self,
        browser: Option<&mut Browser>,
        rect: Option<&mut Rect>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_root_screen_rect
                .map(|f| {
                    let (arg_browser, arg_rect) = (browser, rect);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_rect = arg_rect.cloned().map(|arg| arg.into());
                    let arg_rect = arg_rect
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_rect);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn view_rect(&self, browser: Option<&mut Browser>, rect: Option<&mut Rect>) {
        unsafe {
            if let Some(f) = self.0.get_view_rect {
                let (arg_browser, arg_rect) = (browser, rect);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let mut arg_rect = arg_rect.cloned().map(|arg| arg.into());
                let arg_rect = arg_rect
                    .as_mut()
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_rect);
            }
        }
    }
    fn screen_point(
        &self,
        browser: Option<&mut Browser>,
        view_x: ::std::os::raw::c_int,
        view_y: ::std::os::raw::c_int,
        screen_x: Option<&mut ::std::os::raw::c_int>,
        screen_y: Option<&mut ::std::os::raw::c_int>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_screen_point
                .map(|f| {
                    let (arg_browser, arg_view_x, arg_view_y, arg_screen_x, arg_screen_y) =
                        (browser, view_x, view_y, screen_x, screen_y);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_screen_x = arg_screen_x
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_screen_y = arg_screen_y
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_view_x,
                        arg_view_y,
                        arg_screen_x,
                        arg_screen_y,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn screen_info(
        &self,
        browser: Option<&mut Browser>,
        screen_info: Option<&mut ScreenInfo>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_screen_info
                .map(|f| {
                    let (arg_browser, arg_screen_info) = (browser, screen_info);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_screen_info = arg_screen_info.cloned().map(|arg| arg.into());
                    let arg_screen_info = arg_screen_info
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_screen_info);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_popup_show(&self, browser: Option<&mut Browser>, show: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.on_popup_show {
                let (arg_browser, arg_show) = (browser, show);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_show);
            }
        }
    }
    fn on_popup_size(&self, browser: Option<&mut Browser>, rect: Option<&Rect>) {
        unsafe {
            if let Some(f) = self.0.on_popup_size {
                let (arg_browser, arg_rect) = (browser, rect);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_rect = arg_rect.cloned().map(|arg| arg.into());
                let arg_rect = arg_rect
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_browser, arg_rect);
            }
        }
    }
    fn on_paint(
        &self,
        browser: Option<&mut Browser>,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: Option<&Rect>,
        buffer: *const u8,
        width: ::std::os::raw::c_int,
        height: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_paint {
                let (
                    arg_browser,
                    arg_type_,
                    arg_dirty_rects_count,
                    arg_dirty_rects,
                    arg_buffer,
                    arg_width,
                    arg_height,
                ) = (
                    browser,
                    type_,
                    dirty_rects_count,
                    dirty_rects,
                    buffer,
                    width,
                    height,
                );
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_type_ = arg_type_.into_raw();
                let arg_dirty_rects = arg_dirty_rects.cloned().map(|arg| arg.into());
                let arg_dirty_rects = arg_dirty_rects
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_buffer = arg_buffer.cast();
                f(
                    arg_self_,
                    arg_browser,
                    arg_type_,
                    arg_dirty_rects_count,
                    arg_dirty_rects,
                    arg_buffer,
                    arg_width,
                    arg_height,
                );
            }
        }
    }
    fn on_accelerated_paint(
        &self,
        browser: Option<&mut Browser>,
        type_: PaintElementType,
        dirty_rects_count: usize,
        dirty_rects: Option<&Rect>,
        info: Option<&AcceleratedPaintInfo>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_accelerated_paint {
                let (arg_browser, arg_type_, arg_dirty_rects_count, arg_dirty_rects, arg_info) =
                    (browser, type_, dirty_rects_count, dirty_rects, info);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_type_ = arg_type_.into_raw();
                let arg_dirty_rects = arg_dirty_rects.cloned().map(|arg| arg.into());
                let arg_dirty_rects = arg_dirty_rects
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_info = arg_info.cloned().map(|arg| arg.into());
                let arg_info = arg_info
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_type_,
                    arg_dirty_rects_count,
                    arg_dirty_rects,
                    arg_info,
                );
            }
        }
    }
    fn touch_handle_size(
        &self,
        browser: Option<&mut Browser>,
        orientation: HorizontalAlignment,
        size: Option<&mut Size>,
    ) {
        unsafe {
            if let Some(f) = self.0.get_touch_handle_size {
                let (arg_browser, arg_orientation, arg_size) = (browser, orientation, size);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_orientation = arg_orientation.into_raw();
                let mut arg_size = arg_size.cloned().map(|arg| arg.into());
                let arg_size = arg_size
                    .as_mut()
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_orientation, arg_size);
            }
        }
    }
    fn on_touch_handle_state_changed(
        &self,
        browser: Option<&mut Browser>,
        state: Option<&TouchHandleState>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_touch_handle_state_changed {
                let (arg_browser, arg_state) = (browser, state);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_state = arg_state.cloned().map(|arg| arg.into());
                let arg_state = arg_state
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_browser, arg_state);
            }
        }
    }
    fn start_dragging(
        &self,
        browser: Option<&mut Browser>,
        drag_data: Option<&mut DragData>,
        allowed_ops: DragOperationsMask,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .start_dragging
                .map(|f| {
                    let (arg_browser, arg_drag_data, arg_allowed_ops, arg_x, arg_y) =
                        (browser, drag_data, allowed_ops, x, y);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_drag_data = arg_drag_data
                        .map(|arg| {
                            arg.add_ref();
                            ImplDragData::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_allowed_ops = arg_allowed_ops.into_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_drag_data,
                        arg_allowed_ops,
                        arg_x,
                        arg_y,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn update_drag_cursor(&self, browser: Option<&mut Browser>, operation: DragOperationsMask) {
        unsafe {
            if let Some(f) = self.0.update_drag_cursor {
                let (arg_browser, arg_operation) = (browser, operation);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_operation = arg_operation.into_raw();
                f(arg_self_, arg_browser, arg_operation);
            }
        }
    }
    fn on_scroll_offset_changed(&self, browser: Option<&mut Browser>, x: f64, y: f64) {
        unsafe {
            if let Some(f) = self.0.on_scroll_offset_changed {
                let (arg_browser, arg_x, arg_y) = (browser, x, y);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_x, arg_y);
            }
        }
    }
    fn on_ime_composition_range_changed(
        &self,
        browser: Option<&mut Browser>,
        selected_range: Option<&Range>,
        character_bounds_count: usize,
        character_bounds: Option<&Rect>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_ime_composition_range_changed {
                let (
                    arg_browser,
                    arg_selected_range,
                    arg_character_bounds_count,
                    arg_character_bounds,
                ) = (
                    browser,
                    selected_range,
                    character_bounds_count,
                    character_bounds,
                );
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_selected_range = arg_selected_range.cloned().map(|arg| arg.into());
                let arg_selected_range = arg_selected_range
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_character_bounds = arg_character_bounds.cloned().map(|arg| arg.into());
                let arg_character_bounds = arg_character_bounds
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_selected_range,
                    arg_character_bounds_count,
                    arg_character_bounds,
                );
            }
        }
    }
    fn on_text_selection_changed(
        &self,
        browser: Option<&mut Browser>,
        selected_text: Option<&CefString>,
        selected_range: Option<&Range>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_text_selection_changed {
                let (arg_browser, arg_selected_text, arg_selected_range) =
                    (browser, selected_text, selected_range);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_selected_text = arg_selected_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_selected_range = arg_selected_range.cloned().map(|arg| arg.into());
                let arg_selected_range = arg_selected_range
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_selected_text,
                    arg_selected_range,
                );
            }
        }
    }
    fn on_virtual_keyboard_requested(
        &self,
        browser: Option<&mut Browser>,
        input_mode: TextInputMode,
    ) {
        unsafe {
            if let Some(f) = self.0.on_virtual_keyboard_requested {
                let (arg_browser, arg_input_mode) = (browser, input_mode);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_input_mode = arg_input_mode.into_raw();
                f(arg_self_, arg_browser, arg_input_mode);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_render_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_render_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RenderHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_render_handler_t> for &RenderHandler {
    fn into_raw(self) -> *mut _cef_render_handler_t {
        ImplRenderHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_render_handler_t> for &mut RenderHandler {
    fn into_raw(self) -> *mut _cef_render_handler_t {
        ImplRenderHandler::get_raw(self)
    }
}
impl ConvertReturnValue<RenderHandler> for *mut _cef_render_handler_t {
    fn wrap_result(self) -> RenderHandler {
        RenderHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<RenderHandler> for *mut _cef_render_handler_t {
    fn from(value: RenderHandler) -> Self {
        let object = ImplRenderHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for RenderHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_auth_callback_t`] for more documentation.
#[derive(Clone)]
pub struct AuthCallback(RefGuard<_cef_auth_callback_t>);
pub trait ImplAuthCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_auth_callback_t::cont`] for more documentation."]
    fn cont(&self, username: Option<&CefString>, password: Option<&CefString>);
    #[doc = "See [`_cef_auth_callback_t::cancel`] for more documentation."]
    fn cancel(&self);
    fn get_raw(&self) -> *mut _cef_auth_callback_t;
}
impl ImplAuthCallback for AuthCallback {
    fn cont(&self, username: Option<&CefString>, password: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.cont {
                let (arg_username, arg_password) = (username, password);
                let arg_self_ = self.into_raw();
                let arg_username = arg_username
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_password = arg_password
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_username, arg_password);
            }
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_auth_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_auth_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for AuthCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_auth_callback_t> for &AuthCallback {
    fn into_raw(self) -> *mut _cef_auth_callback_t {
        ImplAuthCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_auth_callback_t> for &mut AuthCallback {
    fn into_raw(self) -> *mut _cef_auth_callback_t {
        ImplAuthCallback::get_raw(self)
    }
}
impl ConvertReturnValue<AuthCallback> for *mut _cef_auth_callback_t {
    fn wrap_result(self) -> AuthCallback {
        AuthCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<AuthCallback> for *mut _cef_auth_callback_t {
    fn from(value: AuthCallback) -> Self {
        let object = ImplAuthCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for AuthCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_response_t`] for more documentation.
#[derive(Clone)]
pub struct Response(RefGuard<_cef_response_t>);
pub trait ImplResponse: Clone + Sized + Rc {
    #[doc = "See [`_cef_response_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_response_t::get_error`] for more documentation."]
    fn error(&self) -> Errorcode;
    #[doc = "See [`_cef_response_t::set_error`] for more documentation."]
    fn set_error(&self, error: Errorcode);
    #[doc = "See [`_cef_response_t::get_status`] for more documentation."]
    fn status(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_response_t::set_status`] for more documentation."]
    fn set_status(&self, status: ::std::os::raw::c_int);
    #[doc = "See [`_cef_response_t::get_status_text`] for more documentation."]
    fn status_text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_response_t::set_status_text`] for more documentation."]
    fn set_status_text(&self, status_text: Option<&CefString>);
    #[doc = "See [`_cef_response_t::get_mime_type`] for more documentation."]
    fn mime_type(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_response_t::set_mime_type`] for more documentation."]
    fn set_mime_type(&self, mime_type: Option<&CefString>);
    #[doc = "See [`_cef_response_t::get_charset`] for more documentation."]
    fn charset(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_response_t::set_charset`] for more documentation."]
    fn set_charset(&self, charset: Option<&CefString>);
    #[doc = "See [`_cef_response_t::get_header_by_name`] for more documentation."]
    fn header_by_name(&self, name: Option<&CefString>) -> CefStringUserfree;
    #[doc = "See [`_cef_response_t::set_header_by_name`] for more documentation."]
    fn set_header_by_name(
        &self,
        name: Option<&CefString>,
        value: Option<&CefString>,
        overwrite: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_response_t::get_header_map`] for more documentation."]
    fn header_map(&self, header_map: Option<&mut CefStringMultimap>);
    #[doc = "See [`_cef_response_t::set_header_map`] for more documentation."]
    fn set_header_map(&self, header_map: Option<&mut CefStringMultimap>);
    #[doc = "See [`_cef_response_t::get_url`] for more documentation."]
    fn url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_response_t::set_url`] for more documentation."]
    fn set_url(&self, url: Option<&CefString>);
    fn get_raw(&self) -> *mut _cef_response_t;
}
impl ImplResponse for Response {
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn error(&self) -> Errorcode {
        unsafe {
            self.0
                .get_error
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_error(&self, error: Errorcode) {
        unsafe {
            if let Some(f) = self.0.set_error {
                let arg_error = error;
                let arg_self_ = self.into_raw();
                let arg_error = arg_error.into_raw();
                f(arg_self_, arg_error);
            }
        }
    }
    fn status(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_status
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_status(&self, status: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_status {
                let arg_status = status;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_status);
            }
        }
    }
    fn status_text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_status_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_status_text(&self, status_text: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_status_text {
                let arg_status_text = status_text;
                let arg_self_ = self.into_raw();
                let arg_status_text = arg_status_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_status_text);
            }
        }
    }
    fn mime_type(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_mime_type
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_mime_type(&self, mime_type: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_mime_type {
                let arg_mime_type = mime_type;
                let arg_self_ = self.into_raw();
                let arg_mime_type = arg_mime_type
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_mime_type);
            }
        }
    }
    fn charset(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_charset
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_charset(&self, charset: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_charset {
                let arg_charset = charset;
                let arg_self_ = self.into_raw();
                let arg_charset = arg_charset
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_charset);
            }
        }
    }
    fn header_by_name(&self, name: Option<&CefString>) -> CefStringUserfree {
        unsafe {
            self.0
                .get_header_by_name
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_header_by_name(
        &self,
        name: Option<&CefString>,
        value: Option<&CefString>,
        overwrite: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.set_header_by_name {
                let (arg_name, arg_value, arg_overwrite) = (name, value, overwrite);
                let arg_self_ = self.into_raw();
                let arg_name = arg_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_value = arg_value
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_name, arg_value, arg_overwrite);
            }
        }
    }
    fn header_map(&self, header_map: Option<&mut CefStringMultimap>) {
        unsafe {
            if let Some(f) = self.0.get_header_map {
                let arg_header_map = header_map;
                let arg_self_ = self.into_raw();
                let arg_header_map = arg_header_map
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_header_map);
            }
        }
    }
    fn set_header_map(&self, header_map: Option<&mut CefStringMultimap>) {
        unsafe {
            if let Some(f) = self.0.set_header_map {
                let arg_header_map = header_map;
                let arg_self_ = self.into_raw();
                let arg_header_map = arg_header_map
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_header_map);
            }
        }
    }
    fn url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_url(&self, url: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_url {
                let arg_url = url;
                let arg_self_ = self.into_raw();
                let arg_url = arg_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_url);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_response_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_response_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Response {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_response_t> for &Response {
    fn into_raw(self) -> *mut _cef_response_t {
        ImplResponse::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_response_t> for &mut Response {
    fn into_raw(self) -> *mut _cef_response_t {
        ImplResponse::get_raw(self)
    }
}
impl ConvertReturnValue<Response> for *mut _cef_response_t {
    fn wrap_result(self) -> Response {
        Response(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Response> for *mut _cef_response_t {
    fn from(value: Response) -> Self {
        let object = ImplResponse::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Response {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_resource_skip_callback_t`] for more documentation.
#[derive(Clone)]
pub struct ResourceSkipCallback(RefGuard<_cef_resource_skip_callback_t>);
pub trait ImplResourceSkipCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_resource_skip_callback_t::cont`] for more documentation."]
    fn cont(&self, bytes_skipped: i64);
    fn get_raw(&self) -> *mut _cef_resource_skip_callback_t;
}
impl ImplResourceSkipCallback for ResourceSkipCallback {
    fn cont(&self, bytes_skipped: i64) {
        unsafe {
            if let Some(f) = self.0.cont {
                let arg_bytes_skipped = bytes_skipped;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_bytes_skipped);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_skip_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_resource_skip_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceSkipCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_skip_callback_t> for &ResourceSkipCallback {
    fn into_raw(self) -> *mut _cef_resource_skip_callback_t {
        ImplResourceSkipCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_skip_callback_t> for &mut ResourceSkipCallback {
    fn into_raw(self) -> *mut _cef_resource_skip_callback_t {
        ImplResourceSkipCallback::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceSkipCallback> for *mut _cef_resource_skip_callback_t {
    fn wrap_result(self) -> ResourceSkipCallback {
        ResourceSkipCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ResourceSkipCallback> for *mut _cef_resource_skip_callback_t {
    fn from(value: ResourceSkipCallback) -> Self {
        let object = ImplResourceSkipCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ResourceSkipCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_resource_read_callback_t`] for more documentation.
#[derive(Clone)]
pub struct ResourceReadCallback(RefGuard<_cef_resource_read_callback_t>);
pub trait ImplResourceReadCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_resource_read_callback_t::cont`] for more documentation."]
    fn cont(&self, bytes_read: ::std::os::raw::c_int);
    fn get_raw(&self) -> *mut _cef_resource_read_callback_t;
}
impl ImplResourceReadCallback for ResourceReadCallback {
    fn cont(&self, bytes_read: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.cont {
                let arg_bytes_read = bytes_read;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_bytes_read);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_read_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_resource_read_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceReadCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_read_callback_t> for &ResourceReadCallback {
    fn into_raw(self) -> *mut _cef_resource_read_callback_t {
        ImplResourceReadCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_read_callback_t> for &mut ResourceReadCallback {
    fn into_raw(self) -> *mut _cef_resource_read_callback_t {
        ImplResourceReadCallback::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceReadCallback> for *mut _cef_resource_read_callback_t {
    fn wrap_result(self) -> ResourceReadCallback {
        ResourceReadCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ResourceReadCallback> for *mut _cef_resource_read_callback_t {
    fn from(value: ResourceReadCallback) -> Self {
        let object = ImplResourceReadCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ResourceReadCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_resource_handler_t`] for more documentation.
#[derive(Clone)]
pub struct ResourceHandler(RefGuard<_cef_resource_handler_t>);
impl ResourceHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResourceHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResourceHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResourceHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_resource_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapResourceHandler: ImplResourceHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resource_handler_t, Self>);
}
pub trait ImplResourceHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_resource_handler_t::open`] for more documentation."]
    fn open(
        &self,
        request: Option<&mut Request>,
        handle_request: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut Callback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_resource_handler_t::process_request`] for more documentation."]
    fn process_request(
        &self,
        request: Option<&mut Request>,
        callback: Option<&mut Callback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_resource_handler_t::get_response_headers`] for more documentation."]
    fn response_headers(
        &self,
        response: Option<&mut Response>,
        response_length: Option<&mut i64>,
        redirect_url: Option<&mut CefString>,
    ) {
    }
    #[doc = "See [`_cef_resource_handler_t::skip`] for more documentation."]
    fn skip(
        &self,
        bytes_to_skip: i64,
        bytes_skipped: Option<&mut i64>,
        callback: Option<&mut ResourceSkipCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_resource_handler_t::read`] for more documentation."]
    fn read(
        &self,
        data_out: *mut u8,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut ResourceReadCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_resource_handler_t::read_response`] for more documentation."]
    fn read_response(
        &self,
        data_out: *mut u8,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut Callback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_resource_handler_t::cancel`] for more documentation."]
    fn cancel(&self) {}
    fn init_methods(object: &mut _cef_resource_handler_t) {
        impl_cef_resource_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resource_handler_t;
}
mod impl_cef_resource_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceHandler>(object: &mut _cef_resource_handler_t) {
        object.open = Some(open::<I>);
        object.process_request = Some(process_request::<I>);
        object.get_response_headers = Some(get_response_headers::<I>);
        object.skip = Some(skip::<I>);
        object.read = Some(read::<I>);
        object.read_response = Some(read_response::<I>);
        object.cancel = Some(cancel::<I>);
    }
    extern "C" fn open<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        request: *mut _cef_request_t,
        handle_request: *mut ::std::os::raw::c_int,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_request, arg_handle_request, arg_callback) =
            (self_, request, handle_request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_handle_request = if arg_handle_request.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_handle_request,
            ))
        };
        let arg_handle_request = arg_handle_request.as_mut().map(|arg| arg.as_mut());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplResourceHandler::open(
            &arg_self_.interface,
            arg_request,
            arg_handle_request,
            arg_callback,
        )
    }
    extern "C" fn process_request<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        request: *mut _cef_request_t,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_request, arg_callback) = (self_, request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplResourceHandler::process_request(&arg_self_.interface, arg_request, arg_callback)
    }
    extern "C" fn get_response_headers<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        response: *mut _cef_response_t,
        response_length: *mut i64,
        redirect_url: *mut cef_string_t,
    ) {
        let (arg_self_, arg_response, arg_response_length, arg_redirect_url) =
            (self_, response, response_length, redirect_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let mut arg_response_length = if arg_response_length.is_null() {
            None
        } else {
            Some(WrapParamRef::<i64, _>::from(arg_response_length))
        };
        let arg_response_length = arg_response_length.as_mut().map(|arg| arg.as_mut());
        let mut arg_redirect_url = if arg_redirect_url.is_null() {
            None
        } else {
            Some(arg_redirect_url.into())
        };
        let arg_redirect_url = arg_redirect_url.as_mut();
        ImplResourceHandler::response_headers(
            &arg_self_.interface,
            arg_response,
            arg_response_length,
            arg_redirect_url,
        )
    }
    extern "C" fn skip<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        bytes_to_skip: i64,
        bytes_skipped: *mut i64,
        callback: *mut _cef_resource_skip_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_bytes_to_skip, arg_bytes_skipped, arg_callback) =
            (self_, bytes_to_skip, bytes_skipped, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_bytes_to_skip = arg_bytes_to_skip.into_raw();
        let mut arg_bytes_skipped = if arg_bytes_skipped.is_null() {
            None
        } else {
            Some(WrapParamRef::<i64, _>::from(arg_bytes_skipped))
        };
        let arg_bytes_skipped = arg_bytes_skipped.as_mut().map(|arg| arg.as_mut());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| ResourceSkipCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplResourceHandler::skip(
            &arg_self_.interface,
            arg_bytes_to_skip,
            arg_bytes_skipped,
            arg_callback,
        )
    }
    extern "C" fn read<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: *mut _cef_resource_read_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
            (self_, data_out, bytes_to_read, bytes_read, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_data_out = arg_data_out.cast();
        let arg_bytes_to_read = arg_bytes_to_read.into_raw();
        let mut arg_bytes_read = if arg_bytes_read.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_bytes_read,
            ))
        };
        let arg_bytes_read = arg_bytes_read.as_mut().map(|arg| arg.as_mut());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| ResourceReadCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplResourceHandler::read(
            &arg_self_.interface,
            arg_data_out,
            arg_bytes_to_read,
            arg_bytes_read,
            arg_callback,
        )
    }
    extern "C" fn read_response<I: ImplResourceHandler>(
        self_: *mut _cef_resource_handler_t,
        data_out: *mut ::std::os::raw::c_void,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: *mut ::std::os::raw::c_int,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
            (self_, data_out, bytes_to_read, bytes_read, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_data_out = arg_data_out.cast();
        let arg_bytes_to_read = arg_bytes_to_read.into_raw();
        let mut arg_bytes_read = if arg_bytes_read.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_bytes_read,
            ))
        };
        let arg_bytes_read = arg_bytes_read.as_mut().map(|arg| arg.as_mut());
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplResourceHandler::read_response(
            &arg_self_.interface,
            arg_data_out,
            arg_bytes_to_read,
            arg_bytes_read,
            arg_callback,
        )
    }
    extern "C" fn cancel<I: ImplResourceHandler>(self_: *mut _cef_resource_handler_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplResourceHandler::cancel(&arg_self_.interface)
    }
}
impl ImplResourceHandler for ResourceHandler {
    fn open(
        &self,
        request: Option<&mut Request>,
        handle_request: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut Callback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .open
                .map(|f| {
                    let (arg_request, arg_handle_request, arg_callback) =
                        (request, handle_request, callback);
                    let arg_self_ = self.into_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_handle_request = arg_handle_request
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request, arg_handle_request, arg_callback);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn process_request(
        &self,
        request: Option<&mut Request>,
        callback: Option<&mut Callback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .process_request
                .map(|f| {
                    let (arg_request, arg_callback) = (request, callback);
                    let arg_self_ = self.into_raw();
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_request, arg_callback);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn response_headers(
        &self,
        response: Option<&mut Response>,
        response_length: Option<&mut i64>,
        redirect_url: Option<&mut CefString>,
    ) {
        unsafe {
            if let Some(f) = self.0.get_response_headers {
                let (arg_response, arg_response_length, arg_redirect_url) =
                    (response, response_length, redirect_url);
                let arg_self_ = self.into_raw();
                let arg_response = arg_response
                    .map(|arg| {
                        arg.add_ref();
                        ImplResponse::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_response_length = arg_response_length
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                let arg_redirect_url = arg_redirect_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_response,
                    arg_response_length,
                    arg_redirect_url,
                );
            }
        }
    }
    fn skip(
        &self,
        bytes_to_skip: i64,
        bytes_skipped: Option<&mut i64>,
        callback: Option<&mut ResourceSkipCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .skip
                .map(|f| {
                    let (arg_bytes_to_skip, arg_bytes_skipped, arg_callback) =
                        (bytes_to_skip, bytes_skipped, callback);
                    let arg_self_ = self.into_raw();
                    let arg_bytes_skipped = arg_bytes_skipped
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplResourceSkipCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_bytes_to_skip,
                        arg_bytes_skipped,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn read(
        &self,
        data_out: *mut u8,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut ResourceReadCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .read
                .map(|f| {
                    let (arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
                        (data_out, bytes_to_read, bytes_read, callback);
                    let arg_self_ = self.into_raw();
                    let arg_data_out = arg_data_out.cast();
                    let arg_bytes_read = arg_bytes_read
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplResourceReadCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_data_out,
                        arg_bytes_to_read,
                        arg_bytes_read,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn read_response(
        &self,
        data_out: *mut u8,
        bytes_to_read: ::std::os::raw::c_int,
        bytes_read: Option<&mut ::std::os::raw::c_int>,
        callback: Option<&mut Callback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .read_response
                .map(|f| {
                    let (arg_data_out, arg_bytes_to_read, arg_bytes_read, arg_callback) =
                        (data_out, bytes_to_read, bytes_read, callback);
                    let arg_self_ = self.into_raw();
                    let arg_data_out = arg_data_out.cast();
                    let arg_bytes_read = arg_bytes_read
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_data_out,
                        arg_bytes_to_read,
                        arg_bytes_read,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_resource_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_handler_t> for &ResourceHandler {
    fn into_raw(self) -> *mut _cef_resource_handler_t {
        ImplResourceHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_handler_t> for &mut ResourceHandler {
    fn into_raw(self) -> *mut _cef_resource_handler_t {
        ImplResourceHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceHandler> for *mut _cef_resource_handler_t {
    fn wrap_result(self) -> ResourceHandler {
        ResourceHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ResourceHandler> for *mut _cef_resource_handler_t {
    fn from(value: ResourceHandler) -> Self {
        let object = ImplResourceHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ResourceHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_response_filter_t`] for more documentation.
#[derive(Clone)]
pub struct ResponseFilter(RefGuard<_cef_response_filter_t>);
impl ResponseFilter {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResponseFilter,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResponseFilter>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResponseFilter>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_response_filter_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapResponseFilter: ImplResponseFilter {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_response_filter_t, Self>);
}
pub trait ImplResponseFilter: Clone + Sized + Rc {
    #[doc = "See [`_cef_response_filter_t::init_filter`] for more documentation."]
    fn init_filter(&self) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_response_filter_t::filter`] for more documentation."]
    fn filter(
        &self,
        data_in: Option<&mut Vec<u8>>,
        data_in_read: Option<&mut usize>,
        data_out: Option<&mut Vec<u8>>,
        data_out_written: Option<&mut usize>,
    ) -> ResponseFilterStatus {
        Default::default()
    }
    fn init_methods(object: &mut _cef_response_filter_t) {
        impl_cef_response_filter_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_response_filter_t;
}
mod impl_cef_response_filter_t {
    use super::*;
    pub fn init_methods<I: ImplResponseFilter>(object: &mut _cef_response_filter_t) {
        object.init_filter = Some(init_filter::<I>);
        object.filter = Some(filter::<I>);
    }
    extern "C" fn init_filter<I: ImplResponseFilter>(
        self_: *mut _cef_response_filter_t,
    ) -> ::std::os::raw::c_int {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplResponseFilter::init_filter(&arg_self_.interface)
    }
    extern "C" fn filter<I: ImplResponseFilter>(
        self_: *mut _cef_response_filter_t,
        data_in: *mut ::std::os::raw::c_void,
        data_in_size: usize,
        data_in_read: *mut usize,
        data_out: *mut ::std::os::raw::c_void,
        data_out_size: usize,
        data_out_written: *mut usize,
    ) -> cef_response_filter_status_t {
        let (
            arg_self_,
            arg_data_in,
            arg_data_in_size,
            arg_data_in_read,
            arg_data_out,
            arg_data_out_size,
            arg_data_out_written,
        ) = (
            self_,
            data_in,
            data_in_size,
            data_in_read,
            data_out,
            data_out_size,
            data_out_written,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let out_data_in = (!arg_data_in.is_null() && arg_data_in_size > 0).then(|| unsafe {
            std::slice::from_raw_parts_mut(arg_data_in.cast(), arg_data_in_size)
        });
        let mut vec_data_in = out_data_in.as_ref().map(|arg| arg.to_vec());
        let arg_data_in = vec_data_in.as_mut();
        let mut arg_data_in_read = if arg_data_in_read.is_null() {
            None
        } else {
            Some(WrapParamRef::<usize, _>::from(arg_data_in_read))
        };
        let arg_data_in_read = arg_data_in_read.as_mut().map(|arg| arg.as_mut());
        let out_data_out = (!arg_data_out.is_null() && arg_data_out_size > 0).then(|| unsafe {
            std::slice::from_raw_parts_mut(arg_data_out.cast(), arg_data_out_size)
        });
        let mut vec_data_out = out_data_out.as_ref().map(|arg| arg.to_vec());
        let arg_data_out = vec_data_out.as_mut();
        let mut arg_data_out_written = if arg_data_out_written.is_null() {
            None
        } else {
            Some(WrapParamRef::<usize, _>::from(arg_data_out_written))
        };
        let arg_data_out_written = arg_data_out_written.as_mut().map(|arg| arg.as_mut());
        let result = ImplResponseFilter::filter(
            &arg_self_.interface,
            arg_data_in,
            arg_data_in_read,
            arg_data_out,
            arg_data_out_written,
        );
        if let (Some(out_data_in), Some(vec_data_in)) = (out_data_in, vec_data_in.as_mut()) {
            let size = vec_data_in.len().min(out_data_in.len());
            out_data_in[..size].copy_from_slice(&vec_data_in[..size]);
        }
        if let (Some(out_data_out), Some(vec_data_out)) = (out_data_out, vec_data_out.as_mut()) {
            let size = vec_data_out.len().min(out_data_out.len());
            out_data_out[..size].copy_from_slice(&vec_data_out[..size]);
        }
        result.into()
    }
}
impl ImplResponseFilter for ResponseFilter {
    fn init_filter(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .init_filter
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn filter(
        &self,
        data_in: Option<&mut Vec<u8>>,
        data_in_read: Option<&mut usize>,
        data_out: Option<&mut Vec<u8>>,
        data_out_written: Option<&mut usize>,
    ) -> ResponseFilterStatus {
        unsafe {
            self.0
                .filter
                .map(|f| {
                    let (arg_data_in, arg_data_in_read, arg_data_out, arg_data_out_written) =
                        (data_in, data_in_read, data_out, data_out_written);
                    let arg_self_ = self.into_raw();
                    let arg_data_in_size = arg_data_in
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let mut out_data_in = arg_data_in;
                    let arg_data_in = out_data_in
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_in_read = arg_data_in_read
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_out_size = arg_data_out
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let mut out_data_out = arg_data_out;
                    let arg_data_out = out_data_out
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_data_out_written = arg_data_out_written
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_data_in,
                        arg_data_in_size,
                        arg_data_in_read,
                        arg_data_out,
                        arg_data_out_size,
                        arg_data_out_written,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_response_filter_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_response_filter_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResponseFilter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_response_filter_t> for &ResponseFilter {
    fn into_raw(self) -> *mut _cef_response_filter_t {
        ImplResponseFilter::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_response_filter_t> for &mut ResponseFilter {
    fn into_raw(self) -> *mut _cef_response_filter_t {
        ImplResponseFilter::get_raw(self)
    }
}
impl ConvertReturnValue<ResponseFilter> for *mut _cef_response_filter_t {
    fn wrap_result(self) -> ResponseFilter {
        ResponseFilter(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ResponseFilter> for *mut _cef_response_filter_t {
    fn from(value: ResponseFilter) -> Self {
        let object = ImplResponseFilter::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ResponseFilter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_resource_request_handler_t`] for more documentation.
#[derive(Clone)]
pub struct ResourceRequestHandler(RefGuard<_cef_resource_request_handler_t>);
impl ResourceRequestHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResourceRequestHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResourceRequestHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResourceRequestHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_resource_request_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapResourceRequestHandler: ImplResourceRequestHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resource_request_handler_t, Self>);
}
pub trait ImplResourceRequestHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_resource_request_handler_t::get_cookie_access_filter`] for more documentation."]
    fn cookie_access_filter(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
    ) -> Option<CookieAccessFilter> {
        Default::default()
    }
    #[doc = "See [`_cef_resource_request_handler_t::on_before_resource_load`] for more documentation."]
    fn on_before_resource_load(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        callback: Option<&mut Callback>,
    ) -> ReturnValue {
        Default::default()
    }
    #[doc = "See [`_cef_resource_request_handler_t::get_resource_handler`] for more documentation."]
    fn resource_handler(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
    ) -> Option<ResourceHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_resource_request_handler_t::on_resource_redirect`] for more documentation."]
    fn on_resource_redirect(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
        new_url: Option<&mut CefString>,
    ) {
    }
    #[doc = "See [`_cef_resource_request_handler_t::on_resource_response`] for more documentation."]
    fn on_resource_response(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_resource_request_handler_t::get_resource_response_filter`] for more documentation."]
    fn resource_response_filter(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
    ) -> Option<ResponseFilter> {
        Default::default()
    }
    #[doc = "See [`_cef_resource_request_handler_t::on_resource_load_complete`] for more documentation."]
    fn on_resource_load_complete(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
        status: UrlrequestStatus,
        received_content_length: i64,
    ) {
    }
    #[doc = "See [`_cef_resource_request_handler_t::on_protocol_execution`] for more documentation."]
    fn on_protocol_execution(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        allow_os_execution: Option<&mut ::std::os::raw::c_int>,
    ) {
    }
    fn init_methods(object: &mut _cef_resource_request_handler_t) {
        impl_cef_resource_request_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resource_request_handler_t;
}
mod impl_cef_resource_request_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceRequestHandler>(
        object: &mut _cef_resource_request_handler_t,
    ) {
        object.get_cookie_access_filter = Some(get_cookie_access_filter::<I>);
        object.on_before_resource_load = Some(on_before_resource_load::<I>);
        object.get_resource_handler = Some(get_resource_handler::<I>);
        object.on_resource_redirect = Some(on_resource_redirect::<I>);
        object.on_resource_response = Some(on_resource_response::<I>);
        object.get_resource_response_filter = Some(get_resource_response_filter::<I>);
        object.on_resource_load_complete = Some(on_resource_load_complete::<I>);
        object.on_protocol_execution = Some(on_protocol_execution::<I>);
    }
    extern "C" fn get_cookie_access_filter<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_cookie_access_filter_t {
        let (arg_self_, arg_browser, arg_frame, arg_request) = (self_, browser, frame, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let result = ImplResourceRequestHandler::cookie_access_filter(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_before_resource_load<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        callback: *mut _cef_callback_t,
    ) -> cef_return_value_t {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_callback) =
            (self_, browser, frame, request, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        let result = ImplResourceRequestHandler::on_before_resource_load(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_callback,
        );
        result.into()
    }
    extern "C" fn get_resource_handler<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_resource_handler_t {
        let (arg_self_, arg_browser, arg_frame, arg_request) = (self_, browser, frame, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let result = ImplResourceRequestHandler::resource_handler(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_resource_redirect<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        new_url: *mut cef_string_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response, arg_new_url) =
            (self_, browser, frame, request, response, new_url);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let mut arg_new_url = if arg_new_url.is_null() {
            None
        } else {
            Some(arg_new_url.into())
        };
        let arg_new_url = arg_new_url.as_mut();
        ImplResourceRequestHandler::on_resource_redirect(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_new_url,
        )
    }
    extern "C" fn on_resource_response<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response) =
            (self_, browser, frame, request, response);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        ImplResourceRequestHandler::on_resource_response(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
        )
    }
    extern "C" fn get_resource_response_filter<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
    ) -> *mut _cef_response_filter_t {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response) =
            (self_, browser, frame, request, response);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let result = ImplResourceRequestHandler::resource_response_filter(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_resource_load_complete<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        status: cef_urlrequest_status_t,
        received_content_length: i64,
    ) {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_status,
            arg_received_content_length,
        ) = (
            self_,
            browser,
            frame,
            request,
            response,
            status,
            received_content_length,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let arg_status = arg_status.into_raw();
        let arg_received_content_length = arg_received_content_length.into_raw();
        ImplResourceRequestHandler::on_resource_load_complete(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_status,
            arg_received_content_length,
        )
    }
    extern "C" fn on_protocol_execution<I: ImplResourceRequestHandler>(
        self_: *mut _cef_resource_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        allow_os_execution: *mut ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_allow_os_execution) =
            (self_, browser, frame, request, allow_os_execution);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_allow_os_execution = if arg_allow_os_execution.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_allow_os_execution,
            ))
        };
        let arg_allow_os_execution = arg_allow_os_execution.as_mut().map(|arg| arg.as_mut());
        ImplResourceRequestHandler::on_protocol_execution(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_allow_os_execution,
        )
    }
}
impl ImplResourceRequestHandler for ResourceRequestHandler {
    fn cookie_access_filter(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
    ) -> Option<CookieAccessFilter> {
        unsafe {
            self.0
                .get_cookie_access_filter
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request) = (browser, frame, request);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_before_resource_load(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        callback: Option<&mut Callback>,
    ) -> ReturnValue {
        unsafe {
            self.0
                .on_before_resource_load
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_callback) =
                        (browser, frame, request, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_callback);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn resource_handler(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
    ) -> Option<ResourceHandler> {
        unsafe {
            self.0
                .get_resource_handler
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request) = (browser, frame, request);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_resource_redirect(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
        new_url: Option<&mut CefString>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_resource_redirect {
                let (arg_browser, arg_frame, arg_request, arg_response, arg_new_url) =
                    (browser, frame, request, response, new_url);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_request = arg_request
                    .map(|arg| {
                        arg.add_ref();
                        ImplRequest::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_response = arg_response
                    .map(|arg| {
                        arg.add_ref();
                        ImplResponse::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_new_url = arg_new_url
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_browser,
                    arg_frame,
                    arg_request,
                    arg_response,
                    arg_new_url,
                );
            }
        }
    }
    fn on_resource_response(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_resource_response
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response) =
                        (browser, frame, request, response);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_response);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn resource_response_filter(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
    ) -> Option<ResponseFilter> {
        unsafe {
            self.0
                .get_resource_response_filter
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response) =
                        (browser, frame, request, response);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_response);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_resource_load_complete(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
        status: UrlrequestStatus,
        received_content_length: i64,
    ) {
        unsafe {
            if let Some(f) = self.0.on_resource_load_complete {
                let (
                    arg_browser,
                    arg_frame,
                    arg_request,
                    arg_response,
                    arg_status,
                    arg_received_content_length,
                ) = (
                    browser,
                    frame,
                    request,
                    response,
                    status,
                    received_content_length,
                );
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_request = arg_request
                    .map(|arg| {
                        arg.add_ref();
                        ImplRequest::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_response = arg_response
                    .map(|arg| {
                        arg.add_ref();
                        ImplResponse::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_status = arg_status.into_raw();
                f(
                    arg_self_,
                    arg_browser,
                    arg_frame,
                    arg_request,
                    arg_response,
                    arg_status,
                    arg_received_content_length,
                );
            }
        }
    }
    fn on_protocol_execution(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        allow_os_execution: Option<&mut ::std::os::raw::c_int>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_protocol_execution {
                let (arg_browser, arg_frame, arg_request, arg_allow_os_execution) =
                    (browser, frame, request, allow_os_execution);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_request = arg_request
                    .map(|arg| {
                        arg.add_ref();
                        ImplRequest::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_allow_os_execution = arg_allow_os_execution
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_browser,
                    arg_frame,
                    arg_request,
                    arg_allow_os_execution,
                );
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_request_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_resource_request_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceRequestHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_request_handler_t> for &ResourceRequestHandler {
    fn into_raw(self) -> *mut _cef_resource_request_handler_t {
        ImplResourceRequestHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_request_handler_t> for &mut ResourceRequestHandler {
    fn into_raw(self) -> *mut _cef_resource_request_handler_t {
        ImplResourceRequestHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceRequestHandler> for *mut _cef_resource_request_handler_t {
    fn wrap_result(self) -> ResourceRequestHandler {
        ResourceRequestHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ResourceRequestHandler> for *mut _cef_resource_request_handler_t {
    fn from(value: ResourceRequestHandler) -> Self {
        let object = ImplResourceRequestHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ResourceRequestHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_cookie_access_filter_t`] for more documentation.
#[derive(Clone)]
pub struct CookieAccessFilter(RefGuard<_cef_cookie_access_filter_t>);
impl CookieAccessFilter {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapCookieAccessFilter,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplCookieAccessFilter>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapCookieAccessFilter>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_cookie_access_filter_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapCookieAccessFilter: ImplCookieAccessFilter {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_cookie_access_filter_t, Self>);
}
pub trait ImplCookieAccessFilter: Clone + Sized + Rc {
    #[doc = "See [`_cef_cookie_access_filter_t::can_send_cookie`] for more documentation."]
    fn can_send_cookie(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        cookie: Option<&Cookie>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_cookie_access_filter_t::can_save_cookie`] for more documentation."]
    fn can_save_cookie(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
        cookie: Option<&Cookie>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_cookie_access_filter_t) {
        impl_cef_cookie_access_filter_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_cookie_access_filter_t;
}
mod impl_cef_cookie_access_filter_t {
    use super::*;
    pub fn init_methods<I: ImplCookieAccessFilter>(object: &mut _cef_cookie_access_filter_t) {
        object.can_send_cookie = Some(can_send_cookie::<I>);
        object.can_save_cookie = Some(can_save_cookie::<I>);
    }
    extern "C" fn can_send_cookie<I: ImplCookieAccessFilter>(
        self_: *mut _cef_cookie_access_filter_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        cookie: *const _cef_cookie_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_cookie) =
            (self_, browser, frame, request, cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_cookie = if arg_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<Cookie, _>::from(arg_cookie))
        };
        let arg_cookie = arg_cookie.as_ref().map(|arg| arg.as_ref());
        ImplCookieAccessFilter::can_send_cookie(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_cookie,
        )
    }
    extern "C" fn can_save_cookie<I: ImplCookieAccessFilter>(
        self_: *mut _cef_cookie_access_filter_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        response: *mut _cef_response_t,
        cookie: *const _cef_cookie_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_response, arg_cookie) =
            (self_, browser, frame, request, response, cookie);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let mut arg_response = unsafe { arg_response.as_mut() }
            .map(|arg| Response(unsafe { RefGuard::from_raw(arg) }));
        let arg_response = arg_response.as_mut();
        let arg_cookie = if arg_cookie.is_null() {
            None
        } else {
            Some(WrapParamRef::<Cookie, _>::from(arg_cookie))
        };
        let arg_cookie = arg_cookie.as_ref().map(|arg| arg.as_ref());
        ImplCookieAccessFilter::can_save_cookie(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_response,
            arg_cookie,
        )
    }
}
impl ImplCookieAccessFilter for CookieAccessFilter {
    fn can_send_cookie(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        cookie: Option<&Cookie>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_send_cookie
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_cookie) =
                        (browser, frame, request, cookie);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_cookie = arg_cookie.cloned().map(|arg| arg.into());
                    let arg_cookie = arg_cookie
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_browser, arg_frame, arg_request, arg_cookie);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn can_save_cookie(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        response: Option<&mut Response>,
        cookie: Option<&Cookie>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_save_cookie
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_response, arg_cookie) =
                        (browser, frame, request, response, cookie);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_response = arg_response
                        .map(|arg| {
                            arg.add_ref();
                            ImplResponse::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_cookie = arg_cookie.cloned().map(|arg| arg.into());
                    let arg_cookie = arg_cookie
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_response,
                        arg_cookie,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_cookie_access_filter_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_cookie_access_filter_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CookieAccessFilter {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_cookie_access_filter_t> for &CookieAccessFilter {
    fn into_raw(self) -> *mut _cef_cookie_access_filter_t {
        ImplCookieAccessFilter::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_cookie_access_filter_t> for &mut CookieAccessFilter {
    fn into_raw(self) -> *mut _cef_cookie_access_filter_t {
        ImplCookieAccessFilter::get_raw(self)
    }
}
impl ConvertReturnValue<CookieAccessFilter> for *mut _cef_cookie_access_filter_t {
    fn wrap_result(self) -> CookieAccessFilter {
        CookieAccessFilter(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<CookieAccessFilter> for *mut _cef_cookie_access_filter_t {
    fn from(value: CookieAccessFilter) -> Self {
        let object = ImplCookieAccessFilter::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for CookieAccessFilter {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_sslinfo_t`] for more documentation.
#[derive(Clone)]
pub struct Sslinfo(RefGuard<_cef_sslinfo_t>);
pub trait ImplSslinfo: Clone + Sized + Rc {
    #[doc = "See [`_cef_sslinfo_t::get_cert_status`] for more documentation."]
    fn cert_status(&self) -> CertStatus;
    #[doc = "See [`_cef_sslinfo_t::get_x509_certificate`] for more documentation."]
    fn x509_certificate(&self) -> Option<X509Certificate>;
    fn get_raw(&self) -> *mut _cef_sslinfo_t;
}
impl ImplSslinfo for Sslinfo {
    fn cert_status(&self) -> CertStatus {
        unsafe {
            self.0
                .get_cert_status
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn x509_certificate(&self) -> Option<X509Certificate> {
        unsafe {
            self.0
                .get_x509_certificate
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_sslinfo_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_sslinfo_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Sslinfo {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_sslinfo_t> for &Sslinfo {
    fn into_raw(self) -> *mut _cef_sslinfo_t {
        ImplSslinfo::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_sslinfo_t> for &mut Sslinfo {
    fn into_raw(self) -> *mut _cef_sslinfo_t {
        ImplSslinfo::get_raw(self)
    }
}
impl ConvertReturnValue<Sslinfo> for *mut _cef_sslinfo_t {
    fn wrap_result(self) -> Sslinfo {
        Sslinfo(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Sslinfo> for *mut _cef_sslinfo_t {
    fn from(value: Sslinfo) -> Self {
        let object = ImplSslinfo::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Sslinfo {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_unresponsive_process_callback_t`] for more documentation.
#[derive(Clone)]
pub struct UnresponsiveProcessCallback(RefGuard<_cef_unresponsive_process_callback_t>);
pub trait ImplUnresponsiveProcessCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_unresponsive_process_callback_t::wait`] for more documentation."]
    fn wait(&self);
    #[doc = "See [`_cef_unresponsive_process_callback_t::terminate`] for more documentation."]
    fn terminate(&self);
    fn get_raw(&self) -> *mut _cef_unresponsive_process_callback_t;
}
impl ImplUnresponsiveProcessCallback for UnresponsiveProcessCallback {
    fn wait(&self) {
        unsafe {
            if let Some(f) = self.0.wait {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn terminate(&self) {
        unsafe {
            if let Some(f) = self.0.terminate {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_unresponsive_process_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_unresponsive_process_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for UnresponsiveProcessCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_unresponsive_process_callback_t> for &UnresponsiveProcessCallback {
    fn into_raw(self) -> *mut _cef_unresponsive_process_callback_t {
        ImplUnresponsiveProcessCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_unresponsive_process_callback_t> for &mut UnresponsiveProcessCallback {
    fn into_raw(self) -> *mut _cef_unresponsive_process_callback_t {
        ImplUnresponsiveProcessCallback::get_raw(self)
    }
}
impl ConvertReturnValue<UnresponsiveProcessCallback> for *mut _cef_unresponsive_process_callback_t {
    fn wrap_result(self) -> UnresponsiveProcessCallback {
        UnresponsiveProcessCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<UnresponsiveProcessCallback> for *mut _cef_unresponsive_process_callback_t {
    fn from(value: UnresponsiveProcessCallback) -> Self {
        let object = ImplUnresponsiveProcessCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for UnresponsiveProcessCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_select_client_certificate_callback_t`] for more documentation.
#[derive(Clone)]
pub struct SelectClientCertificateCallback(RefGuard<_cef_select_client_certificate_callback_t>);
pub trait ImplSelectClientCertificateCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_select_client_certificate_callback_t::select`] for more documentation."]
    fn select(&self, cert: Option<&mut X509Certificate>);
    fn get_raw(&self) -> *mut _cef_select_client_certificate_callback_t;
}
impl ImplSelectClientCertificateCallback for SelectClientCertificateCallback {
    fn select(&self, cert: Option<&mut X509Certificate>) {
        unsafe {
            if let Some(f) = self.0.select {
                let arg_cert = cert;
                let arg_self_ = self.into_raw();
                let arg_cert = arg_cert
                    .map(|arg| {
                        arg.add_ref();
                        ImplX509Certificate::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_cert);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_select_client_certificate_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_select_client_certificate_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SelectClientCertificateCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_select_client_certificate_callback_t>
    for &SelectClientCertificateCallback
{
    fn into_raw(self) -> *mut _cef_select_client_certificate_callback_t {
        ImplSelectClientCertificateCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_select_client_certificate_callback_t>
    for &mut SelectClientCertificateCallback
{
    fn into_raw(self) -> *mut _cef_select_client_certificate_callback_t {
        ImplSelectClientCertificateCallback::get_raw(self)
    }
}
impl ConvertReturnValue<SelectClientCertificateCallback>
    for *mut _cef_select_client_certificate_callback_t
{
    fn wrap_result(self) -> SelectClientCertificateCallback {
        SelectClientCertificateCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<SelectClientCertificateCallback> for *mut _cef_select_client_certificate_callback_t {
    fn from(value: SelectClientCertificateCallback) -> Self {
        let object = ImplSelectClientCertificateCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for SelectClientCertificateCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_request_handler_t`] for more documentation.
#[derive(Clone)]
pub struct RequestHandler(RefGuard<_cef_request_handler_t>);
impl RequestHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRequestHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRequestHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRequestHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_request_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapRequestHandler: ImplRequestHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_request_handler_t, Self>);
}
pub trait ImplRequestHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_request_handler_t::on_before_browse`] for more documentation."]
    fn on_before_browse(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_request_handler_t::on_open_urlfrom_tab`] for more documentation."]
    fn on_open_urlfrom_tab(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        target_url: Option<&CefString>,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_request_handler_t::get_resource_request_handler`] for more documentation."]
    fn resource_request_handler(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: Option<&CefString>,
        disable_default_handling: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<ResourceRequestHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_request_handler_t::get_auth_credentials`] for more documentation."]
    fn auth_credentials(
        &self,
        browser: Option<&mut Browser>,
        origin_url: Option<&CefString>,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefString>,
        port: ::std::os::raw::c_int,
        realm: Option<&CefString>,
        scheme: Option<&CefString>,
        callback: Option<&mut AuthCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_request_handler_t::on_certificate_error`] for more documentation."]
    fn on_certificate_error(
        &self,
        browser: Option<&mut Browser>,
        cert_error: Errorcode,
        request_url: Option<&CefString>,
        ssl_info: Option<&mut Sslinfo>,
        callback: Option<&mut Callback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_request_handler_t::on_select_client_certificate`] for more documentation."]
    fn on_select_client_certificate(
        &self,
        browser: Option<&mut Browser>,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefString>,
        port: ::std::os::raw::c_int,
        certificates: Option<&[Option<X509Certificate>]>,
        callback: Option<&mut SelectClientCertificateCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_request_handler_t::on_render_view_ready`] for more documentation."]
    fn on_render_view_ready(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_request_handler_t::on_render_process_unresponsive`] for more documentation."]
    fn on_render_process_unresponsive(
        &self,
        browser: Option<&mut Browser>,
        callback: Option<&mut UnresponsiveProcessCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_request_handler_t::on_render_process_responsive`] for more documentation."]
    fn on_render_process_responsive(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_request_handler_t::on_render_process_terminated`] for more documentation."]
    fn on_render_process_terminated(
        &self,
        browser: Option<&mut Browser>,
        status: TerminationStatus,
        error_code: ::std::os::raw::c_int,
        error_string: Option<&CefString>,
    ) {
    }
    #[doc = "See [`_cef_request_handler_t::on_document_available_in_main_frame`] for more documentation."]
    fn on_document_available_in_main_frame(&self, browser: Option<&mut Browser>) {}
    fn init_methods(object: &mut _cef_request_handler_t) {
        impl_cef_request_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_request_handler_t;
}
mod impl_cef_request_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRequestHandler>(object: &mut _cef_request_handler_t) {
        object.on_before_browse = Some(on_before_browse::<I>);
        object.on_open_urlfrom_tab = Some(on_open_urlfrom_tab::<I>);
        object.get_resource_request_handler = Some(get_resource_request_handler::<I>);
        object.get_auth_credentials = Some(get_auth_credentials::<I>);
        object.on_certificate_error = Some(on_certificate_error::<I>);
        object.on_select_client_certificate = Some(on_select_client_certificate::<I>);
        object.on_render_view_ready = Some(on_render_view_ready::<I>);
        object.on_render_process_unresponsive = Some(on_render_process_unresponsive::<I>);
        object.on_render_process_responsive = Some(on_render_process_responsive::<I>);
        object.on_render_process_terminated = Some(on_render_process_terminated::<I>);
        object.on_document_available_in_main_frame = Some(on_document_available_in_main_frame::<I>);
    }
    extern "C" fn on_before_browse<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_request, arg_user_gesture, arg_is_redirect) =
            (self_, browser, frame, request, user_gesture, is_redirect);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_user_gesture = arg_user_gesture.into_raw();
        let arg_is_redirect = arg_is_redirect.into_raw();
        ImplRequestHandler::on_before_browse(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_user_gesture,
            arg_is_redirect,
        )
    }
    extern "C" fn on_open_urlfrom_tab<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        target_url: *const cef_string_t,
        target_disposition: cef_window_open_disposition_t,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_target_url,
            arg_target_disposition,
            arg_user_gesture,
        ) = (
            self_,
            browser,
            frame,
            target_url,
            target_disposition,
            user_gesture,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_target_url = if arg_target_url.is_null() {
            None
        } else {
            Some(arg_target_url.into())
        };
        let arg_target_url = arg_target_url.as_ref();
        let arg_target_disposition = arg_target_disposition.into_raw();
        let arg_user_gesture = arg_user_gesture.into_raw();
        ImplRequestHandler::on_open_urlfrom_tab(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_target_url,
            arg_target_disposition,
            arg_user_gesture,
        )
    }
    extern "C" fn get_resource_request_handler<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: *const cef_string_t,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_resource_request_handler_t {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        ) = (
            self_,
            browser,
            frame,
            request,
            is_navigation,
            is_download,
            request_initiator,
            disable_default_handling,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_is_navigation = arg_is_navigation.into_raw();
        let arg_is_download = arg_is_download.into_raw();
        let arg_request_initiator = if arg_request_initiator.is_null() {
            None
        } else {
            Some(arg_request_initiator.into())
        };
        let arg_request_initiator = arg_request_initiator.as_ref();
        let mut arg_disable_default_handling = if arg_disable_default_handling.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_disable_default_handling,
            ))
        };
        let arg_disable_default_handling = arg_disable_default_handling
            .as_mut()
            .map(|arg| arg.as_mut());
        let result = ImplRequestHandler::resource_request_handler(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_auth_credentials<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        origin_url: *const cef_string_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const cef_string_t,
        port: ::std::os::raw::c_int,
        realm: *const cef_string_t,
        scheme: *const cef_string_t,
        callback: *mut _cef_auth_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_origin_url,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_realm,
            arg_scheme,
            arg_callback,
        ) = (
            self_, browser, origin_url, is_proxy, host, port, realm, scheme, callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_origin_url = if arg_origin_url.is_null() {
            None
        } else {
            Some(arg_origin_url.into())
        };
        let arg_origin_url = arg_origin_url.as_ref();
        let arg_is_proxy = arg_is_proxy.into_raw();
        let arg_host = if arg_host.is_null() {
            None
        } else {
            Some(arg_host.into())
        };
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.into_raw();
        let arg_realm = if arg_realm.is_null() {
            None
        } else {
            Some(arg_realm.into())
        };
        let arg_realm = arg_realm.as_ref();
        let arg_scheme = if arg_scheme.is_null() {
            None
        } else {
            Some(arg_scheme.into())
        };
        let arg_scheme = arg_scheme.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| AuthCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplRequestHandler::auth_credentials(
            &arg_self_.interface,
            arg_browser,
            arg_origin_url,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_realm,
            arg_scheme,
            arg_callback,
        )
    }
    extern "C" fn on_certificate_error<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        cert_error: cef_errorcode_t,
        request_url: *const cef_string_t,
        ssl_info: *mut _cef_sslinfo_t,
        callback: *mut _cef_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_cert_error, arg_request_url, arg_ssl_info, arg_callback) =
            (self_, browser, cert_error, request_url, ssl_info, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_cert_error = arg_cert_error.into_raw();
        let arg_request_url = if arg_request_url.is_null() {
            None
        } else {
            Some(arg_request_url.into())
        };
        let arg_request_url = arg_request_url.as_ref();
        let mut arg_ssl_info =
            unsafe { arg_ssl_info.as_mut() }.map(|arg| Sslinfo(unsafe { RefGuard::from_raw(arg) }));
        let arg_ssl_info = arg_ssl_info.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| Callback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplRequestHandler::on_certificate_error(
            &arg_self_.interface,
            arg_browser,
            arg_cert_error,
            arg_request_url,
            arg_ssl_info,
            arg_callback,
        )
    }
    extern "C" fn on_select_client_certificate<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const cef_string_t,
        port: ::std::os::raw::c_int,
        certificates_count: usize,
        certificates: *const *mut _cef_x509_certificate_t,
        callback: *mut _cef_select_client_certificate_callback_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_browser,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_certificates_count,
            arg_certificates,
            arg_callback,
        ) = (
            self_,
            browser,
            is_proxy,
            host,
            port,
            certificates_count,
            certificates,
            callback,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_is_proxy = arg_is_proxy.into_raw();
        let arg_host = if arg_host.is_null() {
            None
        } else {
            Some(arg_host.into())
        };
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.into_raw();
        let vec_certificates = unsafe { arg_certificates.as_ref() }.map(|arg| {
            let arg = unsafe {
                std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_certificates_count)
            };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(X509Certificate(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_certificates = vec_certificates.as_deref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| SelectClientCertificateCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplRequestHandler::on_select_client_certificate(
            &arg_self_.interface,
            arg_browser,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_certificates,
            arg_callback,
        )
    }
    extern "C" fn on_render_view_ready<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplRequestHandler::on_render_view_ready(&arg_self_.interface, arg_browser)
    }
    extern "C" fn on_render_process_unresponsive<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        callback: *mut _cef_unresponsive_process_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_callback) = (self_, browser, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| UnresponsiveProcessCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplRequestHandler::on_render_process_unresponsive(
            &arg_self_.interface,
            arg_browser,
            arg_callback,
        )
    }
    extern "C" fn on_render_process_responsive<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplRequestHandler::on_render_process_responsive(&arg_self_.interface, arg_browser)
    }
    extern "C" fn on_render_process_terminated<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
        status: cef_termination_status_t,
        error_code: ::std::os::raw::c_int,
        error_string: *const cef_string_t,
    ) {
        let (arg_self_, arg_browser, arg_status, arg_error_code, arg_error_string) =
            (self_, browser, status, error_code, error_string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let arg_status = arg_status.into_raw();
        let arg_error_code = arg_error_code.into_raw();
        let arg_error_string = if arg_error_string.is_null() {
            None
        } else {
            Some(arg_error_string.into())
        };
        let arg_error_string = arg_error_string.as_ref();
        ImplRequestHandler::on_render_process_terminated(
            &arg_self_.interface,
            arg_browser,
            arg_status,
            arg_error_code,
            arg_error_string,
        )
    }
    extern "C" fn on_document_available_in_main_frame<I: ImplRequestHandler>(
        self_: *mut _cef_request_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplRequestHandler::on_document_available_in_main_frame(&arg_self_.interface, arg_browser)
    }
}
impl ImplRequestHandler for RequestHandler {
    fn on_before_browse(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        user_gesture: ::std::os::raw::c_int,
        is_redirect: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_before_browse
                .map(|f| {
                    let (arg_browser, arg_frame, arg_request, arg_user_gesture, arg_is_redirect) =
                        (browser, frame, request, user_gesture, is_redirect);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_user_gesture,
                        arg_is_redirect,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_open_urlfrom_tab(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        target_url: Option<&CefString>,
        target_disposition: WindowOpenDisposition,
        user_gesture: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_open_urlfrom_tab
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_target_url,
                        arg_target_disposition,
                        arg_user_gesture,
                    ) = (browser, frame, target_url, target_disposition, user_gesture);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_target_url = arg_target_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_target_disposition = arg_target_disposition.into_raw();
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_target_url,
                        arg_target_disposition,
                        arg_user_gesture,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn resource_request_handler(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: Option<&CefString>,
        disable_default_handling: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<ResourceRequestHandler> {
        unsafe {
            self.0
                .get_resource_request_handler
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    ) = (
                        browser,
                        frame,
                        request,
                        is_navigation,
                        is_download,
                        request_initiator,
                        disable_default_handling,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request_initiator = arg_request_initiator
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_disable_default_handling = arg_disable_default_handling
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn auth_credentials(
        &self,
        browser: Option<&mut Browser>,
        origin_url: Option<&CefString>,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefString>,
        port: ::std::os::raw::c_int,
        realm: Option<&CefString>,
        scheme: Option<&CefString>,
        callback: Option<&mut AuthCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_auth_credentials
                .map(|f| {
                    let (
                        arg_browser,
                        arg_origin_url,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    ) = (
                        browser, origin_url, is_proxy, host, port, realm, scheme, callback,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_origin_url = arg_origin_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_host = arg_host
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_realm = arg_realm
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_scheme = arg_scheme
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplAuthCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_origin_url,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_certificate_error(
        &self,
        browser: Option<&mut Browser>,
        cert_error: Errorcode,
        request_url: Option<&CefString>,
        ssl_info: Option<&mut Sslinfo>,
        callback: Option<&mut Callback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_certificate_error
                .map(|f| {
                    let (arg_browser, arg_cert_error, arg_request_url, arg_ssl_info, arg_callback) =
                        (browser, cert_error, request_url, ssl_info, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_cert_error = arg_cert_error.into_raw();
                    let arg_request_url = arg_request_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_ssl_info = arg_ssl_info
                        .map(|arg| {
                            arg.add_ref();
                            ImplSslinfo::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_cert_error,
                        arg_request_url,
                        arg_ssl_info,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_select_client_certificate(
        &self,
        browser: Option<&mut Browser>,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefString>,
        port: ::std::os::raw::c_int,
        certificates: Option<&[Option<X509Certificate>]>,
        callback: Option<&mut SelectClientCertificateCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_select_client_certificate
                .map(|f| {
                    let (
                        arg_browser,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_certificates,
                        arg_callback,
                    ) = (browser, is_proxy, host, port, certificates, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_host = arg_host
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_certificates_count = arg_certificates
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let vec_certificates = arg_certificates
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_certificates = if vec_certificates.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_certificates.as_ptr()
                    };
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplSelectClientCertificateCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_certificates_count,
                        arg_certificates,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_render_view_ready(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_render_view_ready {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn on_render_process_unresponsive(
        &self,
        browser: Option<&mut Browser>,
        callback: Option<&mut UnresponsiveProcessCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_render_process_unresponsive
                .map(|f| {
                    let (arg_browser, arg_callback) = (browser, callback);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplUnresponsiveProcessCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser, arg_callback);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_render_process_responsive(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_render_process_responsive {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn on_render_process_terminated(
        &self,
        browser: Option<&mut Browser>,
        status: TerminationStatus,
        error_code: ::std::os::raw::c_int,
        error_string: Option<&CefString>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_render_process_terminated {
                let (arg_browser, arg_status, arg_error_code, arg_error_string) =
                    (browser, status, error_code, error_string);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_status = arg_status.into_raw();
                let arg_error_string = arg_error_string
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(
                    arg_self_,
                    arg_browser,
                    arg_status,
                    arg_error_code,
                    arg_error_string,
                );
            }
        }
    }
    fn on_document_available_in_main_frame(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_document_available_in_main_frame {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_request_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_request_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_handler_t> for &RequestHandler {
    fn into_raw(self) -> *mut _cef_request_handler_t {
        ImplRequestHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_request_handler_t> for &mut RequestHandler {
    fn into_raw(self) -> *mut _cef_request_handler_t {
        ImplRequestHandler::get_raw(self)
    }
}
impl ConvertReturnValue<RequestHandler> for *mut _cef_request_handler_t {
    fn wrap_result(self) -> RequestHandler {
        RequestHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<RequestHandler> for *mut _cef_request_handler_t {
    fn from(value: RequestHandler) -> Self {
        let object = ImplRequestHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for RequestHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_client_t`] for more documentation.
#[derive(Clone)]
pub struct Client(RefGuard<_cef_client_t>);
impl Client {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapClient,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplClient>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapClient>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_client_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapClient: ImplClient {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_client_t, Self>);
}
pub trait ImplClient: Clone + Sized + Rc {
    #[doc = "See [`_cef_client_t::get_audio_handler`] for more documentation."]
    fn audio_handler(&self) -> Option<AudioHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_command_handler`] for more documentation."]
    fn command_handler(&self) -> Option<CommandHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_context_menu_handler`] for more documentation."]
    fn context_menu_handler(&self) -> Option<ContextMenuHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_dialog_handler`] for more documentation."]
    fn dialog_handler(&self) -> Option<DialogHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_display_handler`] for more documentation."]
    fn display_handler(&self) -> Option<DisplayHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_download_handler`] for more documentation."]
    fn download_handler(&self) -> Option<DownloadHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_drag_handler`] for more documentation."]
    fn drag_handler(&self) -> Option<DragHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_find_handler`] for more documentation."]
    fn find_handler(&self) -> Option<FindHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_focus_handler`] for more documentation."]
    fn focus_handler(&self) -> Option<FocusHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_frame_handler`] for more documentation."]
    fn frame_handler(&self) -> Option<FrameHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_permission_handler`] for more documentation."]
    fn permission_handler(&self) -> Option<PermissionHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_jsdialog_handler`] for more documentation."]
    fn jsdialog_handler(&self) -> Option<JsdialogHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_keyboard_handler`] for more documentation."]
    fn keyboard_handler(&self) -> Option<KeyboardHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_life_span_handler`] for more documentation."]
    fn life_span_handler(&self) -> Option<LifeSpanHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_load_handler`] for more documentation."]
    fn load_handler(&self) -> Option<LoadHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_print_handler`] for more documentation."]
    fn print_handler(&self) -> Option<PrintHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_render_handler`] for more documentation."]
    fn render_handler(&self) -> Option<RenderHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::get_request_handler`] for more documentation."]
    fn request_handler(&self) -> Option<RequestHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_client_t::on_process_message_received`] for more documentation."]
    fn on_process_message_received(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        source_process: ProcessId,
        message: Option<&mut ProcessMessage>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_client_t) {
        impl_cef_client_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_client_t;
}
mod impl_cef_client_t {
    use super::*;
    pub fn init_methods<I: ImplClient>(object: &mut _cef_client_t) {
        object.get_audio_handler = Some(get_audio_handler::<I>);
        object.get_command_handler = Some(get_command_handler::<I>);
        object.get_context_menu_handler = Some(get_context_menu_handler::<I>);
        object.get_dialog_handler = Some(get_dialog_handler::<I>);
        object.get_display_handler = Some(get_display_handler::<I>);
        object.get_download_handler = Some(get_download_handler::<I>);
        object.get_drag_handler = Some(get_drag_handler::<I>);
        object.get_find_handler = Some(get_find_handler::<I>);
        object.get_focus_handler = Some(get_focus_handler::<I>);
        object.get_frame_handler = Some(get_frame_handler::<I>);
        object.get_permission_handler = Some(get_permission_handler::<I>);
        object.get_jsdialog_handler = Some(get_jsdialog_handler::<I>);
        object.get_keyboard_handler = Some(get_keyboard_handler::<I>);
        object.get_life_span_handler = Some(get_life_span_handler::<I>);
        object.get_load_handler = Some(get_load_handler::<I>);
        object.get_print_handler = Some(get_print_handler::<I>);
        object.get_render_handler = Some(get_render_handler::<I>);
        object.get_request_handler = Some(get_request_handler::<I>);
        object.on_process_message_received = Some(on_process_message_received::<I>);
    }
    extern "C" fn get_audio_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_audio_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::audio_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_command_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_command_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::command_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_context_menu_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_context_menu_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::context_menu_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_dialog_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_dialog_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::dialog_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_display_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_display_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::display_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_download_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_download_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::download_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_drag_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_drag_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::drag_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_find_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_find_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::find_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_focus_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_focus_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::focus_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_frame_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_frame_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::frame_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_permission_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_permission_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::permission_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_jsdialog_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_jsdialog_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::jsdialog_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_keyboard_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_keyboard_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::keyboard_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_life_span_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_life_span_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::life_span_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_load_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_load_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::load_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_print_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_print_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::print_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_render_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_render_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::render_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_request_handler<I: ImplClient>(
        self_: *mut _cef_client_t,
    ) -> *mut _cef_request_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplClient::request_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_process_message_received<I: ImplClient>(
        self_: *mut _cef_client_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        source_process: cef_process_id_t,
        message: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_source_process, arg_message) =
            (self_, browser, frame, source_process, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_source_process = arg_source_process.into_raw();
        let mut arg_message = unsafe { arg_message.as_mut() }
            .map(|arg| ProcessMessage(unsafe { RefGuard::from_raw(arg) }));
        let arg_message = arg_message.as_mut();
        ImplClient::on_process_message_received(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_source_process,
            arg_message,
        )
    }
}
impl ImplClient for Client {
    fn audio_handler(&self) -> Option<AudioHandler> {
        unsafe {
            self.0
                .get_audio_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn command_handler(&self) -> Option<CommandHandler> {
        unsafe {
            self.0
                .get_command_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn context_menu_handler(&self) -> Option<ContextMenuHandler> {
        unsafe {
            self.0
                .get_context_menu_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn dialog_handler(&self) -> Option<DialogHandler> {
        unsafe {
            self.0
                .get_dialog_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn display_handler(&self) -> Option<DisplayHandler> {
        unsafe {
            self.0
                .get_display_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn download_handler(&self) -> Option<DownloadHandler> {
        unsafe {
            self.0
                .get_download_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn drag_handler(&self) -> Option<DragHandler> {
        unsafe {
            self.0
                .get_drag_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn find_handler(&self) -> Option<FindHandler> {
        unsafe {
            self.0
                .get_find_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn focus_handler(&self) -> Option<FocusHandler> {
        unsafe {
            self.0
                .get_focus_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn frame_handler(&self) -> Option<FrameHandler> {
        unsafe {
            self.0
                .get_frame_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn permission_handler(&self) -> Option<PermissionHandler> {
        unsafe {
            self.0
                .get_permission_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn jsdialog_handler(&self) -> Option<JsdialogHandler> {
        unsafe {
            self.0
                .get_jsdialog_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn keyboard_handler(&self) -> Option<KeyboardHandler> {
        unsafe {
            self.0
                .get_keyboard_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn life_span_handler(&self) -> Option<LifeSpanHandler> {
        unsafe {
            self.0
                .get_life_span_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn load_handler(&self) -> Option<LoadHandler> {
        unsafe {
            self.0
                .get_load_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn print_handler(&self) -> Option<PrintHandler> {
        unsafe {
            self.0
                .get_print_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn render_handler(&self) -> Option<RenderHandler> {
        unsafe {
            self.0
                .get_render_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn request_handler(&self) -> Option<RequestHandler> {
        unsafe {
            self.0
                .get_request_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_process_message_received(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        source_process: ProcessId,
        message: Option<&mut ProcessMessage>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_process_message_received
                .map(|f| {
                    let (arg_browser, arg_frame, arg_source_process, arg_message) =
                        (browser, frame, source_process, message);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_source_process = arg_source_process.into_raw();
                    let arg_message = arg_message
                        .map(|arg| {
                            arg.add_ref();
                            ImplProcessMessage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_source_process,
                        arg_message,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_client_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_client_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Client {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_client_t> for &Client {
    fn into_raw(self) -> *mut _cef_client_t {
        ImplClient::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_client_t> for &mut Client {
    fn into_raw(self) -> *mut _cef_client_t {
        ImplClient::get_raw(self)
    }
}
impl ConvertReturnValue<Client> for *mut _cef_client_t {
    fn wrap_result(self) -> Client {
        Client(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Client> for *mut _cef_client_t {
    fn from(value: Client) -> Self {
        let object = ImplClient::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Client {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_command_line_t`] for more documentation.
#[derive(Clone)]
pub struct CommandLine(RefGuard<_cef_command_line_t>);
pub trait ImplCommandLine: Clone + Sized + Rc {
    #[doc = "See [`_cef_command_line_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_command_line_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_command_line_t::copy`] for more documentation."]
    fn copy(&self) -> Option<CommandLine>;
    #[doc = "See [`_cef_command_line_t::init_from_argv`] for more documentation."]
    fn init_from_argv(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    );
    #[doc = "See [`_cef_command_line_t::init_from_string`] for more documentation."]
    fn init_from_string(&self, command_line: Option<&CefString>);
    #[doc = "See [`_cef_command_line_t::reset`] for more documentation."]
    fn reset(&self);
    #[doc = "See [`_cef_command_line_t::get_argv`] for more documentation."]
    fn argv(&self, argv: Option<&mut CefStringList>);
    #[doc = "See [`_cef_command_line_t::get_command_line_string`] for more documentation."]
    fn command_line_string(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_command_line_t::get_program`] for more documentation."]
    fn program(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_command_line_t::set_program`] for more documentation."]
    fn set_program(&self, program: Option<&CefString>);
    #[doc = "See [`_cef_command_line_t::has_switches`] for more documentation."]
    fn has_switches(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_command_line_t::has_switch`] for more documentation."]
    fn has_switch(&self, name: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_command_line_t::get_switch_value`] for more documentation."]
    fn switch_value(&self, name: Option<&CefString>) -> CefStringUserfree;
    #[doc = "See [`_cef_command_line_t::get_switches`] for more documentation."]
    fn switches(&self, switches: Option<&mut CefStringMap>);
    #[doc = "See [`_cef_command_line_t::append_switch`] for more documentation."]
    fn append_switch(&self, name: Option<&CefString>);
    #[doc = "See [`_cef_command_line_t::append_switch_with_value`] for more documentation."]
    fn append_switch_with_value(&self, name: Option<&CefString>, value: Option<&CefString>);
    #[doc = "See [`_cef_command_line_t::has_arguments`] for more documentation."]
    fn has_arguments(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_command_line_t::get_arguments`] for more documentation."]
    fn arguments(&self, arguments: Option<&mut CefStringList>);
    #[doc = "See [`_cef_command_line_t::append_argument`] for more documentation."]
    fn append_argument(&self, argument: Option<&CefString>);
    #[doc = "See [`_cef_command_line_t::prepend_wrapper`] for more documentation."]
    fn prepend_wrapper(&self, wrapper: Option<&CefString>);
    fn get_raw(&self) -> *mut _cef_command_line_t;
}
impl ImplCommandLine for CommandLine {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn copy(&self) -> Option<CommandLine> {
        unsafe {
            self.0
                .copy
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn init_from_argv(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
    ) {
        unsafe {
            if let Some(f) = self.0.init_from_argv {
                let (arg_argc, arg_argv) = (argc, argv);
                let arg_self_ = self.into_raw();
                let arg_argv = arg_argv.cast();
                f(arg_self_, arg_argc, arg_argv);
            }
        }
    }
    fn init_from_string(&self, command_line: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.init_from_string {
                let arg_command_line = command_line;
                let arg_self_ = self.into_raw();
                let arg_command_line = arg_command_line
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_command_line);
            }
        }
    }
    fn reset(&self) {
        unsafe {
            if let Some(f) = self.0.reset {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn argv(&self, argv: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.get_argv {
                let arg_argv = argv;
                let arg_self_ = self.into_raw();
                let arg_argv = arg_argv
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_argv);
            }
        }
    }
    fn command_line_string(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_command_line_string
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn program(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_program
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_program(&self, program: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_program {
                let arg_program = program;
                let arg_self_ = self.into_raw();
                let arg_program = arg_program
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_program);
            }
        }
    }
    fn has_switches(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_switches
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_switch(&self, name: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_switch
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn switch_value(&self, name: Option<&CefString>) -> CefStringUserfree {
        unsafe {
            self.0
                .get_switch_value
                .map(|f| {
                    let arg_name = name;
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_name);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn switches(&self, switches: Option<&mut CefStringMap>) {
        unsafe {
            if let Some(f) = self.0.get_switches {
                let arg_switches = switches;
                let arg_self_ = self.into_raw();
                let arg_switches = arg_switches
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_switches);
            }
        }
    }
    fn append_switch(&self, name: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.append_switch {
                let arg_name = name;
                let arg_self_ = self.into_raw();
                let arg_name = arg_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_name);
            }
        }
    }
    fn append_switch_with_value(&self, name: Option<&CefString>, value: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.append_switch_with_value {
                let (arg_name, arg_value) = (name, value);
                let arg_self_ = self.into_raw();
                let arg_name = arg_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_value = arg_value
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_name, arg_value);
            }
        }
    }
    fn has_arguments(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_arguments
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn arguments(&self, arguments: Option<&mut CefStringList>) {
        unsafe {
            if let Some(f) = self.0.get_arguments {
                let arg_arguments = arguments;
                let arg_self_ = self.into_raw();
                let arg_arguments = arg_arguments
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_arguments);
            }
        }
    }
    fn append_argument(&self, argument: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.append_argument {
                let arg_argument = argument;
                let arg_self_ = self.into_raw();
                let arg_argument = arg_argument
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_argument);
            }
        }
    }
    fn prepend_wrapper(&self, wrapper: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.prepend_wrapper {
                let arg_wrapper = wrapper;
                let arg_self_ = self.into_raw();
                let arg_wrapper = arg_wrapper
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_wrapper);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_command_line_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_command_line_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for CommandLine {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_command_line_t> for &CommandLine {
    fn into_raw(self) -> *mut _cef_command_line_t {
        ImplCommandLine::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_command_line_t> for &mut CommandLine {
    fn into_raw(self) -> *mut _cef_command_line_t {
        ImplCommandLine::get_raw(self)
    }
}
impl ConvertReturnValue<CommandLine> for *mut _cef_command_line_t {
    fn wrap_result(self) -> CommandLine {
        CommandLine(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<CommandLine> for *mut _cef_command_line_t {
    fn from(value: CommandLine) -> Self {
        let object = ImplCommandLine::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for CommandLine {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_request_context_handler_t`] for more documentation.
#[derive(Clone)]
pub struct RequestContextHandler(RefGuard<_cef_request_context_handler_t>);
impl RequestContextHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRequestContextHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRequestContextHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRequestContextHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_request_context_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapRequestContextHandler: ImplRequestContextHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_request_context_handler_t, Self>);
}
pub trait ImplRequestContextHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_request_context_handler_t::on_request_context_initialized`] for more documentation."]
    fn on_request_context_initialized(&self, request_context: Option<&mut RequestContext>) {}
    #[doc = "See [`_cef_request_context_handler_t::get_resource_request_handler`] for more documentation."]
    fn resource_request_handler(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: Option<&CefString>,
        disable_default_handling: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<ResourceRequestHandler> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_request_context_handler_t) {
        impl_cef_request_context_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_request_context_handler_t;
}
mod impl_cef_request_context_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRequestContextHandler>(object: &mut _cef_request_context_handler_t) {
        object.on_request_context_initialized = Some(on_request_context_initialized::<I>);
        object.get_resource_request_handler = Some(get_resource_request_handler::<I>);
    }
    extern "C" fn on_request_context_initialized<I: ImplRequestContextHandler>(
        self_: *mut _cef_request_context_handler_t,
        request_context: *mut _cef_request_context_t,
    ) {
        let (arg_self_, arg_request_context) = (self_, request_context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request_context = unsafe { arg_request_context.as_mut() }
            .map(|arg| RequestContext(unsafe { RefGuard::from_raw(arg) }));
        let arg_request_context = arg_request_context.as_mut();
        ImplRequestContextHandler::on_request_context_initialized(
            &arg_self_.interface,
            arg_request_context,
        )
    }
    extern "C" fn get_resource_request_handler<I: ImplRequestContextHandler>(
        self_: *mut _cef_request_context_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        request: *mut _cef_request_t,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: *const cef_string_t,
        disable_default_handling: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_resource_request_handler_t {
        let (
            arg_self_,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        ) = (
            self_,
            browser,
            frame,
            request,
            is_navigation,
            is_download,
            request_initiator,
            disable_default_handling,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_is_navigation = arg_is_navigation.into_raw();
        let arg_is_download = arg_is_download.into_raw();
        let arg_request_initiator = if arg_request_initiator.is_null() {
            None
        } else {
            Some(arg_request_initiator.into())
        };
        let arg_request_initiator = arg_request_initiator.as_ref();
        let mut arg_disable_default_handling = if arg_disable_default_handling.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_disable_default_handling,
            ))
        };
        let arg_disable_default_handling = arg_disable_default_handling
            .as_mut()
            .map(|arg| arg.as_mut());
        let result = ImplRequestContextHandler::resource_request_handler(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_request,
            arg_is_navigation,
            arg_is_download,
            arg_request_initiator,
            arg_disable_default_handling,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplRequestContextHandler for RequestContextHandler {
    fn on_request_context_initialized(&self, request_context: Option<&mut RequestContext>) {
        unsafe {
            if let Some(f) = self.0.on_request_context_initialized {
                let arg_request_context = request_context;
                let arg_self_ = self.into_raw();
                let arg_request_context = arg_request_context
                    .map(|arg| {
                        arg.add_ref();
                        ImplRequestContext::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_request_context);
            }
        }
    }
    fn resource_request_handler(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        request: Option<&mut Request>,
        is_navigation: ::std::os::raw::c_int,
        is_download: ::std::os::raw::c_int,
        request_initiator: Option<&CefString>,
        disable_default_handling: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<ResourceRequestHandler> {
        unsafe {
            self.0
                .get_resource_request_handler
                .map(|f| {
                    let (
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    ) = (
                        browser,
                        frame,
                        request,
                        is_navigation,
                        is_download,
                        request_initiator,
                        disable_default_handling,
                    );
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_request_initiator = arg_request_initiator
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_disable_default_handling = arg_disable_default_handling
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_request,
                        arg_is_navigation,
                        arg_is_download,
                        arg_request_initiator,
                        arg_disable_default_handling,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_request_context_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_request_context_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RequestContextHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_request_context_handler_t> for &RequestContextHandler {
    fn into_raw(self) -> *mut _cef_request_context_handler_t {
        ImplRequestContextHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_request_context_handler_t> for &mut RequestContextHandler {
    fn into_raw(self) -> *mut _cef_request_context_handler_t {
        ImplRequestContextHandler::get_raw(self)
    }
}
impl ConvertReturnValue<RequestContextHandler> for *mut _cef_request_context_handler_t {
    fn wrap_result(self) -> RequestContextHandler {
        RequestContextHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<RequestContextHandler> for *mut _cef_request_context_handler_t {
    fn from(value: RequestContextHandler) -> Self {
        let object = ImplRequestContextHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for RequestContextHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_browser_process_handler_t`] for more documentation.
#[derive(Clone)]
pub struct BrowserProcessHandler(RefGuard<_cef_browser_process_handler_t>);
impl BrowserProcessHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBrowserProcessHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBrowserProcessHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBrowserProcessHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_browser_process_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapBrowserProcessHandler: ImplBrowserProcessHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_browser_process_handler_t, Self>);
}
pub trait ImplBrowserProcessHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_browser_process_handler_t::on_register_custom_preferences`] for more documentation."]
    fn on_register_custom_preferences(
        &self,
        type_: PreferencesType,
        registrar: Option<&mut PreferenceRegistrar>,
    ) {
    }
    #[doc = "See [`_cef_browser_process_handler_t::on_context_initialized`] for more documentation."]
    fn on_context_initialized(&self) {}
    #[doc = "See [`_cef_browser_process_handler_t::on_before_child_process_launch`] for more documentation."]
    fn on_before_child_process_launch(&self, command_line: Option<&mut CommandLine>) {}
    #[doc = "See [`_cef_browser_process_handler_t::on_already_running_app_relaunch`] for more documentation."]
    fn on_already_running_app_relaunch(
        &self,
        command_line: Option<&mut CommandLine>,
        current_directory: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_browser_process_handler_t::on_schedule_message_pump_work`] for more documentation."]
    fn on_schedule_message_pump_work(&self, delay_ms: i64) {}
    #[doc = "See [`_cef_browser_process_handler_t::get_default_client`] for more documentation."]
    fn default_client(&self) -> Option<Client> {
        Default::default()
    }
    #[doc = "See [`_cef_browser_process_handler_t::get_default_request_context_handler`] for more documentation."]
    fn default_request_context_handler(&self) -> Option<RequestContextHandler> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_browser_process_handler_t) {
        impl_cef_browser_process_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_browser_process_handler_t;
}
mod impl_cef_browser_process_handler_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserProcessHandler>(object: &mut _cef_browser_process_handler_t) {
        object.on_register_custom_preferences = Some(on_register_custom_preferences::<I>);
        object.on_context_initialized = Some(on_context_initialized::<I>);
        object.on_before_child_process_launch = Some(on_before_child_process_launch::<I>);
        object.on_already_running_app_relaunch = Some(on_already_running_app_relaunch::<I>);
        object.on_schedule_message_pump_work = Some(on_schedule_message_pump_work::<I>);
        object.get_default_client = Some(get_default_client::<I>);
        object.get_default_request_context_handler = Some(get_default_request_context_handler::<I>);
    }
    extern "C" fn on_register_custom_preferences<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        type_: cef_preferences_type_t,
        registrar: *mut _cef_preference_registrar_t,
    ) {
        let (arg_self_, arg_type_, arg_registrar) = (self_, type_, registrar);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_type_ = arg_type_.into_raw();
        let mut arg_registrar = if arg_registrar.is_null() {
            None
        } else {
            Some(PreferenceRegistrar(arg_registrar))
        };
        let arg_registrar = arg_registrar.as_mut();
        ImplBrowserProcessHandler::on_register_custom_preferences(
            &arg_self_.interface,
            arg_type_,
            arg_registrar,
        )
    }
    extern "C" fn on_context_initialized<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplBrowserProcessHandler::on_context_initialized(&arg_self_.interface)
    }
    extern "C" fn on_before_child_process_launch<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        command_line: *mut _cef_command_line_t,
    ) {
        let (arg_self_, arg_command_line) = (self_, command_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_command_line = unsafe { arg_command_line.as_mut() }
            .map(|arg| CommandLine(unsafe { RefGuard::from_raw(arg) }));
        let arg_command_line = arg_command_line.as_mut();
        ImplBrowserProcessHandler::on_before_child_process_launch(
            &arg_self_.interface,
            arg_command_line,
        )
    }
    extern "C" fn on_already_running_app_relaunch<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        command_line: *mut _cef_command_line_t,
        current_directory: *const cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_command_line, arg_current_directory) =
            (self_, command_line, current_directory);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_command_line = unsafe { arg_command_line.as_mut() }
            .map(|arg| CommandLine(unsafe { RefGuard::from_raw(arg) }));
        let arg_command_line = arg_command_line.as_mut();
        let arg_current_directory = if arg_current_directory.is_null() {
            None
        } else {
            Some(arg_current_directory.into())
        };
        let arg_current_directory = arg_current_directory.as_ref();
        ImplBrowserProcessHandler::on_already_running_app_relaunch(
            &arg_self_.interface,
            arg_command_line,
            arg_current_directory,
        )
    }
    extern "C" fn on_schedule_message_pump_work<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
        delay_ms: i64,
    ) {
        let (arg_self_, arg_delay_ms) = (self_, delay_ms);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_delay_ms = arg_delay_ms.into_raw();
        ImplBrowserProcessHandler::on_schedule_message_pump_work(&arg_self_.interface, arg_delay_ms)
    }
    extern "C" fn get_default_client<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) -> *mut _cef_client_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserProcessHandler::default_client(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_default_request_context_handler<I: ImplBrowserProcessHandler>(
        self_: *mut _cef_browser_process_handler_t,
    ) -> *mut _cef_request_context_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result =
            ImplBrowserProcessHandler::default_request_context_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplBrowserProcessHandler for BrowserProcessHandler {
    fn on_register_custom_preferences(
        &self,
        type_: PreferencesType,
        registrar: Option<&mut PreferenceRegistrar>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_register_custom_preferences {
                let (arg_type_, arg_registrar) = (type_, registrar);
                let arg_self_ = self.into_raw();
                let arg_type_ = arg_type_.into_raw();
                let arg_registrar = arg_registrar
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_type_, arg_registrar);
            }
        }
    }
    fn on_context_initialized(&self) {
        unsafe {
            if let Some(f) = self.0.on_context_initialized {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn on_before_child_process_launch(&self, command_line: Option<&mut CommandLine>) {
        unsafe {
            if let Some(f) = self.0.on_before_child_process_launch {
                let arg_command_line = command_line;
                let arg_self_ = self.into_raw();
                let arg_command_line = arg_command_line
                    .map(|arg| {
                        arg.add_ref();
                        ImplCommandLine::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_command_line);
            }
        }
    }
    fn on_already_running_app_relaunch(
        &self,
        command_line: Option<&mut CommandLine>,
        current_directory: Option<&CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_already_running_app_relaunch
                .map(|f| {
                    let (arg_command_line, arg_current_directory) =
                        (command_line, current_directory);
                    let arg_self_ = self.into_raw();
                    let arg_command_line = arg_command_line
                        .map(|arg| {
                            arg.add_ref();
                            ImplCommandLine::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_current_directory = arg_current_directory
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_command_line, arg_current_directory);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_schedule_message_pump_work(&self, delay_ms: i64) {
        unsafe {
            if let Some(f) = self.0.on_schedule_message_pump_work {
                let arg_delay_ms = delay_ms;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_delay_ms);
            }
        }
    }
    fn default_client(&self) -> Option<Client> {
        unsafe {
            self.0
                .get_default_client
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn default_request_context_handler(&self) -> Option<RequestContextHandler> {
        unsafe {
            self.0
                .get_default_request_context_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_process_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_browser_process_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserProcessHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_process_handler_t> for &BrowserProcessHandler {
    fn into_raw(self) -> *mut _cef_browser_process_handler_t {
        ImplBrowserProcessHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_process_handler_t> for &mut BrowserProcessHandler {
    fn into_raw(self) -> *mut _cef_browser_process_handler_t {
        ImplBrowserProcessHandler::get_raw(self)
    }
}
impl ConvertReturnValue<BrowserProcessHandler> for *mut _cef_browser_process_handler_t {
    fn wrap_result(self) -> BrowserProcessHandler {
        BrowserProcessHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<BrowserProcessHandler> for *mut _cef_browser_process_handler_t {
    fn from(value: BrowserProcessHandler) -> Self {
        let object = ImplBrowserProcessHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for BrowserProcessHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_task_t`] for more documentation.
#[derive(Clone)]
pub struct Task(RefGuard<_cef_task_t>);
impl Task {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapTask,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplTask>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapTask>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_task_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapTask: ImplTask {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_task_t, Self>);
}
pub trait ImplTask: Clone + Sized + Rc {
    #[doc = "See [`_cef_task_t::execute`] for more documentation."]
    fn execute(&self) {}
    fn init_methods(object: &mut _cef_task_t) {
        impl_cef_task_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_task_t;
}
mod impl_cef_task_t {
    use super::*;
    pub fn init_methods<I: ImplTask>(object: &mut _cef_task_t) {
        object.execute = Some(execute::<I>);
    }
    extern "C" fn execute<I: ImplTask>(self_: *mut _cef_task_t) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplTask::execute(&arg_self_.interface)
    }
}
impl ImplTask for Task {
    fn execute(&self) {
        unsafe {
            if let Some(f) = self.0.execute {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_task_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_task_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Task {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_task_t> for &Task {
    fn into_raw(self) -> *mut _cef_task_t {
        ImplTask::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_task_t> for &mut Task {
    fn into_raw(self) -> *mut _cef_task_t {
        ImplTask::get_raw(self)
    }
}
impl ConvertReturnValue<Task> for *mut _cef_task_t {
    fn wrap_result(self) -> Task {
        Task(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Task> for *mut _cef_task_t {
    fn from(value: Task) -> Self {
        let object = ImplTask::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Task {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_task_runner_t`] for more documentation.
#[derive(Clone)]
pub struct TaskRunner(RefGuard<_cef_task_runner_t>);
pub trait ImplTaskRunner: Clone + Sized + Rc {
    #[doc = "See [`_cef_task_runner_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut TaskRunner>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_task_runner_t::belongs_to_current_thread`] for more documentation."]
    fn belongs_to_current_thread(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_task_runner_t::belongs_to_thread`] for more documentation."]
    fn belongs_to_thread(&self, thread_id: ThreadId) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_task_runner_t::post_task`] for more documentation."]
    fn post_task(&self, task: Option<&mut impl ImplTask>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_task_runner_t::post_delayed_task`] for more documentation."]
    fn post_delayed_task(
        &self,
        task: Option<&mut impl ImplTask>,
        delay_ms: i64,
    ) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_task_runner_t;
}
impl ImplTaskRunner for TaskRunner {
    fn is_same(&self, that: Option<&mut TaskRunner>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplTaskRunner::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn belongs_to_current_thread(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .belongs_to_current_thread
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn belongs_to_thread(&self, thread_id: ThreadId) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .belongs_to_thread
                .map(|f| {
                    let arg_thread_id = thread_id;
                    let arg_self_ = self.into_raw();
                    let arg_thread_id = arg_thread_id.into_raw();
                    let result = f(arg_self_, arg_thread_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn post_task(&self, task: Option<&mut impl ImplTask>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .post_task
                .map(|f| {
                    let arg_task = task;
                    let arg_self_ = self.into_raw();
                    let arg_task = arg_task
                        .map(|arg| {
                            arg.add_ref();
                            ImplTask::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_task);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn post_delayed_task(
        &self,
        task: Option<&mut impl ImplTask>,
        delay_ms: i64,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .post_delayed_task
                .map(|f| {
                    let (arg_task, arg_delay_ms) = (task, delay_ms);
                    let arg_self_ = self.into_raw();
                    let arg_task = arg_task
                        .map(|arg| {
                            arg.add_ref();
                            ImplTask::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_task, arg_delay_ms);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_task_runner_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_task_runner_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for TaskRunner {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_task_runner_t> for &TaskRunner {
    fn into_raw(self) -> *mut _cef_task_runner_t {
        ImplTaskRunner::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_task_runner_t> for &mut TaskRunner {
    fn into_raw(self) -> *mut _cef_task_runner_t {
        ImplTaskRunner::get_raw(self)
    }
}
impl ConvertReturnValue<TaskRunner> for *mut _cef_task_runner_t {
    fn wrap_result(self) -> TaskRunner {
        TaskRunner(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<TaskRunner> for *mut _cef_task_runner_t {
    fn from(value: TaskRunner) -> Self {
        let object = ImplTaskRunner::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for TaskRunner {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_context_t`] for more documentation.
#[derive(Clone)]
pub struct V8Context(RefGuard<_cef_v8_context_t>);
pub trait ImplV8Context: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_context_t::get_task_runner`] for more documentation."]
    fn task_runner(&self) -> Option<TaskRunner>;
    #[doc = "See [`_cef_v8_context_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_context_t::get_browser`] for more documentation."]
    fn browser(&self) -> Option<Browser>;
    #[doc = "See [`_cef_v8_context_t::get_frame`] for more documentation."]
    fn frame(&self) -> Option<Frame>;
    #[doc = "See [`_cef_v8_context_t::get_global`] for more documentation."]
    fn global(&self) -> Option<V8Value>;
    #[doc = "See [`_cef_v8_context_t::enter`] for more documentation."]
    fn enter(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_context_t::exit`] for more documentation."]
    fn exit(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_context_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut V8Context>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_context_t::eval`] for more documentation."]
    fn eval(
        &self,
        code: Option<&CefString>,
        script_url: Option<&CefString>,
        start_line: ::std::os::raw::c_int,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut Option<V8Exception>>,
    ) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_v8_context_t;
}
impl ImplV8Context for V8Context {
    fn task_runner(&self) -> Option<TaskRunner> {
        unsafe {
            self.0
                .get_task_runner
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn browser(&self) -> Option<Browser> {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn frame(&self) -> Option<Frame> {
        unsafe {
            self.0
                .get_frame
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn global(&self) -> Option<V8Value> {
        unsafe {
            self.0
                .get_global
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn enter(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .enter
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn exit(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .exit
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut V8Context>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Context::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn eval(
        &self,
        code: Option<&CefString>,
        script_url: Option<&CefString>,
        start_line: ::std::os::raw::c_int,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut Option<V8Exception>>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .eval
                .map(|f| {
                    let (arg_code, arg_script_url, arg_start_line, arg_retval, arg_exception) =
                        (code, script_url, start_line, retval, exception);
                    let arg_self_ = self.into_raw();
                    let arg_code = arg_code
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_script_url = arg_script_url
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let mut ptr = std::ptr::null_mut();
                    let arg_retval = arg_retval
                        .map(|arg| {
                            if let Some(arg) = arg.as_mut() {
                                arg.add_ref();
                                ptr = arg.get_raw();
                            }
                            std::ptr::from_mut(&mut ptr)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut ptr = std::ptr::null_mut();
                    let arg_exception = arg_exception
                        .map(|arg| {
                            if let Some(arg) = arg.as_mut() {
                                arg.add_ref();
                                ptr = arg.get_raw();
                            }
                            std::ptr::from_mut(&mut ptr)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_code,
                        arg_script_url,
                        arg_start_line,
                        arg_retval,
                        arg_exception,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_context_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_context_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8Context {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_context_t> for &V8Context {
    fn into_raw(self) -> *mut _cef_v8_context_t {
        ImplV8Context::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_context_t> for &mut V8Context {
    fn into_raw(self) -> *mut _cef_v8_context_t {
        ImplV8Context::get_raw(self)
    }
}
impl ConvertReturnValue<V8Context> for *mut _cef_v8_context_t {
    fn wrap_result(self) -> V8Context {
        V8Context(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8Context> for *mut _cef_v8_context_t {
    fn from(value: V8Context) -> Self {
        let object = ImplV8Context::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8Context {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_handler_t`] for more documentation.
#[derive(Clone)]
pub struct V8Handler(RefGuard<_cef_v8_handler_t>);
impl V8Handler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8Handler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8Handler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8Handler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_v8_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapV8Handler: ImplV8Handler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8_handler_t, Self>);
}
pub trait ImplV8Handler: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_handler_t::execute`] for more documentation."]
    fn execute(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        arguments: Option<&[Option<V8Value>]>,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8_handler_t) {
        impl_cef_v8_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8_handler_t;
}
mod impl_cef_v8_handler_t {
    use super::*;
    pub fn init_methods<I: ImplV8Handler>(object: &mut _cef_v8_handler_t) {
        object.execute = Some(execute::<I>);
    }
    extern "C" fn execute<I: ImplV8Handler>(
        self_: *mut _cef_v8_handler_t,
        name: *const cef_string_t,
        object: *mut _cef_v8_value_t,
        arguments_count: usize,
        arguments: *const *mut _cef_v8_value_t,
        retval: *mut *mut _cef_v8_value_t,
        exception: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (
            arg_self_,
            arg_name,
            arg_object,
            arg_arguments_count,
            arg_arguments,
            arg_retval,
            arg_exception,
        ) = (
            self_,
            name,
            object,
            arguments_count,
            arguments,
            retval,
            exception,
        );
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let vec_arguments = unsafe { arg_arguments.as_ref() }.map(|arg| {
            let arg =
                unsafe { std::slice::from_raw_parts(std::ptr::from_ref(arg), arg_arguments_count) };
            arg.iter()
                .map(|arg| {
                    if arg.is_null() {
                        None
                    } else {
                        Some(V8Value(unsafe { RefGuard::from_raw(*arg) }))
                    }
                })
                .collect::<Vec<_>>()
        });
        let arg_arguments = vec_arguments.as_deref();
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8Value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = Some(&mut arg_retval);
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        ImplV8Handler::execute(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_arguments,
            arg_retval,
            arg_exception,
        )
    }
}
impl ImplV8Handler for V8Handler {
    fn execute(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        arguments: Option<&[Option<V8Value>]>,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .execute
                .map(|f| {
                    let (arg_name, arg_object, arg_arguments, arg_retval, arg_exception) =
                        (name, object, arguments, retval, exception);
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_arguments_count = arg_arguments
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let mut ptr = std::ptr::null_mut();
                    let arg_retval = arg_retval
                        .map(|arg| {
                            if let Some(arg) = arg.as_mut() {
                                arg.add_ref();
                                ptr = arg.get_raw();
                            }
                            std::ptr::from_mut(&mut ptr)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_name,
                        arg_object,
                        arg_arguments_count,
                        arg_arguments,
                        arg_retval,
                        arg_exception,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8Handler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_handler_t> for &V8Handler {
    fn into_raw(self) -> *mut _cef_v8_handler_t {
        ImplV8Handler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_handler_t> for &mut V8Handler {
    fn into_raw(self) -> *mut _cef_v8_handler_t {
        ImplV8Handler::get_raw(self)
    }
}
impl ConvertReturnValue<V8Handler> for *mut _cef_v8_handler_t {
    fn wrap_result(self) -> V8Handler {
        V8Handler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8Handler> for *mut _cef_v8_handler_t {
    fn from(value: V8Handler) -> Self {
        let object = ImplV8Handler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8Handler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_accessor_t`] for more documentation.
#[derive(Clone)]
pub struct V8Accessor(RefGuard<_cef_v8_accessor_t>);
impl V8Accessor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8Accessor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8Accessor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8Accessor>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_v8_accessor_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapV8Accessor: ImplV8Accessor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8_accessor_t, Self>);
}
pub trait ImplV8Accessor: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_accessor_t::get`] for more documentation."]
    fn get(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_v8_accessor_t::set`] for more documentation."]
    fn set(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        value: Option<&mut V8Value>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8_accessor_t) {
        impl_cef_v8_accessor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8_accessor_t;
}
mod impl_cef_v8_accessor_t {
    use super::*;
    pub fn init_methods<I: ImplV8Accessor>(object: &mut _cef_v8_accessor_t) {
        object.get = Some(get::<I>);
        object.set = Some(set::<I>);
    }
    extern "C" fn get<I: ImplV8Accessor>(
        self_: *mut _cef_v8_accessor_t,
        name: *const cef_string_t,
        object: *mut _cef_v8_value_t,
        retval: *mut *mut _cef_v8_value_t,
        exception: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_retval, arg_exception) =
            (self_, name, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8Value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = Some(&mut arg_retval);
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        ImplV8Accessor::get(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_retval,
            arg_exception,
        )
    }
    extern "C" fn set<I: ImplV8Accessor>(
        self_: *mut _cef_v8_accessor_t,
        name: *const cef_string_t,
        object: *mut _cef_v8_value_t,
        value: *mut _cef_v8_value_t,
        exception: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_value, arg_exception) =
            (self_, name, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        ImplV8Accessor::set(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_value,
            arg_exception,
        )
    }
}
impl ImplV8Accessor for V8Accessor {
    fn get(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get
                .map(|f| {
                    let (arg_name, arg_object, arg_retval, arg_exception) =
                        (name, object, retval, exception);
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut ptr = std::ptr::null_mut();
                    let arg_retval = arg_retval
                        .map(|arg| {
                            if let Some(arg) = arg.as_mut() {
                                arg.add_ref();
                                ptr = arg.get_raw();
                            }
                            std::ptr::from_mut(&mut ptr)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_object, arg_retval, arg_exception);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        value: Option<&mut V8Value>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set
                .map(|f| {
                    let (arg_name, arg_object, arg_value, arg_exception) =
                        (name, object, value, exception);
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_object, arg_value, arg_exception);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_accessor_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_accessor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8Accessor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_accessor_t> for &V8Accessor {
    fn into_raw(self) -> *mut _cef_v8_accessor_t {
        ImplV8Accessor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_accessor_t> for &mut V8Accessor {
    fn into_raw(self) -> *mut _cef_v8_accessor_t {
        ImplV8Accessor::get_raw(self)
    }
}
impl ConvertReturnValue<V8Accessor> for *mut _cef_v8_accessor_t {
    fn wrap_result(self) -> V8Accessor {
        V8Accessor(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8Accessor> for *mut _cef_v8_accessor_t {
    fn from(value: V8Accessor) -> Self {
        let object = ImplV8Accessor::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8Accessor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_interceptor_t`] for more documentation.
#[derive(Clone)]
pub struct V8Interceptor(RefGuard<_cef_v8_interceptor_t>);
impl V8Interceptor {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8Interceptor,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8Interceptor>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8Interceptor>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_v8_interceptor_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapV8Interceptor: ImplV8Interceptor {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8_interceptor_t, Self>);
}
pub trait ImplV8Interceptor: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_interceptor_t::get_byname`] for more documentation."]
    fn byname(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_v8_interceptor_t::get_byindex`] for more documentation."]
    fn byindex(
        &self,
        index: ::std::os::raw::c_int,
        object: Option<&mut V8Value>,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_v8_interceptor_t::set_byname`] for more documentation."]
    fn set_byname(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        value: Option<&mut V8Value>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_v8_interceptor_t::set_byindex`] for more documentation."]
    fn set_byindex(
        &self,
        index: ::std::os::raw::c_int,
        object: Option<&mut V8Value>,
        value: Option<&mut V8Value>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_v8_interceptor_t) {
        impl_cef_v8_interceptor_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8_interceptor_t;
}
mod impl_cef_v8_interceptor_t {
    use super::*;
    pub fn init_methods<I: ImplV8Interceptor>(object: &mut _cef_v8_interceptor_t) {
        object.get_byname = Some(get_byname::<I>);
        object.get_byindex = Some(get_byindex::<I>);
        object.set_byname = Some(set_byname::<I>);
        object.set_byindex = Some(set_byindex::<I>);
    }
    extern "C" fn get_byname<I: ImplV8Interceptor>(
        self_: *mut _cef_v8_interceptor_t,
        name: *const cef_string_t,
        object: *mut _cef_v8_value_t,
        retval: *mut *mut _cef_v8_value_t,
        exception: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_retval, arg_exception) =
            (self_, name, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8Value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = Some(&mut arg_retval);
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        ImplV8Interceptor::byname(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_retval,
            arg_exception,
        )
    }
    extern "C" fn get_byindex<I: ImplV8Interceptor>(
        self_: *mut _cef_v8_interceptor_t,
        index: ::std::os::raw::c_int,
        object: *mut _cef_v8_value_t,
        retval: *mut *mut _cef_v8_value_t,
        exception: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_object, arg_retval, arg_exception) =
            (self_, index, object, retval, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.into_raw();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_retval = unsafe { arg_retval.as_mut() }.and_then(|ptr| {
            if ptr.is_null() {
                None
            } else {
                Some(V8Value(unsafe { RefGuard::from_raw(*ptr) }))
            }
        });
        let arg_retval = Some(&mut arg_retval);
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        ImplV8Interceptor::byindex(
            &arg_self_.interface,
            arg_index,
            arg_object,
            arg_retval,
            arg_exception,
        )
    }
    extern "C" fn set_byname<I: ImplV8Interceptor>(
        self_: *mut _cef_v8_interceptor_t,
        name: *const cef_string_t,
        object: *mut _cef_v8_value_t,
        value: *mut _cef_v8_value_t,
        exception: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_name, arg_object, arg_value, arg_exception) =
            (self_, name, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_name = if arg_name.is_null() {
            None
        } else {
            Some(arg_name.into())
        };
        let arg_name = arg_name.as_ref();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        ImplV8Interceptor::set_byname(
            &arg_self_.interface,
            arg_name,
            arg_object,
            arg_value,
            arg_exception,
        )
    }
    extern "C" fn set_byindex<I: ImplV8Interceptor>(
        self_: *mut _cef_v8_interceptor_t,
        index: ::std::os::raw::c_int,
        object: *mut _cef_v8_value_t,
        value: *mut _cef_v8_value_t,
        exception: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_index, arg_object, arg_value, arg_exception) =
            (self_, index, object, value, exception);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_index = arg_index.into_raw();
        let mut arg_object =
            unsafe { arg_object.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_object = arg_object.as_mut();
        let mut arg_value =
            unsafe { arg_value.as_mut() }.map(|arg| V8Value(unsafe { RefGuard::from_raw(arg) }));
        let arg_value = arg_value.as_mut();
        let mut arg_exception = if arg_exception.is_null() {
            None
        } else {
            Some(arg_exception.into())
        };
        let arg_exception = arg_exception.as_mut();
        ImplV8Interceptor::set_byindex(
            &arg_self_.interface,
            arg_index,
            arg_object,
            arg_value,
            arg_exception,
        )
    }
}
impl ImplV8Interceptor for V8Interceptor {
    fn byname(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_byname
                .map(|f| {
                    let (arg_name, arg_object, arg_retval, arg_exception) =
                        (name, object, retval, exception);
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut ptr = std::ptr::null_mut();
                    let arg_retval = arg_retval
                        .map(|arg| {
                            if let Some(arg) = arg.as_mut() {
                                arg.add_ref();
                                ptr = arg.get_raw();
                            }
                            std::ptr::from_mut(&mut ptr)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_object, arg_retval, arg_exception);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn byindex(
        &self,
        index: ::std::os::raw::c_int,
        object: Option<&mut V8Value>,
        retval: Option<&mut Option<V8Value>>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_byindex
                .map(|f| {
                    let (arg_index, arg_object, arg_retval, arg_exception) =
                        (index, object, retval, exception);
                    let arg_self_ = self.into_raw();
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut ptr = std::ptr::null_mut();
                    let arg_retval = arg_retval
                        .map(|arg| {
                            if let Some(arg) = arg.as_mut() {
                                arg.add_ref();
                                ptr = arg.get_raw();
                            }
                            std::ptr::from_mut(&mut ptr)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_object, arg_retval, arg_exception);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_byname(
        &self,
        name: Option<&CefString>,
        object: Option<&mut V8Value>,
        value: Option<&mut V8Value>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_byname
                .map(|f| {
                    let (arg_name, arg_object, arg_value, arg_exception) =
                        (name, object, value, exception);
                    let arg_self_ = self.into_raw();
                    let arg_name = arg_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_name, arg_object, arg_value, arg_exception);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_byindex(
        &self,
        index: ::std::os::raw::c_int,
        object: Option<&mut V8Value>,
        value: Option<&mut V8Value>,
        exception: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_byindex
                .map(|f| {
                    let (arg_index, arg_object, arg_value, arg_exception) =
                        (index, object, value, exception);
                    let arg_self_ = self.into_raw();
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_exception = arg_exception
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_object, arg_value, arg_exception);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_interceptor_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_interceptor_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8Interceptor {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_interceptor_t> for &V8Interceptor {
    fn into_raw(self) -> *mut _cef_v8_interceptor_t {
        ImplV8Interceptor::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_interceptor_t> for &mut V8Interceptor {
    fn into_raw(self) -> *mut _cef_v8_interceptor_t {
        ImplV8Interceptor::get_raw(self)
    }
}
impl ConvertReturnValue<V8Interceptor> for *mut _cef_v8_interceptor_t {
    fn wrap_result(self) -> V8Interceptor {
        V8Interceptor(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8Interceptor> for *mut _cef_v8_interceptor_t {
    fn from(value: V8Interceptor) -> Self {
        let object = ImplV8Interceptor::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8Interceptor {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_exception_t`] for more documentation.
#[derive(Clone)]
pub struct V8Exception(RefGuard<_cef_v8_exception_t>);
pub trait ImplV8Exception: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_exception_t::get_message`] for more documentation."]
    fn message(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_v8_exception_t::get_source_line`] for more documentation."]
    fn source_line(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_v8_exception_t::get_script_resource_name`] for more documentation."]
    fn script_resource_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_v8_exception_t::get_line_number`] for more documentation."]
    fn line_number(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_exception_t::get_start_position`] for more documentation."]
    fn start_position(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_exception_t::get_end_position`] for more documentation."]
    fn end_position(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_exception_t::get_start_column`] for more documentation."]
    fn start_column(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_exception_t::get_end_column`] for more documentation."]
    fn end_column(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_v8_exception_t;
}
impl ImplV8Exception for V8Exception {
    fn message(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_message
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn source_line(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_source_line
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn script_resource_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_script_resource_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn line_number(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_line_number
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn start_position(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_start_position
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn end_position(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_end_position
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn start_column(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_start_column
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn end_column(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_end_column
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_exception_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_exception_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8Exception {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_exception_t> for &V8Exception {
    fn into_raw(self) -> *mut _cef_v8_exception_t {
        ImplV8Exception::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_exception_t> for &mut V8Exception {
    fn into_raw(self) -> *mut _cef_v8_exception_t {
        ImplV8Exception::get_raw(self)
    }
}
impl ConvertReturnValue<V8Exception> for *mut _cef_v8_exception_t {
    fn wrap_result(self) -> V8Exception {
        V8Exception(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8Exception> for *mut _cef_v8_exception_t {
    fn from(value: V8Exception) -> Self {
        let object = ImplV8Exception::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8Exception {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_array_buffer_release_callback_t`] for more documentation.
#[derive(Clone)]
pub struct V8ArrayBufferReleaseCallback(RefGuard<_cef_v8_array_buffer_release_callback_t>);
impl V8ArrayBufferReleaseCallback {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapV8ArrayBufferReleaseCallback,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplV8ArrayBufferReleaseCallback>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapV8ArrayBufferReleaseCallback>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_v8_array_buffer_release_callback_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapV8ArrayBufferReleaseCallback: ImplV8ArrayBufferReleaseCallback {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_v8_array_buffer_release_callback_t, Self>);
}
pub trait ImplV8ArrayBufferReleaseCallback: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_array_buffer_release_callback_t::release_buffer`] for more documentation."]
    fn release_buffer(&self, buffer: *mut u8) {}
    fn init_methods(object: &mut _cef_v8_array_buffer_release_callback_t) {
        impl_cef_v8_array_buffer_release_callback_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_v8_array_buffer_release_callback_t;
}
mod impl_cef_v8_array_buffer_release_callback_t {
    use super::*;
    pub fn init_methods<I: ImplV8ArrayBufferReleaseCallback>(
        object: &mut _cef_v8_array_buffer_release_callback_t,
    ) {
        object.release_buffer = Some(release_buffer::<I>);
    }
    extern "C" fn release_buffer<I: ImplV8ArrayBufferReleaseCallback>(
        self_: *mut _cef_v8_array_buffer_release_callback_t,
        buffer: *mut ::std::os::raw::c_void,
    ) {
        let (arg_self_, arg_buffer) = (self_, buffer);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_buffer = arg_buffer.cast();
        ImplV8ArrayBufferReleaseCallback::release_buffer(&arg_self_.interface, arg_buffer)
    }
}
impl ImplV8ArrayBufferReleaseCallback for V8ArrayBufferReleaseCallback {
    fn release_buffer(&self, buffer: *mut u8) {
        unsafe {
            if let Some(f) = self.0.release_buffer {
                let arg_buffer = buffer;
                let arg_self_ = self.into_raw();
                let arg_buffer = arg_buffer.cast();
                f(arg_self_, arg_buffer);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_array_buffer_release_callback_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_array_buffer_release_callback_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8ArrayBufferReleaseCallback {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_array_buffer_release_callback_t> for &V8ArrayBufferReleaseCallback {
    fn into_raw(self) -> *mut _cef_v8_array_buffer_release_callback_t {
        ImplV8ArrayBufferReleaseCallback::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_array_buffer_release_callback_t>
    for &mut V8ArrayBufferReleaseCallback
{
    fn into_raw(self) -> *mut _cef_v8_array_buffer_release_callback_t {
        ImplV8ArrayBufferReleaseCallback::get_raw(self)
    }
}
impl ConvertReturnValue<V8ArrayBufferReleaseCallback>
    for *mut _cef_v8_array_buffer_release_callback_t
{
    fn wrap_result(self) -> V8ArrayBufferReleaseCallback {
        V8ArrayBufferReleaseCallback(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8ArrayBufferReleaseCallback> for *mut _cef_v8_array_buffer_release_callback_t {
    fn from(value: V8ArrayBufferReleaseCallback) -> Self {
        let object = ImplV8ArrayBufferReleaseCallback::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8ArrayBufferReleaseCallback {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_value_t`] for more documentation.
#[derive(Clone)]
pub struct V8Value(RefGuard<_cef_v8_value_t>);
pub trait ImplV8Value: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_value_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_undefined`] for more documentation."]
    fn is_undefined(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_null`] for more documentation."]
    fn is_null(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_bool`] for more documentation."]
    fn is_bool(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_int`] for more documentation."]
    fn is_int(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_uint`] for more documentation."]
    fn is_uint(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_double`] for more documentation."]
    fn is_double(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_date`] for more documentation."]
    fn is_date(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_string`] for more documentation."]
    fn is_string(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_object`] for more documentation."]
    fn is_object(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_array`] for more documentation."]
    fn is_array(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_array_buffer`] for more documentation."]
    fn is_array_buffer(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_function`] for more documentation."]
    fn is_function(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_promise`] for more documentation."]
    fn is_promise(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut V8Value>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_bool_value`] for more documentation."]
    fn bool_value(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_int_value`] for more documentation."]
    fn int_value(&self) -> i32;
    #[doc = "See [`_cef_v8_value_t::get_uint_value`] for more documentation."]
    fn uint_value(&self) -> u32;
    #[doc = "See [`_cef_v8_value_t::get_double_value`] for more documentation."]
    fn double_value(&self) -> f64;
    #[doc = "See [`_cef_v8_value_t::get_date_value`] for more documentation."]
    fn date_value(&self) -> Basetime;
    #[doc = "See [`_cef_v8_value_t::get_string_value`] for more documentation."]
    fn string_value(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_v8_value_t::is_user_created`] for more documentation."]
    fn is_user_created(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::has_exception`] for more documentation."]
    fn has_exception(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_exception`] for more documentation."]
    fn exception(&self) -> Option<V8Exception>;
    #[doc = "See [`_cef_v8_value_t::clear_exception`] for more documentation."]
    fn clear_exception(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::will_rethrow_exceptions`] for more documentation."]
    fn will_rethrow_exceptions(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::set_rethrow_exceptions`] for more documentation."]
    fn set_rethrow_exceptions(&self, rethrow: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::has_value_bykey`] for more documentation."]
    fn has_value_bykey(&self, key: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::has_value_byindex`] for more documentation."]
    fn has_value_byindex(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::delete_value_bykey`] for more documentation."]
    fn delete_value_bykey(&self, key: Option<&CefString>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::delete_value_byindex`] for more documentation."]
    fn delete_value_byindex(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_value_bykey`] for more documentation."]
    fn value_bykey(&self, key: Option<&CefString>) -> Option<V8Value>;
    #[doc = "See [`_cef_v8_value_t::get_value_byindex`] for more documentation."]
    fn value_byindex(&self, index: ::std::os::raw::c_int) -> Option<V8Value>;
    #[doc = "See [`_cef_v8_value_t::set_value_bykey`] for more documentation."]
    fn set_value_bykey(
        &self,
        key: Option<&CefString>,
        value: Option<&mut V8Value>,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::set_value_byindex`] for more documentation."]
    fn set_value_byindex(
        &self,
        index: ::std::os::raw::c_int,
        value: Option<&mut V8Value>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::set_value_byaccessor`] for more documentation."]
    fn set_value_byaccessor(
        &self,
        key: Option<&CefString>,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_keys`] for more documentation."]
    fn keys(&self, keys: Option<&mut CefStringList>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::set_user_data`] for more documentation."]
    fn set_user_data(&self, user_data: Option<&mut BaseRefCounted>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_user_data`] for more documentation."]
    fn user_data(&self) -> Option<BaseRefCounted>;
    #[doc = "See [`_cef_v8_value_t::get_externally_allocated_memory`] for more documentation."]
    fn externally_allocated_memory(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::adjust_externally_allocated_memory`] for more documentation."]
    fn adjust_externally_allocated_memory(
        &self,
        change_in_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_array_length`] for more documentation."]
    fn array_length(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_array_buffer_release_callback`] for more documentation."]
    fn array_buffer_release_callback(&self) -> Option<V8ArrayBufferReleaseCallback>;
    #[doc = "See [`_cef_v8_value_t::neuter_array_buffer`] for more documentation."]
    fn neuter_array_buffer(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::get_array_buffer_byte_length`] for more documentation."]
    fn array_buffer_byte_length(&self) -> usize;
    #[doc = "See [`_cef_v8_value_t::get_array_buffer_data`] for more documentation."]
    fn array_buffer_data(&self) -> *mut ::std::os::raw::c_void;
    #[doc = "See [`_cef_v8_value_t::get_function_name`] for more documentation."]
    fn function_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_v8_value_t::get_function_handler`] for more documentation."]
    fn function_handler(&self) -> Option<V8Handler>;
    #[doc = "See [`_cef_v8_value_t::execute_function`] for more documentation."]
    fn execute_function(
        &self,
        object: Option<&mut V8Value>,
        arguments: Option<&[Option<V8Value>]>,
    ) -> Option<V8Value>;
    #[doc = "See [`_cef_v8_value_t::execute_function_with_context`] for more documentation."]
    fn execute_function_with_context(
        &self,
        context: Option<&mut V8Context>,
        object: Option<&mut V8Value>,
        arguments: Option<&[Option<V8Value>]>,
    ) -> Option<V8Value>;
    #[doc = "See [`_cef_v8_value_t::resolve_promise`] for more documentation."]
    fn resolve_promise(&self, arg: Option<&mut V8Value>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_value_t::reject_promise`] for more documentation."]
    fn reject_promise(&self, error_msg: Option<&CefString>) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_v8_value_t;
}
impl ImplV8Value for V8Value {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_undefined(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_undefined
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_null(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_null
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_bool(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_bool
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_int(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_int
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_uint(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_uint
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_double(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_double
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_date(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_date
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_string(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_string
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_object(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_object
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_array(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_array
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_array_buffer(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_array_buffer
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_function(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_function
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_promise(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_promise
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut V8Value>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn bool_value(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_bool_value
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn int_value(&self) -> i32 {
        unsafe {
            self.0
                .get_int_value
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn uint_value(&self) -> u32 {
        unsafe {
            self.0
                .get_uint_value
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn double_value(&self) -> f64 {
        unsafe {
            self.0
                .get_double_value
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn date_value(&self) -> Basetime {
        unsafe {
            self.0
                .get_date_value
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn string_value(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_string_value
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_user_created(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_user_created
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_exception(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_exception
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn exception(&self) -> Option<V8Exception> {
        unsafe {
            self.0
                .get_exception
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn clear_exception(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .clear_exception
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn will_rethrow_exceptions(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .will_rethrow_exceptions
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_rethrow_exceptions(&self, rethrow: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_rethrow_exceptions
                .map(|f| {
                    let arg_rethrow = rethrow;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_rethrow);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_value_bykey(&self, key: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_value_byindex(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn delete_value_bykey(&self, key: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn delete_value_byindex(&self, index: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .delete_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn value_bykey(&self, key: Option<&CefString>) -> Option<V8Value> {
        unsafe {
            self.0
                .get_value_bykey
                .map(|f| {
                    let arg_key = key;
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_key);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn value_byindex(&self, index: ::std::os::raw::c_int) -> Option<V8Value> {
        unsafe {
            self.0
                .get_value_byindex
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_value_bykey(
        &self,
        key: Option<&CefString>,
        value: Option<&mut V8Value>,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_bykey
                .map(|f| {
                    let (arg_key, arg_value, arg_attribute) = (key, value, attribute);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_attribute = arg_attribute.into_raw();
                    let result = f(arg_self_, arg_key, arg_value, arg_attribute);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_value_byindex(
        &self,
        index: ::std::os::raw::c_int,
        value: Option<&mut V8Value>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_byindex
                .map(|f| {
                    let (arg_index, arg_value) = (index, value);
                    let arg_self_ = self.into_raw();
                    let arg_value = arg_value
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_index, arg_value);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_value_byaccessor(
        &self,
        key: Option<&CefString>,
        attribute: V8Propertyattribute,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_value_byaccessor
                .map(|f| {
                    let (arg_key, arg_attribute) = (key, attribute);
                    let arg_self_ = self.into_raw();
                    let arg_key = arg_key
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_attribute = arg_attribute.into_raw();
                    let result = f(arg_self_, arg_key, arg_attribute);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn keys(&self, keys: Option<&mut CefStringList>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_keys
                .map(|f| {
                    let arg_keys = keys;
                    let arg_self_ = self.into_raw();
                    let arg_keys = arg_keys
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_keys);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_user_data(&self, user_data: Option<&mut BaseRefCounted>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .set_user_data
                .map(|f| {
                    let arg_user_data = user_data;
                    let arg_self_ = self.into_raw();
                    let arg_user_data = arg_user_data
                        .map(|arg| {
                            arg.add_ref();
                            arg.into_raw()
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_user_data);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn user_data(&self) -> Option<BaseRefCounted> {
        unsafe {
            self.0
                .get_user_data
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn externally_allocated_memory(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_externally_allocated_memory
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn adjust_externally_allocated_memory(
        &self,
        change_in_bytes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .adjust_externally_allocated_memory
                .map(|f| {
                    let arg_change_in_bytes = change_in_bytes;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_change_in_bytes);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn array_length(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_array_length
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn array_buffer_release_callback(&self) -> Option<V8ArrayBufferReleaseCallback> {
        unsafe {
            self.0
                .get_array_buffer_release_callback
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn neuter_array_buffer(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .neuter_array_buffer
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn array_buffer_byte_length(&self) -> usize {
        unsafe {
            self.0
                .get_array_buffer_byte_length
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn array_buffer_data(&self) -> *mut ::std::os::raw::c_void {
        unsafe {
            self.0
                .get_array_buffer_data
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn function_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_function_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn function_handler(&self) -> Option<V8Handler> {
        unsafe {
            self.0
                .get_function_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn execute_function(
        &self,
        object: Option<&mut V8Value>,
        arguments: Option<&[Option<V8Value>]>,
    ) -> Option<V8Value> {
        unsafe {
            self.0
                .execute_function
                .map(|f| {
                    let (arg_object, arg_arguments) = (object, arguments);
                    let arg_self_ = self.into_raw();
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_arguments_count = arg_arguments
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let result = f(arg_self_, arg_object, arg_arguments_count, arg_arguments);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn execute_function_with_context(
        &self,
        context: Option<&mut V8Context>,
        object: Option<&mut V8Value>,
        arguments: Option<&[Option<V8Value>]>,
    ) -> Option<V8Value> {
        unsafe {
            self.0
                .execute_function_with_context
                .map(|f| {
                    let (arg_context, arg_object, arg_arguments) = (context, object, arguments);
                    let arg_self_ = self.into_raw();
                    let arg_context = arg_context
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Context::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_object = arg_object
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_arguments_count = arg_arguments
                        .as_ref()
                        .map(|arg| arg.len())
                        .unwrap_or_default();
                    let vec_arguments = arg_arguments
                        .as_ref()
                        .map(|arg| {
                            arg.iter()
                                .map(|elem| {
                                    elem.as_ref()
                                        .map(|elem| {
                                            elem.add_ref();
                                            elem.get_raw()
                                        })
                                        .unwrap_or(std::ptr::null_mut())
                                })
                                .collect::<Vec<_>>()
                        })
                        .unwrap_or_default();
                    let arg_arguments = if vec_arguments.is_empty() {
                        std::ptr::null()
                    } else {
                        vec_arguments.as_ptr()
                    };
                    let result = f(
                        arg_self_,
                        arg_context,
                        arg_object,
                        arg_arguments_count,
                        arg_arguments,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn resolve_promise(&self, arg: Option<&mut V8Value>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .resolve_promise
                .map(|f| {
                    let arg_arg = arg;
                    let arg_self_ = self.into_raw();
                    let arg_arg = arg_arg
                        .map(|arg| {
                            arg.add_ref();
                            ImplV8Value::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_arg);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn reject_promise(&self, error_msg: Option<&CefString>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .reject_promise
                .map(|f| {
                    let arg_error_msg = error_msg;
                    let arg_self_ = self.into_raw();
                    let arg_error_msg = arg_error_msg
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_error_msg);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_value_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_value_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8Value {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_value_t> for &V8Value {
    fn into_raw(self) -> *mut _cef_v8_value_t {
        ImplV8Value::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_value_t> for &mut V8Value {
    fn into_raw(self) -> *mut _cef_v8_value_t {
        ImplV8Value::get_raw(self)
    }
}
impl ConvertReturnValue<V8Value> for *mut _cef_v8_value_t {
    fn wrap_result(self) -> V8Value {
        V8Value(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8Value> for *mut _cef_v8_value_t {
    fn from(value: V8Value) -> Self {
        let object = ImplV8Value::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8Value {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_stack_trace_t`] for more documentation.
#[derive(Clone)]
pub struct V8StackTrace(RefGuard<_cef_v8_stack_trace_t>);
pub trait ImplV8StackTrace: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_stack_trace_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_stack_trace_t::get_frame_count`] for more documentation."]
    fn frame_count(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_stack_trace_t::get_frame`] for more documentation."]
    fn frame(&self, index: ::std::os::raw::c_int) -> Option<V8StackFrame>;
    fn get_raw(&self) -> *mut _cef_v8_stack_trace_t;
}
impl ImplV8StackTrace for V8StackTrace {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn frame_count(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_frame_count
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn frame(&self, index: ::std::os::raw::c_int) -> Option<V8StackFrame> {
        unsafe {
            self.0
                .get_frame
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_stack_trace_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_stack_trace_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8StackTrace {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_stack_trace_t> for &V8StackTrace {
    fn into_raw(self) -> *mut _cef_v8_stack_trace_t {
        ImplV8StackTrace::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_stack_trace_t> for &mut V8StackTrace {
    fn into_raw(self) -> *mut _cef_v8_stack_trace_t {
        ImplV8StackTrace::get_raw(self)
    }
}
impl ConvertReturnValue<V8StackTrace> for *mut _cef_v8_stack_trace_t {
    fn wrap_result(self) -> V8StackTrace {
        V8StackTrace(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8StackTrace> for *mut _cef_v8_stack_trace_t {
    fn from(value: V8StackTrace) -> Self {
        let object = ImplV8StackTrace::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8StackTrace {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_v8_stack_frame_t`] for more documentation.
#[derive(Clone)]
pub struct V8StackFrame(RefGuard<_cef_v8_stack_frame_t>);
pub trait ImplV8StackFrame: Clone + Sized + Rc {
    #[doc = "See [`_cef_v8_stack_frame_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_stack_frame_t::get_script_name`] for more documentation."]
    fn script_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_v8_stack_frame_t::get_script_name_or_source_url`] for more documentation."]
    fn script_name_or_source_url(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_v8_stack_frame_t::get_function_name`] for more documentation."]
    fn function_name(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_v8_stack_frame_t::get_line_number`] for more documentation."]
    fn line_number(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_stack_frame_t::get_column`] for more documentation."]
    fn column(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_stack_frame_t::is_eval`] for more documentation."]
    fn is_eval(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_v8_stack_frame_t::is_constructor`] for more documentation."]
    fn is_constructor(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_v8_stack_frame_t;
}
impl ImplV8StackFrame for V8StackFrame {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn script_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_script_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn script_name_or_source_url(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_script_name_or_source_url
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn function_name(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_function_name
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn line_number(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_line_number
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn column(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_column
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_eval(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_eval
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_constructor(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_constructor
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_v8_stack_frame_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_v8_stack_frame_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for V8StackFrame {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_v8_stack_frame_t> for &V8StackFrame {
    fn into_raw(self) -> *mut _cef_v8_stack_frame_t {
        ImplV8StackFrame::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_v8_stack_frame_t> for &mut V8StackFrame {
    fn into_raw(self) -> *mut _cef_v8_stack_frame_t {
        ImplV8StackFrame::get_raw(self)
    }
}
impl ConvertReturnValue<V8StackFrame> for *mut _cef_v8_stack_frame_t {
    fn wrap_result(self) -> V8StackFrame {
        V8StackFrame(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<V8StackFrame> for *mut _cef_v8_stack_frame_t {
    fn from(value: V8StackFrame) -> Self {
        let object = ImplV8StackFrame::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for V8StackFrame {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_render_process_handler_t`] for more documentation.
#[derive(Clone)]
pub struct RenderProcessHandler(RefGuard<_cef_render_process_handler_t>);
impl RenderProcessHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapRenderProcessHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplRenderProcessHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapRenderProcessHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_render_process_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapRenderProcessHandler: ImplRenderProcessHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_render_process_handler_t, Self>);
}
pub trait ImplRenderProcessHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_render_process_handler_t::on_web_kit_initialized`] for more documentation."]
    fn on_web_kit_initialized(&self) {}
    #[doc = "See [`_cef_render_process_handler_t::on_browser_created`] for more documentation."]
    fn on_browser_created(
        &self,
        browser: Option<&mut Browser>,
        extra_info: Option<&mut DictionaryValue>,
    ) {
    }
    #[doc = "See [`_cef_render_process_handler_t::on_browser_destroyed`] for more documentation."]
    fn on_browser_destroyed(&self, browser: Option<&mut Browser>) {}
    #[doc = "See [`_cef_render_process_handler_t::get_load_handler`] for more documentation."]
    fn load_handler(&self) -> Option<LoadHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_render_process_handler_t::on_context_created`] for more documentation."]
    fn on_context_created(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        context: Option<&mut V8Context>,
    ) {
    }
    #[doc = "See [`_cef_render_process_handler_t::on_context_released`] for more documentation."]
    fn on_context_released(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        context: Option<&mut V8Context>,
    ) {
    }
    #[doc = "See [`_cef_render_process_handler_t::on_uncaught_exception`] for more documentation."]
    fn on_uncaught_exception(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        context: Option<&mut V8Context>,
        exception: Option<&mut V8Exception>,
        stack_trace: Option<&mut V8StackTrace>,
    ) {
    }
    #[doc = "See [`_cef_render_process_handler_t::on_focused_node_changed`] for more documentation."]
    fn on_focused_node_changed(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        node: Option<&mut Domnode>,
    ) {
    }
    #[doc = "See [`_cef_render_process_handler_t::on_process_message_received`] for more documentation."]
    fn on_process_message_received(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        source_process: ProcessId,
        message: Option<&mut ProcessMessage>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_render_process_handler_t) {
        impl_cef_render_process_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_render_process_handler_t;
}
mod impl_cef_render_process_handler_t {
    use super::*;
    pub fn init_methods<I: ImplRenderProcessHandler>(object: &mut _cef_render_process_handler_t) {
        object.on_web_kit_initialized = Some(on_web_kit_initialized::<I>);
        object.on_browser_created = Some(on_browser_created::<I>);
        object.on_browser_destroyed = Some(on_browser_destroyed::<I>);
        object.get_load_handler = Some(get_load_handler::<I>);
        object.on_context_created = Some(on_context_created::<I>);
        object.on_context_released = Some(on_context_released::<I>);
        object.on_uncaught_exception = Some(on_uncaught_exception::<I>);
        object.on_focused_node_changed = Some(on_focused_node_changed::<I>);
        object.on_process_message_received = Some(on_process_message_received::<I>);
    }
    extern "C" fn on_web_kit_initialized<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
    ) {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        ImplRenderProcessHandler::on_web_kit_initialized(&arg_self_.interface)
    }
    extern "C" fn on_browser_created<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        extra_info: *mut _cef_dictionary_value_t,
    ) {
        let (arg_self_, arg_browser, arg_extra_info) = (self_, browser, extra_info);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_extra_info = unsafe { arg_extra_info.as_mut() }
            .map(|arg| DictionaryValue(unsafe { RefGuard::from_raw(arg) }));
        let arg_extra_info = arg_extra_info.as_mut();
        ImplRenderProcessHandler::on_browser_created(
            &arg_self_.interface,
            arg_browser,
            arg_extra_info,
        )
    }
    extern "C" fn on_browser_destroyed<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser) = (self_, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplRenderProcessHandler::on_browser_destroyed(&arg_self_.interface, arg_browser)
    }
    extern "C" fn get_load_handler<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
    ) -> *mut _cef_load_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplRenderProcessHandler::load_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_context_created<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8_context_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context) = (self_, browser, frame, context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_context = unsafe { arg_context.as_mut() }
            .map(|arg| V8Context(unsafe { RefGuard::from_raw(arg) }));
        let arg_context = arg_context.as_mut();
        ImplRenderProcessHandler::on_context_created(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_context,
        )
    }
    extern "C" fn on_context_released<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8_context_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context) = (self_, browser, frame, context);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_context = unsafe { arg_context.as_mut() }
            .map(|arg| V8Context(unsafe { RefGuard::from_raw(arg) }));
        let arg_context = arg_context.as_mut();
        ImplRenderProcessHandler::on_context_released(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_context,
        )
    }
    extern "C" fn on_uncaught_exception<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        context: *mut _cef_v8_context_t,
        exception: *mut _cef_v8_exception_t,
        stack_trace: *mut _cef_v8_stack_trace_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_context, arg_exception, arg_stack_trace) =
            (self_, browser, frame, context, exception, stack_trace);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_context = unsafe { arg_context.as_mut() }
            .map(|arg| V8Context(unsafe { RefGuard::from_raw(arg) }));
        let arg_context = arg_context.as_mut();
        let mut arg_exception = unsafe { arg_exception.as_mut() }
            .map(|arg| V8Exception(unsafe { RefGuard::from_raw(arg) }));
        let arg_exception = arg_exception.as_mut();
        let mut arg_stack_trace = unsafe { arg_stack_trace.as_mut() }
            .map(|arg| V8StackTrace(unsafe { RefGuard::from_raw(arg) }));
        let arg_stack_trace = arg_stack_trace.as_mut();
        ImplRenderProcessHandler::on_uncaught_exception(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_context,
            arg_exception,
            arg_stack_trace,
        )
    }
    extern "C" fn on_focused_node_changed<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        node: *mut _cef_domnode_t,
    ) {
        let (arg_self_, arg_browser, arg_frame, arg_node) = (self_, browser, frame, node);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let mut arg_node =
            unsafe { arg_node.as_mut() }.map(|arg| Domnode(unsafe { RefGuard::from_raw(arg) }));
        let arg_node = arg_node.as_mut();
        ImplRenderProcessHandler::on_focused_node_changed(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_node,
        )
    }
    extern "C" fn on_process_message_received<I: ImplRenderProcessHandler>(
        self_: *mut _cef_render_process_handler_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        source_process: cef_process_id_t,
        message: *mut _cef_process_message_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser, arg_frame, arg_source_process, arg_message) =
            (self_, browser, frame, source_process, message);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_source_process = arg_source_process.into_raw();
        let mut arg_message = unsafe { arg_message.as_mut() }
            .map(|arg| ProcessMessage(unsafe { RefGuard::from_raw(arg) }));
        let arg_message = arg_message.as_mut();
        ImplRenderProcessHandler::on_process_message_received(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_source_process,
            arg_message,
        )
    }
}
impl ImplRenderProcessHandler for RenderProcessHandler {
    fn on_web_kit_initialized(&self) {
        unsafe {
            if let Some(f) = self.0.on_web_kit_initialized {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn on_browser_created(
        &self,
        browser: Option<&mut Browser>,
        extra_info: Option<&mut DictionaryValue>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_browser_created {
                let (arg_browser, arg_extra_info) = (browser, extra_info);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_extra_info = arg_extra_info
                    .map(|arg| {
                        arg.add_ref();
                        ImplDictionaryValue::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_extra_info);
            }
        }
    }
    fn on_browser_destroyed(&self, browser: Option<&mut Browser>) {
        unsafe {
            if let Some(f) = self.0.on_browser_destroyed {
                let arg_browser = browser;
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser);
            }
        }
    }
    fn load_handler(&self) -> Option<LoadHandler> {
        unsafe {
            self.0
                .get_load_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_context_created(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        context: Option<&mut V8Context>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_context_created {
                let (arg_browser, arg_frame, arg_context) = (browser, frame, context);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_context = arg_context
                    .map(|arg| {
                        arg.add_ref();
                        ImplV8Context::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame, arg_context);
            }
        }
    }
    fn on_context_released(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        context: Option<&mut V8Context>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_context_released {
                let (arg_browser, arg_frame, arg_context) = (browser, frame, context);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_context = arg_context
                    .map(|arg| {
                        arg.add_ref();
                        ImplV8Context::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame, arg_context);
            }
        }
    }
    fn on_uncaught_exception(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        context: Option<&mut V8Context>,
        exception: Option<&mut V8Exception>,
        stack_trace: Option<&mut V8StackTrace>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_uncaught_exception {
                let (arg_browser, arg_frame, arg_context, arg_exception, arg_stack_trace) =
                    (browser, frame, context, exception, stack_trace);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_context = arg_context
                    .map(|arg| {
                        arg.add_ref();
                        ImplV8Context::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_exception = arg_exception
                    .map(|arg| {
                        arg.add_ref();
                        ImplV8Exception::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_stack_trace = arg_stack_trace
                    .map(|arg| {
                        arg.add_ref();
                        ImplV8StackTrace::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_browser,
                    arg_frame,
                    arg_context,
                    arg_exception,
                    arg_stack_trace,
                );
            }
        }
    }
    fn on_focused_node_changed(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        node: Option<&mut Domnode>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_focused_node_changed {
                let (arg_browser, arg_frame, arg_node) = (browser, frame, node);
                let arg_self_ = self.into_raw();
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_frame = arg_frame
                    .map(|arg| {
                        arg.add_ref();
                        ImplFrame::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_node = arg_node
                    .map(|arg| {
                        arg.add_ref();
                        ImplDomnode::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser, arg_frame, arg_node);
            }
        }
    }
    fn on_process_message_received(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        source_process: ProcessId,
        message: Option<&mut ProcessMessage>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_process_message_received
                .map(|f| {
                    let (arg_browser, arg_frame, arg_source_process, arg_message) =
                        (browser, frame, source_process, message);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_source_process = arg_source_process.into_raw();
                    let arg_message = arg_message
                        .map(|arg| {
                            arg.add_ref();
                            ImplProcessMessage::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_source_process,
                        arg_message,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_render_process_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_render_process_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for RenderProcessHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_render_process_handler_t> for &RenderProcessHandler {
    fn into_raw(self) -> *mut _cef_render_process_handler_t {
        ImplRenderProcessHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_render_process_handler_t> for &mut RenderProcessHandler {
    fn into_raw(self) -> *mut _cef_render_process_handler_t {
        ImplRenderProcessHandler::get_raw(self)
    }
}
impl ConvertReturnValue<RenderProcessHandler> for *mut _cef_render_process_handler_t {
    fn wrap_result(self) -> RenderProcessHandler {
        RenderProcessHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<RenderProcessHandler> for *mut _cef_render_process_handler_t {
    fn from(value: RenderProcessHandler) -> Self {
        let object = ImplRenderProcessHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for RenderProcessHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_resource_bundle_handler_t`] for more documentation.
#[derive(Clone)]
pub struct ResourceBundleHandler(RefGuard<_cef_resource_bundle_handler_t>);
impl ResourceBundleHandler {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapResourceBundleHandler,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplResourceBundleHandler>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapResourceBundleHandler>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_resource_bundle_handler_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapResourceBundleHandler: ImplResourceBundleHandler {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_resource_bundle_handler_t, Self>);
}
pub trait ImplResourceBundleHandler: Clone + Sized + Rc {
    #[doc = "See [`_cef_resource_bundle_handler_t::get_localized_string`] for more documentation."]
    fn localized_string(
        &self,
        string_id: ::std::os::raw::c_int,
        string: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_resource_bundle_handler_t::get_data_resource`] for more documentation."]
    fn data_resource(
        &self,
        resource_id: ::std::os::raw::c_int,
        data: Option<&mut Vec<u8>>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_resource_bundle_handler_t::get_data_resource_for_scale`] for more documentation."]
    fn data_resource_for_scale(
        &self,
        resource_id: ::std::os::raw::c_int,
        scale_factor: ScaleFactor,
        data: Option<&mut Vec<u8>>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_resource_bundle_handler_t) {
        impl_cef_resource_bundle_handler_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_resource_bundle_handler_t;
}
mod impl_cef_resource_bundle_handler_t {
    use super::*;
    pub fn init_methods<I: ImplResourceBundleHandler>(object: &mut _cef_resource_bundle_handler_t) {
        object.get_localized_string = Some(get_localized_string::<I>);
        object.get_data_resource = Some(get_data_resource::<I>);
        object.get_data_resource_for_scale = Some(get_data_resource_for_scale::<I>);
    }
    extern "C" fn get_localized_string<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        string_id: ::std::os::raw::c_int,
        string: *mut cef_string_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_string_id, arg_string) = (self_, string_id, string);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_string_id = arg_string_id.into_raw();
        let mut arg_string = if arg_string.is_null() {
            None
        } else {
            Some(arg_string.into())
        };
        let arg_string = arg_string.as_mut();
        ImplResourceBundleHandler::localized_string(&arg_self_.interface, arg_string_id, arg_string)
    }
    extern "C" fn get_data_resource<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        resource_id: ::std::os::raw::c_int,
        data: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_resource_id, arg_data, arg_data_size) =
            (self_, resource_id, data, data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_resource_id = arg_resource_id.into_raw();
        let out_data_size = unsafe { arg_data_size.as_mut() };
        let arg_data_size = out_data_size
            .as_ref()
            .map(|size| **size)
            .unwrap_or_default();
        let out_data = (!arg_data.is_null() && arg_data_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts_mut(arg_data.cast(), arg_data_size) });
        let mut vec_data = out_data.as_ref().map(|arg| arg.to_vec());
        let arg_data = vec_data.as_mut();
        let result = ImplResourceBundleHandler::data_resource(
            &arg_self_.interface,
            arg_resource_id,
            arg_data,
        );
        if let (Some(out_data_size), Some(out_data), Some(vec_data)) =
            (out_data_size, out_data, vec_data.as_mut())
        {
            *out_data_size = vec_data.len().min(*out_data_size);
            out_data[..(*out_data_size)].copy_from_slice(&vec_data[..(*out_data_size)]);
        }
        result
    }
    extern "C" fn get_data_resource_for_scale<I: ImplResourceBundleHandler>(
        self_: *mut _cef_resource_bundle_handler_t,
        resource_id: ::std::os::raw::c_int,
        scale_factor: cef_scale_factor_t,
        data: *mut *mut ::std::os::raw::c_void,
        data_size: *mut usize,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_resource_id, arg_scale_factor, arg_data, arg_data_size) =
            (self_, resource_id, scale_factor, data, data_size);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_resource_id = arg_resource_id.into_raw();
        let arg_scale_factor = arg_scale_factor.into_raw();
        let out_data_size = unsafe { arg_data_size.as_mut() };
        let arg_data_size = out_data_size
            .as_ref()
            .map(|size| **size)
            .unwrap_or_default();
        let out_data = (!arg_data.is_null() && arg_data_size > 0)
            .then(|| unsafe { std::slice::from_raw_parts_mut(arg_data.cast(), arg_data_size) });
        let mut vec_data = out_data.as_ref().map(|arg| arg.to_vec());
        let arg_data = vec_data.as_mut();
        let result = ImplResourceBundleHandler::data_resource_for_scale(
            &arg_self_.interface,
            arg_resource_id,
            arg_scale_factor,
            arg_data,
        );
        if let (Some(out_data_size), Some(out_data), Some(vec_data)) =
            (out_data_size, out_data, vec_data.as_mut())
        {
            *out_data_size = vec_data.len().min(*out_data_size);
            out_data[..(*out_data_size)].copy_from_slice(&vec_data[..(*out_data_size)]);
        }
        result
    }
}
impl ImplResourceBundleHandler for ResourceBundleHandler {
    fn localized_string(
        &self,
        string_id: ::std::os::raw::c_int,
        string: Option<&mut CefString>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_localized_string
                .map(|f| {
                    let (arg_string_id, arg_string) = (string_id, string);
                    let arg_self_ = self.into_raw();
                    let arg_string = arg_string
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_string_id, arg_string);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn data_resource(
        &self,
        resource_id: ::std::os::raw::c_int,
        data: Option<&mut Vec<u8>>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_data_resource
                .map(|f| {
                    let (arg_resource_id, arg_data) = (resource_id, data);
                    let arg_self_ = self.into_raw();
                    let mut out_data_size =
                        arg_data.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let arg_data_size = &mut out_data_size;
                    let mut out_data = arg_data;
                    let arg_data = out_data
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_resource_id, arg_data, arg_data_size);
                    if let Some(out_data) = out_data {
                        out_data.resize(out_data_size, Default::default());
                    }
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn data_resource_for_scale(
        &self,
        resource_id: ::std::os::raw::c_int,
        scale_factor: ScaleFactor,
        data: Option<&mut Vec<u8>>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_data_resource_for_scale
                .map(|f| {
                    let (arg_resource_id, arg_scale_factor, arg_data) =
                        (resource_id, scale_factor, data);
                    let arg_self_ = self.into_raw();
                    let arg_scale_factor = arg_scale_factor.into_raw();
                    let mut out_data_size =
                        arg_data.as_ref().map(|arg| arg.len()).unwrap_or_default();
                    let arg_data_size = &mut out_data_size;
                    let mut out_data = arg_data;
                    let arg_data = out_data
                        .as_mut()
                        .and_then(|arg| {
                            if arg.is_empty() {
                                None
                            } else {
                                Some(arg.as_mut_ptr().cast())
                            }
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_resource_id,
                        arg_scale_factor,
                        arg_data,
                        arg_data_size,
                    );
                    if let Some(out_data) = out_data {
                        out_data.resize(out_data_size, Default::default());
                    }
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_resource_bundle_handler_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_resource_bundle_handler_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ResourceBundleHandler {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_resource_bundle_handler_t> for &ResourceBundleHandler {
    fn into_raw(self) -> *mut _cef_resource_bundle_handler_t {
        ImplResourceBundleHandler::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_resource_bundle_handler_t> for &mut ResourceBundleHandler {
    fn into_raw(self) -> *mut _cef_resource_bundle_handler_t {
        ImplResourceBundleHandler::get_raw(self)
    }
}
impl ConvertReturnValue<ResourceBundleHandler> for *mut _cef_resource_bundle_handler_t {
    fn wrap_result(self) -> ResourceBundleHandler {
        ResourceBundleHandler(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ResourceBundleHandler> for *mut _cef_resource_bundle_handler_t {
    fn from(value: ResourceBundleHandler) -> Self {
        let object = ImplResourceBundleHandler::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ResourceBundleHandler {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_scheme_registrar_t`] for more documentation.
#[derive(Clone, Copy)]
pub struct SchemeRegistrar(*mut _cef_scheme_registrar_t);
pub trait ImplSchemeRegistrar: Sized {
    #[doc = "See [`_cef_scheme_registrar_t::add_custom_scheme`] for more documentation."]
    fn add_custom_scheme(
        &self,
        scheme_name: Option<&CefString>,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    fn init_methods(object: &mut _cef_scheme_registrar_t) {
        impl_cef_scheme_registrar_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_scheme_registrar_t;
}
mod impl_cef_scheme_registrar_t {
    use super::*;
    pub fn init_methods<I: ImplSchemeRegistrar>(object: &mut _cef_scheme_registrar_t) {
        object.add_custom_scheme = Some(add_custom_scheme::<I>);
    }
    extern "C" fn add_custom_scheme<I: ImplSchemeRegistrar>(
        self_: *mut _cef_scheme_registrar_t,
        scheme_name: *const cef_string_t,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_scheme_name, arg_options) = (self_, scheme_name, options);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_scheme_name = if arg_scheme_name.is_null() {
            None
        } else {
            Some(arg_scheme_name.into())
        };
        let arg_scheme_name = arg_scheme_name.as_ref();
        let arg_options = arg_options.into_raw();
        ImplSchemeRegistrar::add_custom_scheme(&arg_self_.interface, arg_scheme_name, arg_options)
    }
}
impl ImplSchemeRegistrar for SchemeRegistrar {
    fn add_custom_scheme(
        &self,
        scheme_name: Option<&CefString>,
        options: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .as_ref()
                .and_then(|this| this.add_custom_scheme)
                .map(|f| {
                    let (arg_scheme_name, arg_options) = (scheme_name, options);
                    let arg_self_ = self.into_raw();
                    let arg_scheme_name = arg_scheme_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_scheme_name, arg_options);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_scheme_registrar_t {
        self.0
    }
}
impl ConvertParam<*mut _cef_scheme_registrar_t> for &SchemeRegistrar {
    fn into_raw(self) -> *mut _cef_scheme_registrar_t {
        ImplSchemeRegistrar::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_scheme_registrar_t> for &mut SchemeRegistrar {
    fn into_raw(self) -> *mut _cef_scheme_registrar_t {
        ImplSchemeRegistrar::get_raw(self)
    }
}
impl ConvertReturnValue<SchemeRegistrar> for *mut _cef_scheme_registrar_t {
    fn wrap_result(self) -> SchemeRegistrar {
        SchemeRegistrar(self)
    }
}
impl From<SchemeRegistrar> for *mut _cef_scheme_registrar_t {
    fn from(value: SchemeRegistrar) -> Self {
        ImplSchemeRegistrar::get_raw(&value)
    }
}
impl Default for SchemeRegistrar {
    fn default() -> Self {
        Self(std::ptr::null_mut())
    }
}

/// See [`_cef_scheme_handler_factory_t`] for more documentation.
#[derive(Clone)]
pub struct SchemeHandlerFactory(RefGuard<_cef_scheme_handler_factory_t>);
impl SchemeHandlerFactory {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapSchemeHandlerFactory,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplSchemeHandlerFactory>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapSchemeHandlerFactory>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_scheme_handler_factory_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapSchemeHandlerFactory: ImplSchemeHandlerFactory {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_scheme_handler_factory_t, Self>);
}
pub trait ImplSchemeHandlerFactory: Clone + Sized + Rc {
    #[doc = "See [`_cef_scheme_handler_factory_t::create`] for more documentation."]
    fn create(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        scheme_name: Option<&CefString>,
        request: Option<&mut Request>,
    ) -> Option<ResourceHandler> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_scheme_handler_factory_t) {
        impl_cef_scheme_handler_factory_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_scheme_handler_factory_t;
}
mod impl_cef_scheme_handler_factory_t {
    use super::*;
    pub fn init_methods<I: ImplSchemeHandlerFactory>(object: &mut _cef_scheme_handler_factory_t) {
        object.create = Some(create::<I>);
    }
    extern "C" fn create<I: ImplSchemeHandlerFactory>(
        self_: *mut _cef_scheme_handler_factory_t,
        browser: *mut _cef_browser_t,
        frame: *mut _cef_frame_t,
        scheme_name: *const cef_string_t,
        request: *mut _cef_request_t,
    ) -> *mut _cef_resource_handler_t {
        let (arg_self_, arg_browser, arg_frame, arg_scheme_name, arg_request) =
            (self_, browser, frame, scheme_name, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        let mut arg_frame =
            unsafe { arg_frame.as_mut() }.map(|arg| Frame(unsafe { RefGuard::from_raw(arg) }));
        let arg_frame = arg_frame.as_mut();
        let arg_scheme_name = if arg_scheme_name.is_null() {
            None
        } else {
            Some(arg_scheme_name.into())
        };
        let arg_scheme_name = arg_scheme_name.as_ref();
        let mut arg_request =
            unsafe { arg_request.as_mut() }.map(|arg| Request(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let result = ImplSchemeHandlerFactory::create(
            &arg_self_.interface,
            arg_browser,
            arg_frame,
            arg_scheme_name,
            arg_request,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplSchemeHandlerFactory for SchemeHandlerFactory {
    fn create(
        &self,
        browser: Option<&mut Browser>,
        frame: Option<&mut Frame>,
        scheme_name: Option<&CefString>,
        request: Option<&mut Request>,
    ) -> Option<ResourceHandler> {
        unsafe {
            self.0
                .create
                .map(|f| {
                    let (arg_browser, arg_frame, arg_scheme_name, arg_request) =
                        (browser, frame, scheme_name, request);
                    let arg_self_ = self.into_raw();
                    let arg_browser = arg_browser
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowser::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_frame = arg_frame
                        .map(|arg| {
                            arg.add_ref();
                            ImplFrame::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_scheme_name = arg_scheme_name
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_request = arg_request
                        .map(|arg| {
                            arg.add_ref();
                            ImplRequest::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser,
                        arg_frame,
                        arg_scheme_name,
                        arg_request,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_scheme_handler_factory_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_scheme_handler_factory_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for SchemeHandlerFactory {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_scheme_handler_factory_t> for &SchemeHandlerFactory {
    fn into_raw(self) -> *mut _cef_scheme_handler_factory_t {
        ImplSchemeHandlerFactory::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_scheme_handler_factory_t> for &mut SchemeHandlerFactory {
    fn into_raw(self) -> *mut _cef_scheme_handler_factory_t {
        ImplSchemeHandlerFactory::get_raw(self)
    }
}
impl ConvertReturnValue<SchemeHandlerFactory> for *mut _cef_scheme_handler_factory_t {
    fn wrap_result(self) -> SchemeHandlerFactory {
        SchemeHandlerFactory(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<SchemeHandlerFactory> for *mut _cef_scheme_handler_factory_t {
    fn from(value: SchemeHandlerFactory) -> Self {
        let object = ImplSchemeHandlerFactory::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for SchemeHandlerFactory {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_app_t`] for more documentation.
#[derive(Clone)]
pub struct App(RefGuard<_cef_app_t>);
impl App {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapApp,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplApp>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapApp>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_app_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapApp: ImplApp {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_app_t, Self>);
}
pub trait ImplApp: Clone + Sized + Rc {
    #[doc = "See [`_cef_app_t::on_before_command_line_processing`] for more documentation."]
    fn on_before_command_line_processing(
        &self,
        process_type: Option<&CefString>,
        command_line: Option<&mut CommandLine>,
    ) {
    }
    #[doc = "See [`_cef_app_t::on_register_custom_schemes`] for more documentation."]
    fn on_register_custom_schemes(&self, registrar: Option<&mut SchemeRegistrar>) {}
    #[doc = "See [`_cef_app_t::get_resource_bundle_handler`] for more documentation."]
    fn resource_bundle_handler(&self) -> Option<ResourceBundleHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_app_t::get_browser_process_handler`] for more documentation."]
    fn browser_process_handler(&self) -> Option<BrowserProcessHandler> {
        Default::default()
    }
    #[doc = "See [`_cef_app_t::get_render_process_handler`] for more documentation."]
    fn render_process_handler(&self) -> Option<RenderProcessHandler> {
        Default::default()
    }
    fn init_methods(object: &mut _cef_app_t) {
        impl_cef_app_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_app_t;
}
mod impl_cef_app_t {
    use super::*;
    pub fn init_methods<I: ImplApp>(object: &mut _cef_app_t) {
        object.on_before_command_line_processing = Some(on_before_command_line_processing::<I>);
        object.on_register_custom_schemes = Some(on_register_custom_schemes::<I>);
        object.get_resource_bundle_handler = Some(get_resource_bundle_handler::<I>);
        object.get_browser_process_handler = Some(get_browser_process_handler::<I>);
        object.get_render_process_handler = Some(get_render_process_handler::<I>);
    }
    extern "C" fn on_before_command_line_processing<I: ImplApp>(
        self_: *mut _cef_app_t,
        process_type: *const cef_string_t,
        command_line: *mut _cef_command_line_t,
    ) {
        let (arg_self_, arg_process_type, arg_command_line) = (self_, process_type, command_line);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_process_type = if arg_process_type.is_null() {
            None
        } else {
            Some(arg_process_type.into())
        };
        let arg_process_type = arg_process_type.as_ref();
        let mut arg_command_line = unsafe { arg_command_line.as_mut() }
            .map(|arg| CommandLine(unsafe { RefGuard::from_raw(arg) }));
        let arg_command_line = arg_command_line.as_mut();
        ImplApp::on_before_command_line_processing(
            &arg_self_.interface,
            arg_process_type,
            arg_command_line,
        )
    }
    extern "C" fn on_register_custom_schemes<I: ImplApp>(
        self_: *mut _cef_app_t,
        registrar: *mut _cef_scheme_registrar_t,
    ) {
        let (arg_self_, arg_registrar) = (self_, registrar);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_registrar = if arg_registrar.is_null() {
            None
        } else {
            Some(SchemeRegistrar(arg_registrar))
        };
        let arg_registrar = arg_registrar.as_mut();
        ImplApp::on_register_custom_schemes(&arg_self_.interface, arg_registrar)
    }
    extern "C" fn get_resource_bundle_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_resource_bundle_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplApp::resource_bundle_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_browser_process_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_browser_process_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplApp::browser_process_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn get_render_process_handler<I: ImplApp>(
        self_: *mut _cef_app_t,
    ) -> *mut _cef_render_process_handler_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplApp::render_process_handler(&arg_self_.interface);
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
}
impl ImplApp for App {
    fn on_before_command_line_processing(
        &self,
        process_type: Option<&CefString>,
        command_line: Option<&mut CommandLine>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_before_command_line_processing {
                let (arg_process_type, arg_command_line) = (process_type, command_line);
                let arg_self_ = self.into_raw();
                let arg_process_type = arg_process_type
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                let arg_command_line = arg_command_line
                    .map(|arg| {
                        arg.add_ref();
                        ImplCommandLine::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_process_type, arg_command_line);
            }
        }
    }
    fn on_register_custom_schemes(&self, registrar: Option<&mut SchemeRegistrar>) {
        unsafe {
            if let Some(f) = self.0.on_register_custom_schemes {
                let arg_registrar = registrar;
                let arg_self_ = self.into_raw();
                let arg_registrar = arg_registrar
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_registrar);
            }
        }
    }
    fn resource_bundle_handler(&self) -> Option<ResourceBundleHandler> {
        unsafe {
            self.0
                .get_resource_bundle_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn browser_process_handler(&self) -> Option<BrowserProcessHandler> {
        unsafe {
            self.0
                .get_browser_process_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn render_process_handler(&self) -> Option<RenderProcessHandler> {
        unsafe {
            self.0
                .get_render_process_handler
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_app_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_app_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for App {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_app_t> for &App {
    fn into_raw(self) -> *mut _cef_app_t {
        ImplApp::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_app_t> for &mut App {
    fn into_raw(self) -> *mut _cef_app_t {
        ImplApp::get_raw(self)
    }
}
impl ConvertReturnValue<App> for *mut _cef_app_t {
    fn wrap_result(self) -> App {
        App(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<App> for *mut _cef_app_t {
    fn from(value: App) -> Self {
        let object = ImplApp::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for App {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_urlrequest_t`] for more documentation.
#[derive(Clone)]
pub struct Urlrequest(RefGuard<_cef_urlrequest_t>);
pub trait ImplUrlrequest: Clone + Sized + Rc {
    #[doc = "See [`_cef_urlrequest_t::get_request`] for more documentation."]
    fn request(&self) -> Option<Request>;
    #[doc = "See [`_cef_urlrequest_t::get_client`] for more documentation."]
    fn client(&self) -> Option<UrlrequestClient>;
    #[doc = "See [`_cef_urlrequest_t::get_request_status`] for more documentation."]
    fn request_status(&self) -> UrlrequestStatus;
    #[doc = "See [`_cef_urlrequest_t::get_request_error`] for more documentation."]
    fn request_error(&self) -> Errorcode;
    #[doc = "See [`_cef_urlrequest_t::get_response`] for more documentation."]
    fn response(&self) -> Option<Response>;
    #[doc = "See [`_cef_urlrequest_t::response_was_cached`] for more documentation."]
    fn response_was_cached(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_urlrequest_t::cancel`] for more documentation."]
    fn cancel(&self);
    fn get_raw(&self) -> *mut _cef_urlrequest_t;
}
impl ImplUrlrequest for Urlrequest {
    fn request(&self) -> Option<Request> {
        unsafe {
            self.0
                .get_request
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn client(&self) -> Option<UrlrequestClient> {
        unsafe {
            self.0
                .get_client
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn request_status(&self) -> UrlrequestStatus {
        unsafe {
            self.0
                .get_request_status
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn request_error(&self) -> Errorcode {
        unsafe {
            self.0
                .get_request_error
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn response(&self) -> Option<Response> {
        unsafe {
            self.0
                .get_response
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn response_was_cached(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .response_was_cached
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn cancel(&self) {
        unsafe {
            if let Some(f) = self.0.cancel {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_urlrequest_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_urlrequest_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Urlrequest {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_urlrequest_t> for &Urlrequest {
    fn into_raw(self) -> *mut _cef_urlrequest_t {
        ImplUrlrequest::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_urlrequest_t> for &mut Urlrequest {
    fn into_raw(self) -> *mut _cef_urlrequest_t {
        ImplUrlrequest::get_raw(self)
    }
}
impl ConvertReturnValue<Urlrequest> for *mut _cef_urlrequest_t {
    fn wrap_result(self) -> Urlrequest {
        Urlrequest(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Urlrequest> for *mut _cef_urlrequest_t {
    fn from(value: Urlrequest) -> Self {
        let object = ImplUrlrequest::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Urlrequest {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_urlrequest_client_t`] for more documentation.
#[derive(Clone)]
pub struct UrlrequestClient(RefGuard<_cef_urlrequest_client_t>);
impl UrlrequestClient {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapUrlrequestClient,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplUrlrequestClient>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapUrlrequestClient>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_urlrequest_client_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapUrlrequestClient: ImplUrlrequestClient {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_urlrequest_client_t, Self>);
}
pub trait ImplUrlrequestClient: Clone + Sized + Rc {
    #[doc = "See [`_cef_urlrequest_client_t::on_request_complete`] for more documentation."]
    fn on_request_complete(&self, request: Option<&mut Urlrequest>) {}
    #[doc = "See [`_cef_urlrequest_client_t::on_upload_progress`] for more documentation."]
    fn on_upload_progress(&self, request: Option<&mut Urlrequest>, current: i64, total: i64) {}
    #[doc = "See [`_cef_urlrequest_client_t::on_download_progress`] for more documentation."]
    fn on_download_progress(&self, request: Option<&mut Urlrequest>, current: i64, total: i64) {}
    #[doc = "See [`_cef_urlrequest_client_t::on_download_data`] for more documentation."]
    fn on_download_data(
        &self,
        request: Option<&mut Urlrequest>,
        data: *const u8,
        data_length: usize,
    ) {
    }
    #[doc = "See [`_cef_urlrequest_client_t::get_auth_credentials`] for more documentation."]
    fn auth_credentials(
        &self,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefString>,
        port: ::std::os::raw::c_int,
        realm: Option<&CefString>,
        scheme: Option<&CefString>,
        callback: Option<&mut AuthCallback>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_urlrequest_client_t) {
        impl_cef_urlrequest_client_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_urlrequest_client_t;
}
mod impl_cef_urlrequest_client_t {
    use super::*;
    pub fn init_methods<I: ImplUrlrequestClient>(object: &mut _cef_urlrequest_client_t) {
        object.on_request_complete = Some(on_request_complete::<I>);
        object.on_upload_progress = Some(on_upload_progress::<I>);
        object.on_download_progress = Some(on_download_progress::<I>);
        object.on_download_data = Some(on_download_data::<I>);
        object.get_auth_credentials = Some(get_auth_credentials::<I>);
    }
    extern "C" fn on_request_complete<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
    ) {
        let (arg_self_, arg_request) = (self_, request);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request = unsafe { arg_request.as_mut() }
            .map(|arg| Urlrequest(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        ImplUrlrequestClient::on_request_complete(&arg_self_.interface, arg_request)
    }
    extern "C" fn on_upload_progress<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        current: i64,
        total: i64,
    ) {
        let (arg_self_, arg_request, arg_current, arg_total) = (self_, request, current, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request = unsafe { arg_request.as_mut() }
            .map(|arg| Urlrequest(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_current = arg_current.into_raw();
        let arg_total = arg_total.into_raw();
        ImplUrlrequestClient::on_upload_progress(
            &arg_self_.interface,
            arg_request,
            arg_current,
            arg_total,
        )
    }
    extern "C" fn on_download_progress<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        current: i64,
        total: i64,
    ) {
        let (arg_self_, arg_request, arg_current, arg_total) = (self_, request, current, total);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request = unsafe { arg_request.as_mut() }
            .map(|arg| Urlrequest(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_current = arg_current.into_raw();
        let arg_total = arg_total.into_raw();
        ImplUrlrequestClient::on_download_progress(
            &arg_self_.interface,
            arg_request,
            arg_current,
            arg_total,
        )
    }
    extern "C" fn on_download_data<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        request: *mut _cef_urlrequest_t,
        data: *const ::std::os::raw::c_void,
        data_length: usize,
    ) {
        let (arg_self_, arg_request, arg_data, arg_data_length) =
            (self_, request, data, data_length);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_request = unsafe { arg_request.as_mut() }
            .map(|arg| Urlrequest(unsafe { RefGuard::from_raw(arg) }));
        let arg_request = arg_request.as_mut();
        let arg_data = arg_data.cast();
        let arg_data_length = arg_data_length.into_raw();
        ImplUrlrequestClient::on_download_data(
            &arg_self_.interface,
            arg_request,
            arg_data,
            arg_data_length,
        )
    }
    extern "C" fn get_auth_credentials<I: ImplUrlrequestClient>(
        self_: *mut _cef_urlrequest_client_t,
        is_proxy: ::std::os::raw::c_int,
        host: *const cef_string_t,
        port: ::std::os::raw::c_int,
        realm: *const cef_string_t,
        scheme: *const cef_string_t,
        callback: *mut _cef_auth_callback_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_is_proxy, arg_host, arg_port, arg_realm, arg_scheme, arg_callback) =
            (self_, is_proxy, host, port, realm, scheme, callback);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let arg_is_proxy = arg_is_proxy.into_raw();
        let arg_host = if arg_host.is_null() {
            None
        } else {
            Some(arg_host.into())
        };
        let arg_host = arg_host.as_ref();
        let arg_port = arg_port.into_raw();
        let arg_realm = if arg_realm.is_null() {
            None
        } else {
            Some(arg_realm.into())
        };
        let arg_realm = arg_realm.as_ref();
        let arg_scheme = if arg_scheme.is_null() {
            None
        } else {
            Some(arg_scheme.into())
        };
        let arg_scheme = arg_scheme.as_ref();
        let mut arg_callback = unsafe { arg_callback.as_mut() }
            .map(|arg| AuthCallback(unsafe { RefGuard::from_raw(arg) }));
        let arg_callback = arg_callback.as_mut();
        ImplUrlrequestClient::auth_credentials(
            &arg_self_.interface,
            arg_is_proxy,
            arg_host,
            arg_port,
            arg_realm,
            arg_scheme,
            arg_callback,
        )
    }
}
impl ImplUrlrequestClient for UrlrequestClient {
    fn on_request_complete(&self, request: Option<&mut Urlrequest>) {
        unsafe {
            if let Some(f) = self.0.on_request_complete {
                let arg_request = request;
                let arg_self_ = self.into_raw();
                let arg_request = arg_request
                    .map(|arg| {
                        arg.add_ref();
                        ImplUrlrequest::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_request);
            }
        }
    }
    fn on_upload_progress(&self, request: Option<&mut Urlrequest>, current: i64, total: i64) {
        unsafe {
            if let Some(f) = self.0.on_upload_progress {
                let (arg_request, arg_current, arg_total) = (request, current, total);
                let arg_self_ = self.into_raw();
                let arg_request = arg_request
                    .map(|arg| {
                        arg.add_ref();
                        ImplUrlrequest::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_request, arg_current, arg_total);
            }
        }
    }
    fn on_download_progress(&self, request: Option<&mut Urlrequest>, current: i64, total: i64) {
        unsafe {
            if let Some(f) = self.0.on_download_progress {
                let (arg_request, arg_current, arg_total) = (request, current, total);
                let arg_self_ = self.into_raw();
                let arg_request = arg_request
                    .map(|arg| {
                        arg.add_ref();
                        ImplUrlrequest::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_request, arg_current, arg_total);
            }
        }
    }
    fn on_download_data(
        &self,
        request: Option<&mut Urlrequest>,
        data: *const u8,
        data_length: usize,
    ) {
        unsafe {
            if let Some(f) = self.0.on_download_data {
                let (arg_request, arg_data, arg_data_length) = (request, data, data_length);
                let arg_self_ = self.into_raw();
                let arg_request = arg_request
                    .map(|arg| {
                        arg.add_ref();
                        ImplUrlrequest::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_data = arg_data.cast();
                f(arg_self_, arg_request, arg_data, arg_data_length);
            }
        }
    }
    fn auth_credentials(
        &self,
        is_proxy: ::std::os::raw::c_int,
        host: Option<&CefString>,
        port: ::std::os::raw::c_int,
        realm: Option<&CefString>,
        scheme: Option<&CefString>,
        callback: Option<&mut AuthCallback>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_auth_credentials
                .map(|f| {
                    let (arg_is_proxy, arg_host, arg_port, arg_realm, arg_scheme, arg_callback) =
                        (is_proxy, host, port, realm, scheme, callback);
                    let arg_self_ = self.into_raw();
                    let arg_host = arg_host
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_realm = arg_realm
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_scheme = arg_scheme
                        .map(|arg| arg.into_raw())
                        .unwrap_or(std::ptr::null());
                    let arg_callback = arg_callback
                        .map(|arg| {
                            arg.add_ref();
                            ImplAuthCallback::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_is_proxy,
                        arg_host,
                        arg_port,
                        arg_realm,
                        arg_scheme,
                        arg_callback,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_urlrequest_client_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_urlrequest_client_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for UrlrequestClient {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_urlrequest_client_t> for &UrlrequestClient {
    fn into_raw(self) -> *mut _cef_urlrequest_client_t {
        ImplUrlrequestClient::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_urlrequest_client_t> for &mut UrlrequestClient {
    fn into_raw(self) -> *mut _cef_urlrequest_client_t {
        ImplUrlrequestClient::get_raw(self)
    }
}
impl ConvertReturnValue<UrlrequestClient> for *mut _cef_urlrequest_client_t {
    fn wrap_result(self) -> UrlrequestClient {
        UrlrequestClient(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<UrlrequestClient> for *mut _cef_urlrequest_client_t {
    fn from(value: UrlrequestClient) -> Self {
        let object = ImplUrlrequestClient::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for UrlrequestClient {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_layout_t`] for more documentation.
#[derive(Clone)]
pub struct Layout(RefGuard<_cef_layout_t>);
pub trait ImplLayout: Clone + Sized + Rc {
    #[doc = "See [`_cef_layout_t::as_box_layout`] for more documentation."]
    fn as_box_layout(&self) -> Option<BoxLayout>;
    #[doc = "See [`_cef_layout_t::as_fill_layout`] for more documentation."]
    fn as_fill_layout(&self) -> Option<FillLayout>;
    #[doc = "See [`_cef_layout_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_layout_t;
}
impl ImplLayout for Layout {
    fn as_box_layout(&self) -> Option<BoxLayout> {
        unsafe {
            self.0
                .as_box_layout
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_fill_layout(&self) -> Option<FillLayout> {
        unsafe {
            self.0
                .as_fill_layout
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_layout_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Layout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_layout_t> for &Layout {
    fn into_raw(self) -> *mut _cef_layout_t {
        ImplLayout::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_layout_t> for &mut Layout {
    fn into_raw(self) -> *mut _cef_layout_t {
        ImplLayout::get_raw(self)
    }
}
impl ConvertReturnValue<Layout> for *mut _cef_layout_t {
    fn wrap_result(self) -> Layout {
        Layout(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Layout> for *mut _cef_layout_t {
    fn from(value: Layout) -> Self {
        let object = ImplLayout::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Layout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_box_layout_t`] for more documentation.
#[derive(Clone)]
pub struct BoxLayout(RefGuard<_cef_box_layout_t>);
pub trait ImplBoxLayout: ImplLayout {
    #[doc = "See [`_cef_box_layout_t::set_flex_for_view`] for more documentation."]
    fn set_flex_for_view(&self, view: Option<&mut View>, flex: ::std::os::raw::c_int);
    #[doc = "See [`_cef_box_layout_t::clear_flex_for_view`] for more documentation."]
    fn clear_flex_for_view(&self, view: Option<&mut View>);
    fn get_raw(&self) -> *mut _cef_box_layout_t {
        <Self as ImplLayout>::get_raw(self).cast()
    }
}
impl ImplLayout for BoxLayout {
    fn as_box_layout(&self) -> Option<BoxLayout> {
        Layout::from(self).as_box_layout()
    }
    fn as_fill_layout(&self) -> Option<FillLayout> {
        Layout::from(self).as_fill_layout()
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Layout::from(self).is_valid()
    }
    fn get_raw(&self) -> *mut _cef_layout_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&BoxLayout> for Layout {
    fn from(from: &BoxLayout) -> Self {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplBoxLayout for BoxLayout {
    fn set_flex_for_view(&self, view: Option<&mut View>, flex: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_flex_for_view {
                let (arg_view, arg_flex) = (view, flex);
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view, arg_flex);
            }
        }
    }
    fn clear_flex_for_view(&self, view: Option<&mut View>) {
        unsafe {
            if let Some(f) = self.0.clear_flex_for_view {
                let arg_view = view;
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_box_layout_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_box_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BoxLayout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_box_layout_t> for &BoxLayout {
    fn into_raw(self) -> *mut _cef_box_layout_t {
        ImplBoxLayout::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_box_layout_t> for &mut BoxLayout {
    fn into_raw(self) -> *mut _cef_box_layout_t {
        ImplBoxLayout::get_raw(self)
    }
}
impl ConvertReturnValue<BoxLayout> for *mut _cef_box_layout_t {
    fn wrap_result(self) -> BoxLayout {
        BoxLayout(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<BoxLayout> for *mut _cef_box_layout_t {
    fn from(value: BoxLayout) -> Self {
        let object = ImplBoxLayout::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for BoxLayout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_fill_layout_t`] for more documentation.
#[derive(Clone)]
pub struct FillLayout(RefGuard<_cef_fill_layout_t>);
pub trait ImplFillLayout: ImplLayout {
    fn get_raw(&self) -> *mut _cef_fill_layout_t {
        <Self as ImplLayout>::get_raw(self).cast()
    }
}
impl ImplLayout for FillLayout {
    fn as_box_layout(&self) -> Option<BoxLayout> {
        Layout::from(self).as_box_layout()
    }
    fn as_fill_layout(&self) -> Option<FillLayout> {
        Layout::from(self).as_fill_layout()
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        Layout::from(self).is_valid()
    }
    fn get_raw(&self) -> *mut _cef_layout_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&FillLayout> for Layout {
    fn from(from: &FillLayout) -> Self {
        Layout(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplFillLayout for FillLayout {
    fn get_raw(&self) -> *mut _cef_fill_layout_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_fill_layout_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for FillLayout {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_fill_layout_t> for &FillLayout {
    fn into_raw(self) -> *mut _cef_fill_layout_t {
        ImplFillLayout::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_fill_layout_t> for &mut FillLayout {
    fn into_raw(self) -> *mut _cef_fill_layout_t {
        ImplFillLayout::get_raw(self)
    }
}
impl ConvertReturnValue<FillLayout> for *mut _cef_fill_layout_t {
    fn wrap_result(self) -> FillLayout {
        FillLayout(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<FillLayout> for *mut _cef_fill_layout_t {
    fn from(value: FillLayout) -> Self {
        let object = ImplFillLayout::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for FillLayout {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_view_delegate_t`] for more documentation.
#[derive(Clone)]
pub struct ViewDelegate(RefGuard<_cef_view_delegate_t>);
impl ViewDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapViewDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplViewDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapViewDelegate>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_view_delegate_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapViewDelegate: ImplViewDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_view_delegate_t, Self>);
}
pub trait ImplViewDelegate: Clone + Sized + Rc {
    #[doc = "See [`_cef_view_delegate_t::get_preferred_size`] for more documentation."]
    fn preferred_size(&self, view: Option<&mut View>) -> Size {
        Default::default()
    }
    #[doc = "See [`_cef_view_delegate_t::get_minimum_size`] for more documentation."]
    fn minimum_size(&self, view: Option<&mut View>) -> Size {
        Default::default()
    }
    #[doc = "See [`_cef_view_delegate_t::get_maximum_size`] for more documentation."]
    fn maximum_size(&self, view: Option<&mut View>) -> Size {
        Default::default()
    }
    #[doc = "See [`_cef_view_delegate_t::get_height_for_width`] for more documentation."]
    fn height_for_width(
        &self,
        view: Option<&mut View>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_view_delegate_t::on_parent_view_changed`] for more documentation."]
    fn on_parent_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut View>,
    ) {
    }
    #[doc = "See [`_cef_view_delegate_t::on_child_view_changed`] for more documentation."]
    fn on_child_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        child: Option<&mut View>,
    ) {
    }
    #[doc = "See [`_cef_view_delegate_t::on_window_changed`] for more documentation."]
    fn on_window_changed(&self, view: Option<&mut View>, added: ::std::os::raw::c_int) {}
    #[doc = "See [`_cef_view_delegate_t::on_layout_changed`] for more documentation."]
    fn on_layout_changed(&self, view: Option<&mut View>, new_bounds: Option<&Rect>) {}
    #[doc = "See [`_cef_view_delegate_t::on_focus`] for more documentation."]
    fn on_focus(&self, view: Option<&mut View>) {}
    #[doc = "See [`_cef_view_delegate_t::on_blur`] for more documentation."]
    fn on_blur(&self, view: Option<&mut View>) {}
    #[doc = "See [`_cef_view_delegate_t::on_theme_changed`] for more documentation."]
    fn on_theme_changed(&self, view: Option<&mut View>) {}
    fn init_methods(object: &mut _cef_view_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t;
}
mod impl_cef_view_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplViewDelegate>(object: &mut _cef_view_delegate_t) {
        object.get_preferred_size = Some(get_preferred_size::<I>);
        object.get_minimum_size = Some(get_minimum_size::<I>);
        object.get_maximum_size = Some(get_maximum_size::<I>);
        object.get_height_for_width = Some(get_height_for_width::<I>);
        object.on_parent_view_changed = Some(on_parent_view_changed::<I>);
        object.on_child_view_changed = Some(on_child_view_changed::<I>);
        object.on_window_changed = Some(on_window_changed::<I>);
        object.on_layout_changed = Some(on_layout_changed::<I>);
        object.on_focus = Some(on_focus::<I>);
        object.on_blur = Some(on_blur::<I>);
        object.on_theme_changed = Some(on_theme_changed::<I>);
    }
    extern "C" fn get_preferred_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::preferred_size(&arg_self_.interface, arg_view);
        result.into()
    }
    extern "C" fn get_minimum_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::minimum_size(&arg_self_.interface, arg_view);
        result.into()
    }
    extern "C" fn get_maximum_size<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) -> _cef_size_t {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let result = ImplViewDelegate::maximum_size(&arg_self_.interface, arg_view);
        result.into()
    }
    extern "C" fn get_height_for_width<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_view, arg_width) = (self_, view, width);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_width = arg_width.into_raw();
        ImplViewDelegate::height_for_width(&arg_self_.interface, arg_view, arg_width)
    }
    extern "C" fn on_parent_view_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
        parent: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view, arg_added, arg_parent) = (self_, view, added, parent);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_added = arg_added.into_raw();
        let mut arg_parent =
            unsafe { arg_parent.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_parent = arg_parent.as_mut();
        ImplViewDelegate::on_parent_view_changed(
            &arg_self_.interface,
            arg_view,
            arg_added,
            arg_parent,
        )
    }
    extern "C" fn on_child_view_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
        child: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view, arg_added, arg_child) = (self_, view, added, child);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_added = arg_added.into_raw();
        let mut arg_child =
            unsafe { arg_child.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_child = arg_child.as_mut();
        ImplViewDelegate::on_child_view_changed(
            &arg_self_.interface,
            arg_view,
            arg_added,
            arg_child,
        )
    }
    extern "C" fn on_window_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        added: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_view, arg_added) = (self_, view, added);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_added = arg_added.into_raw();
        ImplViewDelegate::on_window_changed(&arg_self_.interface, arg_view, arg_added)
    }
    extern "C" fn on_layout_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
        new_bounds: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_view, arg_new_bounds) = (self_, view, new_bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        let arg_new_bounds = if arg_new_bounds.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_new_bounds))
        };
        let arg_new_bounds = arg_new_bounds.as_ref().map(|arg| arg.as_ref());
        ImplViewDelegate::on_layout_changed(&arg_self_.interface, arg_view, arg_new_bounds)
    }
    extern "C" fn on_focus<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        ImplViewDelegate::on_focus(&arg_self_.interface, arg_view)
    }
    extern "C" fn on_blur<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        ImplViewDelegate::on_blur(&arg_self_.interface, arg_view)
    }
    extern "C" fn on_theme_changed<I: ImplViewDelegate>(
        self_: *mut _cef_view_delegate_t,
        view: *mut _cef_view_t,
    ) {
        let (arg_self_, arg_view) = (self_, view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_view =
            unsafe { arg_view.as_mut() }.map(|arg| View(unsafe { RefGuard::from_raw(arg) }));
        let arg_view = arg_view.as_mut();
        ImplViewDelegate::on_theme_changed(&arg_self_.interface, arg_view)
    }
}
impl ImplViewDelegate for ViewDelegate {
    fn preferred_size(&self, view: Option<&mut View>) -> Size {
        unsafe {
            self.0
                .get_preferred_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.into_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn minimum_size(&self, view: Option<&mut View>) -> Size {
        unsafe {
            self.0
                .get_minimum_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.into_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn maximum_size(&self, view: Option<&mut View>) -> Size {
        unsafe {
            self.0
                .get_maximum_size
                .map(|f| {
                    let arg_view = view;
                    let arg_self_ = self.into_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn height_for_width(
        &self,
        view: Option<&mut View>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_height_for_width
                .map(|f| {
                    let (arg_view, arg_width) = (view, width);
                    let arg_self_ = self.into_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view, arg_width);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut View>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_parent_view_changed {
                let (arg_view, arg_added, arg_parent) = (view, added, parent);
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_parent = arg_parent
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view, arg_added, arg_parent);
            }
        }
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        child: Option<&mut View>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_child_view_changed {
                let (arg_view, arg_added, arg_child) = (view, added, child);
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_child = arg_child
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view, arg_added, arg_child);
            }
        }
    }
    fn on_window_changed(&self, view: Option<&mut View>, added: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.on_window_changed {
                let (arg_view, arg_added) = (view, added);
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view, arg_added);
            }
        }
    }
    fn on_layout_changed(&self, view: Option<&mut View>, new_bounds: Option<&Rect>) {
        unsafe {
            if let Some(f) = self.0.on_layout_changed {
                let (arg_view, arg_new_bounds) = (view, new_bounds);
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_new_bounds = arg_new_bounds.cloned().map(|arg| arg.into());
                let arg_new_bounds = arg_new_bounds
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_view, arg_new_bounds);
            }
        }
    }
    fn on_focus(&self, view: Option<&mut View>) {
        unsafe {
            if let Some(f) = self.0.on_focus {
                let arg_view = view;
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view);
            }
        }
    }
    fn on_blur(&self, view: Option<&mut View>) {
        unsafe {
            if let Some(f) = self.0.on_blur {
                let arg_view = view;
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view);
            }
        }
    }
    fn on_theme_changed(&self, view: Option<&mut View>) {
        unsafe {
            if let Some(f) = self.0.on_theme_changed {
                let arg_view = view;
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_view_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ViewDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_view_delegate_t> for &ViewDelegate {
    fn into_raw(self) -> *mut _cef_view_delegate_t {
        ImplViewDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_view_delegate_t> for &mut ViewDelegate {
    fn into_raw(self) -> *mut _cef_view_delegate_t {
        ImplViewDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<ViewDelegate> for *mut _cef_view_delegate_t {
    fn wrap_result(self) -> ViewDelegate {
        ViewDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ViewDelegate> for *mut _cef_view_delegate_t {
    fn from(value: ViewDelegate) -> Self {
        let object = ImplViewDelegate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ViewDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_view_t`] for more documentation.
#[derive(Clone)]
pub struct View(RefGuard<_cef_view_t>);
pub trait ImplView: Clone + Sized + Rc {
    #[doc = "See [`_cef_view_t::as_browser_view`] for more documentation."]
    fn as_browser_view(&self) -> Option<BrowserView>;
    #[doc = "See [`_cef_view_t::as_button`] for more documentation."]
    fn as_button(&self) -> Option<Button>;
    #[doc = "See [`_cef_view_t::as_panel`] for more documentation."]
    fn as_panel(&self) -> Option<Panel>;
    #[doc = "See [`_cef_view_t::as_scroll_view`] for more documentation."]
    fn as_scroll_view(&self) -> Option<ScrollView>;
    #[doc = "See [`_cef_view_t::as_textfield`] for more documentation."]
    fn as_textfield(&self) -> Option<Textfield>;
    #[doc = "See [`_cef_view_t::get_type_string`] for more documentation."]
    fn type_string(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_view_t::to_string`] for more documentation."]
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree;
    #[doc = "See [`_cef_view_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::is_attached`] for more documentation."]
    fn is_attached(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::get_delegate`] for more documentation."]
    fn delegate(&self) -> Option<ViewDelegate>;
    #[doc = "See [`_cef_view_t::get_window`] for more documentation."]
    fn window(&self) -> Option<Window>;
    #[doc = "See [`_cef_view_t::get_id`] for more documentation."]
    fn id(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::set_id`] for more documentation."]
    fn set_id(&self, id: ::std::os::raw::c_int);
    #[doc = "See [`_cef_view_t::get_group_id`] for more documentation."]
    fn group_id(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::set_group_id`] for more documentation."]
    fn set_group_id(&self, group_id: ::std::os::raw::c_int);
    #[doc = "See [`_cef_view_t::get_parent_view`] for more documentation."]
    fn parent_view(&self) -> Option<View>;
    #[doc = "See [`_cef_view_t::get_view_for_id`] for more documentation."]
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View>;
    #[doc = "See [`_cef_view_t::set_bounds`] for more documentation."]
    fn set_bounds(&self, bounds: Option<&Rect>);
    #[doc = "See [`_cef_view_t::get_bounds`] for more documentation."]
    fn bounds(&self) -> Rect;
    #[doc = "See [`_cef_view_t::get_bounds_in_screen`] for more documentation."]
    fn bounds_in_screen(&self) -> Rect;
    #[doc = "See [`_cef_view_t::set_size`] for more documentation."]
    fn set_size(&self, size: Option<&Size>);
    #[doc = "See [`_cef_view_t::get_size`] for more documentation."]
    fn size(&self) -> Size;
    #[doc = "See [`_cef_view_t::set_position`] for more documentation."]
    fn set_position(&self, position: Option<&Point>);
    #[doc = "See [`_cef_view_t::get_position`] for more documentation."]
    fn position(&self) -> Point;
    #[doc = "See [`_cef_view_t::set_insets`] for more documentation."]
    fn set_insets(&self, insets: Option<&Insets>);
    #[doc = "See [`_cef_view_t::get_insets`] for more documentation."]
    fn insets(&self) -> Insets;
    #[doc = "See [`_cef_view_t::get_preferred_size`] for more documentation."]
    fn preferred_size(&self) -> Size;
    #[doc = "See [`_cef_view_t::size_to_preferred_size`] for more documentation."]
    fn size_to_preferred_size(&self);
    #[doc = "See [`_cef_view_t::get_minimum_size`] for more documentation."]
    fn minimum_size(&self) -> Size;
    #[doc = "See [`_cef_view_t::get_maximum_size`] for more documentation."]
    fn maximum_size(&self) -> Size;
    #[doc = "See [`_cef_view_t::get_height_for_width`] for more documentation."]
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::invalidate_layout`] for more documentation."]
    fn invalidate_layout(&self);
    #[doc = "See [`_cef_view_t::set_visible`] for more documentation."]
    fn set_visible(&self, visible: ::std::os::raw::c_int);
    #[doc = "See [`_cef_view_t::is_visible`] for more documentation."]
    fn is_visible(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::is_drawn`] for more documentation."]
    fn is_drawn(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::set_enabled`] for more documentation."]
    fn set_enabled(&self, enabled: ::std::os::raw::c_int);
    #[doc = "See [`_cef_view_t::is_enabled`] for more documentation."]
    fn is_enabled(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::set_focusable`] for more documentation."]
    fn set_focusable(&self, focusable: ::std::os::raw::c_int);
    #[doc = "See [`_cef_view_t::is_focusable`] for more documentation."]
    fn is_focusable(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::is_accessibility_focusable`] for more documentation."]
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::has_focus`] for more documentation."]
    fn has_focus(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::request_focus`] for more documentation."]
    fn request_focus(&self);
    #[doc = "See [`_cef_view_t::set_background_color`] for more documentation."]
    fn set_background_color(&self, color: u32);
    #[doc = "See [`_cef_view_t::get_background_color`] for more documentation."]
    fn background_color(&self) -> cef_color_t;
    #[doc = "See [`_cef_view_t::get_theme_color`] for more documentation."]
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t;
    #[doc = "See [`_cef_view_t::convert_point_to_screen`] for more documentation."]
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::convert_point_from_screen`] for more documentation."]
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::convert_point_to_window`] for more documentation."]
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::convert_point_from_window`] for more documentation."]
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::convert_point_to_view`] for more documentation."]
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_view_t::convert_point_from_view`] for more documentation."]
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_view_t;
}
impl ImplView for View {
    fn as_browser_view(&self) -> Option<BrowserView> {
        unsafe {
            self.0
                .as_browser_view
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_button(&self) -> Option<Button> {
        unsafe {
            self.0
                .as_button
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_panel(&self) -> Option<Panel> {
        unsafe {
            self.0
                .as_panel
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        unsafe {
            self.0
                .as_scroll_view
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn as_textfield(&self) -> Option<Textfield> {
        unsafe {
            self.0
                .as_textfield
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn type_string(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_type_string
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        unsafe {
            self.0
                .to_string
                .map(|f| {
                    let arg_include_children = include_children;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_include_children);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_attached
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        unsafe {
            self.0
                .get_delegate
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn window(&self) -> Option<Window> {
        unsafe {
            self.0
                .get_window
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn id(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_id {
                let arg_id = id;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_id);
            }
        }
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_group_id
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_group_id {
                let arg_group_id = group_id;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_group_id);
            }
        }
    }
    fn parent_view(&self) -> Option<View> {
        unsafe {
            self.0
                .get_parent_view
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        unsafe {
            self.0
                .get_view_for_id
                .map(|f| {
                    let arg_id = id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_id);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        unsafe {
            if let Some(f) = self.0.set_bounds {
                let arg_bounds = bounds;
                let arg_self_ = self.into_raw();
                let arg_bounds = arg_bounds.cloned().map(|arg| arg.into());
                let arg_bounds = arg_bounds
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_bounds);
            }
        }
    }
    fn bounds(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn bounds_in_screen(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_size(&self, size: Option<&Size>) {
        unsafe {
            if let Some(f) = self.0.set_size {
                let arg_size = size;
                let arg_self_ = self.into_raw();
                let arg_size = arg_size.cloned().map(|arg| arg.into());
                let arg_size = arg_size
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_size);
            }
        }
    }
    fn size(&self) -> Size {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_position(&self, position: Option<&Point>) {
        unsafe {
            if let Some(f) = self.0.set_position {
                let arg_position = position;
                let arg_self_ = self.into_raw();
                let arg_position = arg_position.cloned().map(|arg| arg.into());
                let arg_position = arg_position
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_position);
            }
        }
    }
    fn position(&self) -> Point {
        unsafe {
            self.0
                .get_position
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        unsafe {
            if let Some(f) = self.0.set_insets {
                let arg_insets = insets;
                let arg_self_ = self.into_raw();
                let arg_insets = arg_insets.cloned().map(|arg| arg.into());
                let arg_insets = arg_insets
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_insets);
            }
        }
    }
    fn insets(&self) -> Insets {
        unsafe {
            self.0
                .get_insets
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn preferred_size(&self) -> Size {
        unsafe {
            self.0
                .get_preferred_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn size_to_preferred_size(&self) {
        unsafe {
            if let Some(f) = self.0.size_to_preferred_size {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn minimum_size(&self) -> Size {
        unsafe {
            self.0
                .get_minimum_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn maximum_size(&self) -> Size {
        unsafe {
            self.0
                .get_maximum_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_height_for_width
                .map(|f| {
                    let arg_width = width;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_width);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn invalidate_layout(&self) {
        unsafe {
            if let Some(f) = self.0.invalidate_layout {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_visible {
                let arg_visible = visible;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_visible);
            }
        }
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_drawn
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_enabled {
                let arg_enabled = enabled;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_enabled);
            }
        }
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_enabled
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_focusable {
                let arg_focusable = focusable;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_focusable);
            }
        }
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_focusable
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_accessibility_focusable
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_focus
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn request_focus(&self) {
        unsafe {
            if let Some(f) = self.0.request_focus {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_background_color(&self, color: u32) {
        unsafe {
            if let Some(f) = self.0.set_background_color {
                let arg_color = color;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_color);
            }
        }
    }
    fn background_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_background_color
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        unsafe {
            self.0
                .get_theme_color
                .map(|f| {
                    let arg_color_id = color_id;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_color_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_screen
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.into_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_screen
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.into_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_window
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.into_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_window
                .map(|f| {
                    let arg_point = point;
                    let arg_self_ = self.into_raw();
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_point);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_to_view
                .map(|f| {
                    let (arg_view, arg_point) = (view, point);
                    let arg_self_ = self.into_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view, arg_point);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .convert_point_from_view
                .map(|f| {
                    let (arg_view, arg_point) = (view, point);
                    let arg_self_ = self.into_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                    let arg_point = arg_point
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_view, arg_point);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for View {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_view_t> for &View {
    fn into_raw(self) -> *mut _cef_view_t {
        ImplView::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_view_t> for &mut View {
    fn into_raw(self) -> *mut _cef_view_t {
        ImplView::get_raw(self)
    }
}
impl ConvertReturnValue<View> for *mut _cef_view_t {
    fn wrap_result(self) -> View {
        View(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<View> for *mut _cef_view_t {
    fn from(value: View) -> Self {
        let object = ImplView::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for View {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_button_t`] for more documentation.
#[derive(Clone)]
pub struct Button(RefGuard<_cef_button_t>);
pub trait ImplButton: ImplView {
    #[doc = "See [`_cef_button_t::as_label_button`] for more documentation."]
    fn as_label_button(&self) -> Option<LabelButton>;
    #[doc = "See [`_cef_button_t::set_state`] for more documentation."]
    fn set_state(&self, state: ButtonState);
    #[doc = "See [`_cef_button_t::get_state`] for more documentation."]
    fn state(&self) -> ButtonState;
    #[doc = "See [`_cef_button_t::set_ink_drop_enabled`] for more documentation."]
    fn set_ink_drop_enabled(&self, enabled: ::std::os::raw::c_int);
    #[doc = "See [`_cef_button_t::set_tooltip_text`] for more documentation."]
    fn set_tooltip_text(&self, tooltip_text: Option<&CefString>);
    #[doc = "See [`_cef_button_t::set_accessible_name`] for more documentation."]
    fn set_accessible_name(&self, name: Option<&CefString>);
    fn get_raw(&self) -> *mut _cef_button_t {
        <Self as ImplView>::get_raw(self).cast()
    }
}
impl ImplView for Button {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View::from(self).as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View::from(self).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View::from(self).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View::from(self).as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View::from(self).as_textfield()
    }
    fn type_string(&self) -> CefStringUserfree {
        View::from(self).type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        View::from(self).to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View::from(self).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View::from(self).is_attached()
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        View::from(self).is_same(that)
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        View::from(self).delegate()
    }
    fn window(&self) -> Option<Window> {
        View::from(self).window()
    }
    fn id(&self) -> ::std::os::raw::c_int {
        View::from(self).id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View::from(self).set_id(id)
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        View::from(self).group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View::from(self).set_group_id(group_id)
    }
    fn parent_view(&self) -> Option<View> {
        View::from(self).parent_view()
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View::from(self).view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View::from(self).set_bounds(bounds)
    }
    fn bounds(&self) -> Rect {
        View::from(self).bounds()
    }
    fn bounds_in_screen(&self) -> Rect {
        View::from(self).bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View::from(self).set_size(size)
    }
    fn size(&self) -> Size {
        View::from(self).size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View::from(self).set_position(position)
    }
    fn position(&self) -> Point {
        View::from(self).position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View::from(self).set_insets(insets)
    }
    fn insets(&self) -> Insets {
        View::from(self).insets()
    }
    fn preferred_size(&self) -> Size {
        View::from(self).preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View::from(self).size_to_preferred_size()
    }
    fn minimum_size(&self) -> Size {
        View::from(self).minimum_size()
    }
    fn maximum_size(&self) -> Size {
        View::from(self).maximum_size()
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View::from(self).height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View::from(self).invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View::from(self).set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View::from(self).is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View::from(self).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View::from(self).set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View::from(self).is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View::from(self).set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View::from(self).has_focus()
    }
    fn request_focus(&self) {
        View::from(self).request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View::from(self).set_background_color(color)
    }
    fn background_color(&self) -> cef_color_t {
        View::from(self).background_color()
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View::from(self).theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&Button> for View {
    fn from(from: &Button) -> Self {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplButton for Button {
    fn as_label_button(&self) -> Option<LabelButton> {
        unsafe {
            self.0
                .as_label_button
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_state(&self, state: ButtonState) {
        unsafe {
            if let Some(f) = self.0.set_state {
                let arg_state = state;
                let arg_self_ = self.into_raw();
                let arg_state = arg_state.into_raw();
                f(arg_self_, arg_state);
            }
        }
    }
    fn state(&self) -> ButtonState {
        unsafe {
            self.0
                .get_state
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_ink_drop_enabled(&self, enabled: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_ink_drop_enabled {
                let arg_enabled = enabled;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_enabled);
            }
        }
    }
    fn set_tooltip_text(&self, tooltip_text: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_tooltip_text {
                let arg_tooltip_text = tooltip_text;
                let arg_self_ = self.into_raw();
                let arg_tooltip_text = arg_tooltip_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_tooltip_text);
            }
        }
    }
    fn set_accessible_name(&self, name: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_accessible_name {
                let arg_name = name;
                let arg_self_ = self.into_raw();
                let arg_name = arg_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_name);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_button_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Button {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_button_t> for &Button {
    fn into_raw(self) -> *mut _cef_button_t {
        ImplButton::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_button_t> for &mut Button {
    fn into_raw(self) -> *mut _cef_button_t {
        ImplButton::get_raw(self)
    }
}
impl ConvertReturnValue<Button> for *mut _cef_button_t {
    fn wrap_result(self) -> Button {
        Button(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Button> for *mut _cef_button_t {
    fn from(value: Button) -> Self {
        let object = ImplButton::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Button {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_button_delegate_t`] for more documentation.
#[derive(Clone)]
pub struct ButtonDelegate(RefGuard<_cef_button_delegate_t>);
impl ButtonDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapButtonDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplButtonDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapButtonDelegate>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_button_delegate_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapButtonDelegate: ImplButtonDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_button_delegate_t, Self>);
}
pub trait ImplButtonDelegate: ImplViewDelegate {
    #[doc = "See [`_cef_button_delegate_t::on_button_pressed`] for more documentation."]
    fn on_button_pressed(&self, button: Option<&mut Button>) {}
    #[doc = "See [`_cef_button_delegate_t::on_button_state_changed`] for more documentation."]
    fn on_button_state_changed(&self, button: Option<&mut Button>) {}
    fn init_methods(object: &mut _cef_button_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_button_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_button_delegate_t {
        <Self as ImplViewDelegate>::get_raw(self).cast()
    }
}
mod impl_cef_button_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplButtonDelegate>(object: &mut _cef_button_delegate_t) {
        object.on_button_pressed = Some(on_button_pressed::<I>);
        object.on_button_state_changed = Some(on_button_state_changed::<I>);
    }
    extern "C" fn on_button_pressed<I: ImplButtonDelegate>(
        self_: *mut _cef_button_delegate_t,
        button: *mut _cef_button_t,
    ) {
        let (arg_self_, arg_button) = (self_, button);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_button =
            unsafe { arg_button.as_mut() }.map(|arg| Button(unsafe { RefGuard::from_raw(arg) }));
        let arg_button = arg_button.as_mut();
        ImplButtonDelegate::on_button_pressed(&arg_self_.interface, arg_button)
    }
    extern "C" fn on_button_state_changed<I: ImplButtonDelegate>(
        self_: *mut _cef_button_delegate_t,
        button: *mut _cef_button_t,
    ) {
        let (arg_self_, arg_button) = (self_, button);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_button =
            unsafe { arg_button.as_mut() }.map(|arg| Button(unsafe { RefGuard::from_raw(arg) }));
        let arg_button = arg_button.as_mut();
        ImplButtonDelegate::on_button_state_changed(&arg_self_.interface, arg_button)
    }
}
impl ImplViewDelegate for ButtonDelegate {
    fn preferred_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .preferred_size(view)
    }
    fn minimum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .minimum_size(view)
    }
    fn maximum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .maximum_size(view)
    }
    fn height_for_width(
        &self,
        view: Option<&mut View>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        child: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut View>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut View>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl ImplButtonDelegate for ButtonDelegate {
    fn on_button_pressed(&self, button: Option<&mut Button>) {
        unsafe {
            if let Some(f) = self.0.on_button_pressed {
                let arg_button = button;
                let arg_self_ = self.into_raw();
                let arg_button = arg_button
                    .map(|arg| {
                        arg.add_ref();
                        ImplButton::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_button);
            }
        }
    }
    fn on_button_state_changed(&self, button: Option<&mut Button>) {
        unsafe {
            if let Some(f) = self.0.on_button_state_changed {
                let arg_button = button;
                let arg_self_ = self.into_raw();
                let arg_button = arg_button
                    .map(|arg| {
                        arg.add_ref();
                        ImplButton::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_button);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_button_delegate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_button_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ButtonDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_button_delegate_t> for &ButtonDelegate {
    fn into_raw(self) -> *mut _cef_button_delegate_t {
        ImplButtonDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_button_delegate_t> for &mut ButtonDelegate {
    fn into_raw(self) -> *mut _cef_button_delegate_t {
        ImplButtonDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<ButtonDelegate> for *mut _cef_button_delegate_t {
    fn wrap_result(self) -> ButtonDelegate {
        ButtonDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ButtonDelegate> for *mut _cef_button_delegate_t {
    fn from(value: ButtonDelegate) -> Self {
        let object = ImplButtonDelegate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ButtonDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_label_button_t`] for more documentation.
#[derive(Clone)]
pub struct LabelButton(RefGuard<_cef_label_button_t>);
pub trait ImplLabelButton: ImplButton {
    #[doc = "See [`_cef_label_button_t::as_menu_button`] for more documentation."]
    fn as_menu_button(&self) -> Option<MenuButton>;
    #[doc = "See [`_cef_label_button_t::set_text`] for more documentation."]
    fn set_text(&self, text: Option<&CefString>);
    #[doc = "See [`_cef_label_button_t::get_text`] for more documentation."]
    fn text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_label_button_t::set_image`] for more documentation."]
    fn set_image(&self, button_state: ButtonState, image: Option<&mut Image>);
    #[doc = "See [`_cef_label_button_t::get_image`] for more documentation."]
    fn image(&self, button_state: ButtonState) -> Option<Image>;
    #[doc = "See [`_cef_label_button_t::set_text_color`] for more documentation."]
    fn set_text_color(&self, for_state: ButtonState, color: u32);
    #[doc = "See [`_cef_label_button_t::set_enabled_text_colors`] for more documentation."]
    fn set_enabled_text_colors(&self, color: u32);
    #[doc = "See [`_cef_label_button_t::set_font_list`] for more documentation."]
    fn set_font_list(&self, font_list: Option<&CefString>);
    #[doc = "See [`_cef_label_button_t::set_horizontal_alignment`] for more documentation."]
    fn set_horizontal_alignment(&self, alignment: HorizontalAlignment);
    #[doc = "See [`_cef_label_button_t::set_minimum_size`] for more documentation."]
    fn set_minimum_size(&self, size: Option<&Size>);
    #[doc = "See [`_cef_label_button_t::set_maximum_size`] for more documentation."]
    fn set_maximum_size(&self, size: Option<&Size>);
    fn get_raw(&self) -> *mut _cef_label_button_t {
        <Self as ImplButton>::get_raw(self).cast()
    }
}
impl ImplView for LabelButton {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View::from(self).as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View::from(self).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View::from(self).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View::from(self).as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View::from(self).as_textfield()
    }
    fn type_string(&self) -> CefStringUserfree {
        View::from(self).type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        View::from(self).to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View::from(self).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View::from(self).is_attached()
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        View::from(self).is_same(that)
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        View::from(self).delegate()
    }
    fn window(&self) -> Option<Window> {
        View::from(self).window()
    }
    fn id(&self) -> ::std::os::raw::c_int {
        View::from(self).id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View::from(self).set_id(id)
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        View::from(self).group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View::from(self).set_group_id(group_id)
    }
    fn parent_view(&self) -> Option<View> {
        View::from(self).parent_view()
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View::from(self).view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View::from(self).set_bounds(bounds)
    }
    fn bounds(&self) -> Rect {
        View::from(self).bounds()
    }
    fn bounds_in_screen(&self) -> Rect {
        View::from(self).bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View::from(self).set_size(size)
    }
    fn size(&self) -> Size {
        View::from(self).size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View::from(self).set_position(position)
    }
    fn position(&self) -> Point {
        View::from(self).position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View::from(self).set_insets(insets)
    }
    fn insets(&self) -> Insets {
        View::from(self).insets()
    }
    fn preferred_size(&self) -> Size {
        View::from(self).preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View::from(self).size_to_preferred_size()
    }
    fn minimum_size(&self) -> Size {
        View::from(self).minimum_size()
    }
    fn maximum_size(&self) -> Size {
        View::from(self).maximum_size()
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View::from(self).height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View::from(self).invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View::from(self).set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View::from(self).is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View::from(self).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View::from(self).set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View::from(self).is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View::from(self).set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View::from(self).has_focus()
    }
    fn request_focus(&self) {
        View::from(self).request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View::from(self).set_background_color(color)
    }
    fn background_color(&self) -> cef_color_t {
        View::from(self).background_color()
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View::from(self).theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&LabelButton> for View {
    fn from(from: &LabelButton) -> Self {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplButton for LabelButton {
    fn as_label_button(&self) -> Option<LabelButton> {
        Button::from(self).as_label_button()
    }
    fn set_state(&self, state: ButtonState) {
        Button::from(self).set_state(state)
    }
    fn state(&self) -> ButtonState {
        Button::from(self).state()
    }
    fn set_ink_drop_enabled(&self, enabled: ::std::os::raw::c_int) {
        Button::from(self).set_ink_drop_enabled(enabled)
    }
    fn set_tooltip_text(&self, tooltip_text: Option<&CefString>) {
        Button::from(self).set_tooltip_text(tooltip_text)
    }
    fn set_accessible_name(&self, name: Option<&CefString>) {
        Button::from(self).set_accessible_name(name)
    }
    fn get_raw(&self) -> *mut _cef_button_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&LabelButton> for Button {
    fn from(from: &LabelButton) -> Self {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplLabelButton for LabelButton {
    fn as_menu_button(&self) -> Option<MenuButton> {
        unsafe {
            self.0
                .as_menu_button
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_text(&self, text: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_text {
                let arg_text = text;
                let arg_self_ = self.into_raw();
                let arg_text = arg_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_text);
            }
        }
    }
    fn text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_image(&self, button_state: ButtonState, image: Option<&mut Image>) {
        unsafe {
            if let Some(f) = self.0.set_image {
                let (arg_button_state, arg_image) = (button_state, image);
                let arg_self_ = self.into_raw();
                let arg_button_state = arg_button_state.into_raw();
                let arg_image = arg_image
                    .map(|arg| {
                        arg.add_ref();
                        ImplImage::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_button_state, arg_image);
            }
        }
    }
    fn image(&self, button_state: ButtonState) -> Option<Image> {
        unsafe {
            self.0
                .get_image
                .map(|f| {
                    let arg_button_state = button_state;
                    let arg_self_ = self.into_raw();
                    let arg_button_state = arg_button_state.into_raw();
                    let result = f(arg_self_, arg_button_state);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_text_color(&self, for_state: ButtonState, color: u32) {
        unsafe {
            if let Some(f) = self.0.set_text_color {
                let (arg_for_state, arg_color) = (for_state, color);
                let arg_self_ = self.into_raw();
                let arg_for_state = arg_for_state.into_raw();
                f(arg_self_, arg_for_state, arg_color);
            }
        }
    }
    fn set_enabled_text_colors(&self, color: u32) {
        unsafe {
            if let Some(f) = self.0.set_enabled_text_colors {
                let arg_color = color;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_color);
            }
        }
    }
    fn set_font_list(&self, font_list: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_font_list {
                let arg_font_list = font_list;
                let arg_self_ = self.into_raw();
                let arg_font_list = arg_font_list
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_font_list);
            }
        }
    }
    fn set_horizontal_alignment(&self, alignment: HorizontalAlignment) {
        unsafe {
            if let Some(f) = self.0.set_horizontal_alignment {
                let arg_alignment = alignment;
                let arg_self_ = self.into_raw();
                let arg_alignment = arg_alignment.into_raw();
                f(arg_self_, arg_alignment);
            }
        }
    }
    fn set_minimum_size(&self, size: Option<&Size>) {
        unsafe {
            if let Some(f) = self.0.set_minimum_size {
                let arg_size = size;
                let arg_self_ = self.into_raw();
                let arg_size = arg_size.cloned().map(|arg| arg.into());
                let arg_size = arg_size
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_size);
            }
        }
    }
    fn set_maximum_size(&self, size: Option<&Size>) {
        unsafe {
            if let Some(f) = self.0.set_maximum_size {
                let arg_size = size;
                let arg_self_ = self.into_raw();
                let arg_size = arg_size.cloned().map(|arg| arg.into());
                let arg_size = arg_size
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_size);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_label_button_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_label_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for LabelButton {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_label_button_t> for &LabelButton {
    fn into_raw(self) -> *mut _cef_label_button_t {
        ImplLabelButton::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_label_button_t> for &mut LabelButton {
    fn into_raw(self) -> *mut _cef_label_button_t {
        ImplLabelButton::get_raw(self)
    }
}
impl ConvertReturnValue<LabelButton> for *mut _cef_label_button_t {
    fn wrap_result(self) -> LabelButton {
        LabelButton(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<LabelButton> for *mut _cef_label_button_t {
    fn from(value: LabelButton) -> Self {
        let object = ImplLabelButton::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for LabelButton {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_menu_button_pressed_lock_t`] for more documentation.
#[derive(Clone)]
pub struct MenuButtonPressedLock(RefGuard<_cef_menu_button_pressed_lock_t>);
pub trait ImplMenuButtonPressedLock: Clone + Sized + Rc {
    fn get_raw(&self) -> *mut _cef_menu_button_pressed_lock_t;
}
impl ImplMenuButtonPressedLock for MenuButtonPressedLock {
    fn get_raw(&self) -> *mut _cef_menu_button_pressed_lock_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_menu_button_pressed_lock_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButtonPressedLock {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_pressed_lock_t> for &MenuButtonPressedLock {
    fn into_raw(self) -> *mut _cef_menu_button_pressed_lock_t {
        ImplMenuButtonPressedLock::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_button_pressed_lock_t> for &mut MenuButtonPressedLock {
    fn into_raw(self) -> *mut _cef_menu_button_pressed_lock_t {
        ImplMenuButtonPressedLock::get_raw(self)
    }
}
impl ConvertReturnValue<MenuButtonPressedLock> for *mut _cef_menu_button_pressed_lock_t {
    fn wrap_result(self) -> MenuButtonPressedLock {
        MenuButtonPressedLock(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MenuButtonPressedLock> for *mut _cef_menu_button_pressed_lock_t {
    fn from(value: MenuButtonPressedLock) -> Self {
        let object = ImplMenuButtonPressedLock::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MenuButtonPressedLock {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_menu_button_delegate_t`] for more documentation.
#[derive(Clone)]
pub struct MenuButtonDelegate(RefGuard<_cef_menu_button_delegate_t>);
impl MenuButtonDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapMenuButtonDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplMenuButtonDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapMenuButtonDelegate>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_menu_button_delegate_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapMenuButtonDelegate: ImplMenuButtonDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_menu_button_delegate_t, Self>);
}
pub trait ImplMenuButtonDelegate: ImplButtonDelegate {
    #[doc = "See [`_cef_menu_button_delegate_t::on_menu_button_pressed`] for more documentation."]
    fn on_menu_button_pressed(
        &self,
        menu_button: Option<&mut MenuButton>,
        screen_point: Option<&Point>,
        button_pressed_lock: Option<&mut MenuButtonPressedLock>,
    ) {
    }
    fn init_methods(object: &mut _cef_menu_button_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_button_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_menu_button_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_menu_button_delegate_t {
        <Self as ImplButtonDelegate>::get_raw(self).cast()
    }
}
mod impl_cef_menu_button_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplMenuButtonDelegate>(object: &mut _cef_menu_button_delegate_t) {
        object.on_menu_button_pressed = Some(on_menu_button_pressed::<I>);
    }
    extern "C" fn on_menu_button_pressed<I: ImplMenuButtonDelegate>(
        self_: *mut _cef_menu_button_delegate_t,
        menu_button: *mut _cef_menu_button_t,
        screen_point: *const _cef_point_t,
        button_pressed_lock: *mut _cef_menu_button_pressed_lock_t,
    ) {
        let (arg_self_, arg_menu_button, arg_screen_point, arg_button_pressed_lock) =
            (self_, menu_button, screen_point, button_pressed_lock);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_menu_button = unsafe { arg_menu_button.as_mut() }
            .map(|arg| MenuButton(unsafe { RefGuard::from_raw(arg) }));
        let arg_menu_button = arg_menu_button.as_mut();
        let arg_screen_point = if arg_screen_point.is_null() {
            None
        } else {
            Some(WrapParamRef::<Point, _>::from(arg_screen_point))
        };
        let arg_screen_point = arg_screen_point.as_ref().map(|arg| arg.as_ref());
        let mut arg_button_pressed_lock = unsafe { arg_button_pressed_lock.as_mut() }
            .map(|arg| MenuButtonPressedLock(unsafe { RefGuard::from_raw(arg) }));
        let arg_button_pressed_lock = arg_button_pressed_lock.as_mut();
        ImplMenuButtonDelegate::on_menu_button_pressed(
            &arg_self_.interface,
            arg_menu_button,
            arg_screen_point,
            arg_button_pressed_lock,
        )
    }
}
impl ImplViewDelegate for MenuButtonDelegate {
    fn preferred_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .preferred_size(view)
    }
    fn minimum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .minimum_size(view)
    }
    fn maximum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .maximum_size(view)
    }
    fn height_for_width(
        &self,
        view: Option<&mut View>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        child: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut View>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut View>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl ImplButtonDelegate for MenuButtonDelegate {
    fn on_button_pressed(&self, button: Option<&mut Button>) {
        ButtonDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_button_pressed(button)
    }
    fn on_button_state_changed(&self, button: Option<&mut Button>) {
        ButtonDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_button_state_changed(button)
    }
    fn get_raw(&self) -> *mut _cef_button_delegate_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl ImplMenuButtonDelegate for MenuButtonDelegate {
    fn on_menu_button_pressed(
        &self,
        menu_button: Option<&mut MenuButton>,
        screen_point: Option<&Point>,
        button_pressed_lock: Option<&mut MenuButtonPressedLock>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_menu_button_pressed {
                let (arg_menu_button, arg_screen_point, arg_button_pressed_lock) =
                    (menu_button, screen_point, button_pressed_lock);
                let arg_self_ = self.into_raw();
                let arg_menu_button = arg_menu_button
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuButton::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_screen_point = arg_screen_point.cloned().map(|arg| arg.into());
                let arg_screen_point = arg_screen_point
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_button_pressed_lock = arg_button_pressed_lock
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuButtonPressedLock::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(
                    arg_self_,
                    arg_menu_button,
                    arg_screen_point,
                    arg_button_pressed_lock,
                );
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_menu_button_delegate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_menu_button_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButtonDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_delegate_t> for &MenuButtonDelegate {
    fn into_raw(self) -> *mut _cef_menu_button_delegate_t {
        ImplMenuButtonDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_button_delegate_t> for &mut MenuButtonDelegate {
    fn into_raw(self) -> *mut _cef_menu_button_delegate_t {
        ImplMenuButtonDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<MenuButtonDelegate> for *mut _cef_menu_button_delegate_t {
    fn wrap_result(self) -> MenuButtonDelegate {
        MenuButtonDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MenuButtonDelegate> for *mut _cef_menu_button_delegate_t {
    fn from(value: MenuButtonDelegate) -> Self {
        let object = ImplMenuButtonDelegate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MenuButtonDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_menu_button_t`] for more documentation.
#[derive(Clone)]
pub struct MenuButton(RefGuard<_cef_menu_button_t>);
pub trait ImplMenuButton: ImplLabelButton {
    #[doc = "See [`_cef_menu_button_t::show_menu`] for more documentation."]
    fn show_menu(
        &self,
        menu_model: Option<&mut MenuModel>,
        screen_point: Option<&Point>,
        anchor_position: MenuAnchorPosition,
    );
    #[doc = "See [`_cef_menu_button_t::trigger_menu`] for more documentation."]
    fn trigger_menu(&self);
    fn get_raw(&self) -> *mut _cef_menu_button_t {
        <Self as ImplLabelButton>::get_raw(self).cast()
    }
}
impl ImplView for MenuButton {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View::from(self).as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View::from(self).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View::from(self).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View::from(self).as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View::from(self).as_textfield()
    }
    fn type_string(&self) -> CefStringUserfree {
        View::from(self).type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        View::from(self).to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View::from(self).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View::from(self).is_attached()
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        View::from(self).is_same(that)
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        View::from(self).delegate()
    }
    fn window(&self) -> Option<Window> {
        View::from(self).window()
    }
    fn id(&self) -> ::std::os::raw::c_int {
        View::from(self).id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View::from(self).set_id(id)
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        View::from(self).group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View::from(self).set_group_id(group_id)
    }
    fn parent_view(&self) -> Option<View> {
        View::from(self).parent_view()
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View::from(self).view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View::from(self).set_bounds(bounds)
    }
    fn bounds(&self) -> Rect {
        View::from(self).bounds()
    }
    fn bounds_in_screen(&self) -> Rect {
        View::from(self).bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View::from(self).set_size(size)
    }
    fn size(&self) -> Size {
        View::from(self).size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View::from(self).set_position(position)
    }
    fn position(&self) -> Point {
        View::from(self).position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View::from(self).set_insets(insets)
    }
    fn insets(&self) -> Insets {
        View::from(self).insets()
    }
    fn preferred_size(&self) -> Size {
        View::from(self).preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View::from(self).size_to_preferred_size()
    }
    fn minimum_size(&self) -> Size {
        View::from(self).minimum_size()
    }
    fn maximum_size(&self) -> Size {
        View::from(self).maximum_size()
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View::from(self).height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View::from(self).invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View::from(self).set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View::from(self).is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View::from(self).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View::from(self).set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View::from(self).is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View::from(self).set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View::from(self).has_focus()
    }
    fn request_focus(&self) {
        View::from(self).request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View::from(self).set_background_color(color)
    }
    fn background_color(&self) -> cef_color_t {
        View::from(self).background_color()
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View::from(self).theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&MenuButton> for View {
    fn from(from: &MenuButton) -> Self {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplButton for MenuButton {
    fn as_label_button(&self) -> Option<LabelButton> {
        Button::from(self).as_label_button()
    }
    fn set_state(&self, state: ButtonState) {
        Button::from(self).set_state(state)
    }
    fn state(&self) -> ButtonState {
        Button::from(self).state()
    }
    fn set_ink_drop_enabled(&self, enabled: ::std::os::raw::c_int) {
        Button::from(self).set_ink_drop_enabled(enabled)
    }
    fn set_tooltip_text(&self, tooltip_text: Option<&CefString>) {
        Button::from(self).set_tooltip_text(tooltip_text)
    }
    fn set_accessible_name(&self, name: Option<&CefString>) {
        Button::from(self).set_accessible_name(name)
    }
    fn get_raw(&self) -> *mut _cef_button_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&MenuButton> for Button {
    fn from(from: &MenuButton) -> Self {
        Button(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplLabelButton for MenuButton {
    fn as_menu_button(&self) -> Option<MenuButton> {
        LabelButton::from(self).as_menu_button()
    }
    fn set_text(&self, text: Option<&CefString>) {
        LabelButton::from(self).set_text(text)
    }
    fn text(&self) -> CefStringUserfree {
        LabelButton::from(self).text()
    }
    fn set_image(&self, button_state: ButtonState, image: Option<&mut Image>) {
        LabelButton::from(self).set_image(button_state, image)
    }
    fn image(&self, button_state: ButtonState) -> Option<Image> {
        LabelButton::from(self).image(button_state)
    }
    fn set_text_color(&self, for_state: ButtonState, color: u32) {
        LabelButton::from(self).set_text_color(for_state, color)
    }
    fn set_enabled_text_colors(&self, color: u32) {
        LabelButton::from(self).set_enabled_text_colors(color)
    }
    fn set_font_list(&self, font_list: Option<&CefString>) {
        LabelButton::from(self).set_font_list(font_list)
    }
    fn set_horizontal_alignment(&self, alignment: HorizontalAlignment) {
        LabelButton::from(self).set_horizontal_alignment(alignment)
    }
    fn set_minimum_size(&self, size: Option<&Size>) {
        LabelButton::from(self).set_minimum_size(size)
    }
    fn set_maximum_size(&self, size: Option<&Size>) {
        LabelButton::from(self).set_maximum_size(size)
    }
    fn get_raw(&self) -> *mut _cef_label_button_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&MenuButton> for LabelButton {
    fn from(from: &MenuButton) -> Self {
        LabelButton(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplMenuButton for MenuButton {
    fn show_menu(
        &self,
        menu_model: Option<&mut MenuModel>,
        screen_point: Option<&Point>,
        anchor_position: MenuAnchorPosition,
    ) {
        unsafe {
            if let Some(f) = self.0.show_menu {
                let (arg_menu_model, arg_screen_point, arg_anchor_position) =
                    (menu_model, screen_point, anchor_position);
                let arg_self_ = self.into_raw();
                let arg_menu_model = arg_menu_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_screen_point = arg_screen_point.cloned().map(|arg| arg.into());
                let arg_screen_point = arg_screen_point
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_anchor_position = arg_anchor_position.into_raw();
                f(
                    arg_self_,
                    arg_menu_model,
                    arg_screen_point,
                    arg_anchor_position,
                );
            }
        }
    }
    fn trigger_menu(&self) {
        unsafe {
            if let Some(f) = self.0.trigger_menu {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_menu_button_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_menu_button_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for MenuButton {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_menu_button_t> for &MenuButton {
    fn into_raw(self) -> *mut _cef_menu_button_t {
        ImplMenuButton::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_menu_button_t> for &mut MenuButton {
    fn into_raw(self) -> *mut _cef_menu_button_t {
        ImplMenuButton::get_raw(self)
    }
}
impl ConvertReturnValue<MenuButton> for *mut _cef_menu_button_t {
    fn wrap_result(self) -> MenuButton {
        MenuButton(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<MenuButton> for *mut _cef_menu_button_t {
    fn from(value: MenuButton) -> Self {
        let object = ImplMenuButton::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for MenuButton {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_textfield_delegate_t`] for more documentation.
#[derive(Clone)]
pub struct TextfieldDelegate(RefGuard<_cef_textfield_delegate_t>);
impl TextfieldDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapTextfieldDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplTextfieldDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapTextfieldDelegate>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_textfield_delegate_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapTextfieldDelegate: ImplTextfieldDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_textfield_delegate_t, Self>);
}
pub trait ImplTextfieldDelegate: ImplViewDelegate {
    #[doc = "See [`_cef_textfield_delegate_t::on_key_event`] for more documentation."]
    fn on_key_event(
        &self,
        textfield: Option<&mut Textfield>,
        event: Option<&KeyEvent>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_textfield_delegate_t::on_after_user_action`] for more documentation."]
    fn on_after_user_action(&self, textfield: Option<&mut Textfield>) {}
    fn init_methods(object: &mut _cef_textfield_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_textfield_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_textfield_delegate_t {
        <Self as ImplViewDelegate>::get_raw(self).cast()
    }
}
mod impl_cef_textfield_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplTextfieldDelegate>(object: &mut _cef_textfield_delegate_t) {
        object.on_key_event = Some(on_key_event::<I>);
        object.on_after_user_action = Some(on_after_user_action::<I>);
    }
    extern "C" fn on_key_event<I: ImplTextfieldDelegate>(
        self_: *mut _cef_textfield_delegate_t,
        textfield: *mut _cef_textfield_t,
        event: *const _cef_key_event_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_textfield, arg_event) = (self_, textfield, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_textfield = unsafe { arg_textfield.as_mut() }
            .map(|arg| Textfield(unsafe { RefGuard::from_raw(arg) }));
        let arg_textfield = arg_textfield.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent, _>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        ImplTextfieldDelegate::on_key_event(&arg_self_.interface, arg_textfield, arg_event)
    }
    extern "C" fn on_after_user_action<I: ImplTextfieldDelegate>(
        self_: *mut _cef_textfield_delegate_t,
        textfield: *mut _cef_textfield_t,
    ) {
        let (arg_self_, arg_textfield) = (self_, textfield);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_textfield = unsafe { arg_textfield.as_mut() }
            .map(|arg| Textfield(unsafe { RefGuard::from_raw(arg) }));
        let arg_textfield = arg_textfield.as_mut();
        ImplTextfieldDelegate::on_after_user_action(&arg_self_.interface, arg_textfield)
    }
}
impl ImplViewDelegate for TextfieldDelegate {
    fn preferred_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .preferred_size(view)
    }
    fn minimum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .minimum_size(view)
    }
    fn maximum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .maximum_size(view)
    }
    fn height_for_width(
        &self,
        view: Option<&mut View>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        child: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut View>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut View>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl ImplTextfieldDelegate for TextfieldDelegate {
    fn on_key_event(
        &self,
        textfield: Option<&mut Textfield>,
        event: Option<&KeyEvent>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_textfield, arg_event) = (textfield, event);
                    let arg_self_ = self.into_raw();
                    let arg_textfield = arg_textfield
                        .map(|arg| {
                            arg.add_ref();
                            ImplTextfield::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_textfield, arg_event);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_after_user_action(&self, textfield: Option<&mut Textfield>) {
        unsafe {
            if let Some(f) = self.0.on_after_user_action {
                let arg_textfield = textfield;
                let arg_self_ = self.into_raw();
                let arg_textfield = arg_textfield
                    .map(|arg| {
                        arg.add_ref();
                        ImplTextfield::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_textfield);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_textfield_delegate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_textfield_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for TextfieldDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_textfield_delegate_t> for &TextfieldDelegate {
    fn into_raw(self) -> *mut _cef_textfield_delegate_t {
        ImplTextfieldDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_textfield_delegate_t> for &mut TextfieldDelegate {
    fn into_raw(self) -> *mut _cef_textfield_delegate_t {
        ImplTextfieldDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<TextfieldDelegate> for *mut _cef_textfield_delegate_t {
    fn wrap_result(self) -> TextfieldDelegate {
        TextfieldDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<TextfieldDelegate> for *mut _cef_textfield_delegate_t {
    fn from(value: TextfieldDelegate) -> Self {
        let object = ImplTextfieldDelegate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for TextfieldDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_textfield_t`] for more documentation.
#[derive(Clone)]
pub struct Textfield(RefGuard<_cef_textfield_t>);
pub trait ImplTextfield: ImplView {
    #[doc = "See [`_cef_textfield_t::set_password_input`] for more documentation."]
    fn set_password_input(&self, password_input: ::std::os::raw::c_int);
    #[doc = "See [`_cef_textfield_t::is_password_input`] for more documentation."]
    fn is_password_input(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_textfield_t::set_read_only`] for more documentation."]
    fn set_read_only(&self, read_only: ::std::os::raw::c_int);
    #[doc = "See [`_cef_textfield_t::is_read_only`] for more documentation."]
    fn is_read_only(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_textfield_t::get_text`] for more documentation."]
    fn text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_textfield_t::set_text`] for more documentation."]
    fn set_text(&self, text: Option<&CefString>);
    #[doc = "See [`_cef_textfield_t::append_text`] for more documentation."]
    fn append_text(&self, text: Option<&CefString>);
    #[doc = "See [`_cef_textfield_t::insert_or_replace_text`] for more documentation."]
    fn insert_or_replace_text(&self, text: Option<&CefString>);
    #[doc = "See [`_cef_textfield_t::has_selection`] for more documentation."]
    fn has_selection(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_textfield_t::get_selected_text`] for more documentation."]
    fn selected_text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_textfield_t::select_all`] for more documentation."]
    fn select_all(&self, reversed: ::std::os::raw::c_int);
    #[doc = "See [`_cef_textfield_t::clear_selection`] for more documentation."]
    fn clear_selection(&self);
    #[doc = "See [`_cef_textfield_t::get_selected_range`] for more documentation."]
    fn selected_range(&self) -> Range;
    #[doc = "See [`_cef_textfield_t::select_range`] for more documentation."]
    fn select_range(&self, range: Option<&Range>);
    #[doc = "See [`_cef_textfield_t::get_cursor_position`] for more documentation."]
    fn cursor_position(&self) -> usize;
    #[doc = "See [`_cef_textfield_t::set_text_color`] for more documentation."]
    fn set_text_color(&self, color: u32);
    #[doc = "See [`_cef_textfield_t::get_text_color`] for more documentation."]
    fn text_color(&self) -> cef_color_t;
    #[doc = "See [`_cef_textfield_t::set_selection_text_color`] for more documentation."]
    fn set_selection_text_color(&self, color: u32);
    #[doc = "See [`_cef_textfield_t::get_selection_text_color`] for more documentation."]
    fn selection_text_color(&self) -> cef_color_t;
    #[doc = "See [`_cef_textfield_t::set_selection_background_color`] for more documentation."]
    fn set_selection_background_color(&self, color: u32);
    #[doc = "See [`_cef_textfield_t::get_selection_background_color`] for more documentation."]
    fn selection_background_color(&self) -> cef_color_t;
    #[doc = "See [`_cef_textfield_t::set_font_list`] for more documentation."]
    fn set_font_list(&self, font_list: Option<&CefString>);
    #[doc = "See [`_cef_textfield_t::apply_text_color`] for more documentation."]
    fn apply_text_color(&self, color: u32, range: Option<&Range>);
    #[doc = "See [`_cef_textfield_t::apply_text_style`] for more documentation."]
    fn apply_text_style(&self, style: TextStyle, add: ::std::os::raw::c_int, range: Option<&Range>);
    #[doc = "See [`_cef_textfield_t::is_command_enabled`] for more documentation."]
    fn is_command_enabled(&self, command_id: TextFieldCommands) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_textfield_t::execute_command`] for more documentation."]
    fn execute_command(&self, command_id: TextFieldCommands);
    #[doc = "See [`_cef_textfield_t::clear_edit_history`] for more documentation."]
    fn clear_edit_history(&self);
    #[doc = "See [`_cef_textfield_t::set_placeholder_text`] for more documentation."]
    fn set_placeholder_text(&self, text: Option<&CefString>);
    #[doc = "See [`_cef_textfield_t::get_placeholder_text`] for more documentation."]
    fn placeholder_text(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_textfield_t::set_placeholder_text_color`] for more documentation."]
    fn set_placeholder_text_color(&self, color: u32);
    #[doc = "See [`_cef_textfield_t::set_accessible_name`] for more documentation."]
    fn set_accessible_name(&self, name: Option<&CefString>);
    fn get_raw(&self) -> *mut _cef_textfield_t {
        <Self as ImplView>::get_raw(self).cast()
    }
}
impl ImplView for Textfield {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View::from(self).as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View::from(self).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View::from(self).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View::from(self).as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View::from(self).as_textfield()
    }
    fn type_string(&self) -> CefStringUserfree {
        View::from(self).type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        View::from(self).to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View::from(self).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View::from(self).is_attached()
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        View::from(self).is_same(that)
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        View::from(self).delegate()
    }
    fn window(&self) -> Option<Window> {
        View::from(self).window()
    }
    fn id(&self) -> ::std::os::raw::c_int {
        View::from(self).id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View::from(self).set_id(id)
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        View::from(self).group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View::from(self).set_group_id(group_id)
    }
    fn parent_view(&self) -> Option<View> {
        View::from(self).parent_view()
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View::from(self).view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View::from(self).set_bounds(bounds)
    }
    fn bounds(&self) -> Rect {
        View::from(self).bounds()
    }
    fn bounds_in_screen(&self) -> Rect {
        View::from(self).bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View::from(self).set_size(size)
    }
    fn size(&self) -> Size {
        View::from(self).size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View::from(self).set_position(position)
    }
    fn position(&self) -> Point {
        View::from(self).position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View::from(self).set_insets(insets)
    }
    fn insets(&self) -> Insets {
        View::from(self).insets()
    }
    fn preferred_size(&self) -> Size {
        View::from(self).preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View::from(self).size_to_preferred_size()
    }
    fn minimum_size(&self) -> Size {
        View::from(self).minimum_size()
    }
    fn maximum_size(&self) -> Size {
        View::from(self).maximum_size()
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View::from(self).height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View::from(self).invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View::from(self).set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View::from(self).is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View::from(self).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View::from(self).set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View::from(self).is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View::from(self).set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View::from(self).has_focus()
    }
    fn request_focus(&self) {
        View::from(self).request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View::from(self).set_background_color(color)
    }
    fn background_color(&self) -> cef_color_t {
        View::from(self).background_color()
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View::from(self).theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&Textfield> for View {
    fn from(from: &Textfield) -> Self {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplTextfield for Textfield {
    fn set_password_input(&self, password_input: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_password_input {
                let arg_password_input = password_input;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_password_input);
            }
        }
    }
    fn is_password_input(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_password_input
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_read_only(&self, read_only: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_read_only {
                let arg_read_only = read_only;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_read_only);
            }
        }
    }
    fn is_read_only(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_read_only
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_text(&self, text: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_text {
                let arg_text = text;
                let arg_self_ = self.into_raw();
                let arg_text = arg_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_text);
            }
        }
    }
    fn append_text(&self, text: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.append_text {
                let arg_text = text;
                let arg_self_ = self.into_raw();
                let arg_text = arg_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_text);
            }
        }
    }
    fn insert_or_replace_text(&self, text: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.insert_or_replace_text {
                let arg_text = text;
                let arg_self_ = self.into_raw();
                let arg_text = arg_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_text);
            }
        }
    }
    fn has_selection(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_selection
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn selected_text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_selected_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn select_all(&self, reversed: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.select_all {
                let arg_reversed = reversed;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_reversed);
            }
        }
    }
    fn clear_selection(&self) {
        unsafe {
            if let Some(f) = self.0.clear_selection {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn selected_range(&self) -> Range {
        unsafe {
            self.0
                .get_selected_range
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn select_range(&self, range: Option<&Range>) {
        unsafe {
            if let Some(f) = self.0.select_range {
                let arg_range = range;
                let arg_self_ = self.into_raw();
                let arg_range = arg_range.cloned().map(|arg| arg.into());
                let arg_range = arg_range
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_range);
            }
        }
    }
    fn cursor_position(&self) -> usize {
        unsafe {
            self.0
                .get_cursor_position
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_text_color(&self, color: u32) {
        unsafe {
            if let Some(f) = self.0.set_text_color {
                let arg_color = color;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_color);
            }
        }
    }
    fn text_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_text_color
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_selection_text_color(&self, color: u32) {
        unsafe {
            if let Some(f) = self.0.set_selection_text_color {
                let arg_color = color;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_color);
            }
        }
    }
    fn selection_text_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_selection_text_color
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_selection_background_color(&self, color: u32) {
        unsafe {
            if let Some(f) = self.0.set_selection_background_color {
                let arg_color = color;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_color);
            }
        }
    }
    fn selection_background_color(&self) -> cef_color_t {
        unsafe {
            self.0
                .get_selection_background_color
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_font_list(&self, font_list: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_font_list {
                let arg_font_list = font_list;
                let arg_self_ = self.into_raw();
                let arg_font_list = arg_font_list
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_font_list);
            }
        }
    }
    fn apply_text_color(&self, color: u32, range: Option<&Range>) {
        unsafe {
            if let Some(f) = self.0.apply_text_color {
                let (arg_color, arg_range) = (color, range);
                let arg_self_ = self.into_raw();
                let arg_range = arg_range.cloned().map(|arg| arg.into());
                let arg_range = arg_range
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_color, arg_range);
            }
        }
    }
    fn apply_text_style(
        &self,
        style: TextStyle,
        add: ::std::os::raw::c_int,
        range: Option<&Range>,
    ) {
        unsafe {
            if let Some(f) = self.0.apply_text_style {
                let (arg_style, arg_add, arg_range) = (style, add, range);
                let arg_self_ = self.into_raw();
                let arg_style = arg_style.into_raw();
                let arg_range = arg_range.cloned().map(|arg| arg.into());
                let arg_range = arg_range
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_style, arg_add, arg_range);
            }
        }
    }
    fn is_command_enabled(&self, command_id: TextFieldCommands) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_command_enabled
                .map(|f| {
                    let arg_command_id = command_id;
                    let arg_self_ = self.into_raw();
                    let arg_command_id = arg_command_id.into_raw();
                    let result = f(arg_self_, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn execute_command(&self, command_id: TextFieldCommands) {
        unsafe {
            if let Some(f) = self.0.execute_command {
                let arg_command_id = command_id;
                let arg_self_ = self.into_raw();
                let arg_command_id = arg_command_id.into_raw();
                f(arg_self_, arg_command_id);
            }
        }
    }
    fn clear_edit_history(&self) {
        unsafe {
            if let Some(f) = self.0.clear_edit_history {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_placeholder_text(&self, text: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_placeholder_text {
                let arg_text = text;
                let arg_self_ = self.into_raw();
                let arg_text = arg_text
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_text);
            }
        }
    }
    fn placeholder_text(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_placeholder_text
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_placeholder_text_color(&self, color: u32) {
        unsafe {
            if let Some(f) = self.0.set_placeholder_text_color {
                let arg_color = color;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_color);
            }
        }
    }
    fn set_accessible_name(&self, name: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_accessible_name {
                let arg_name = name;
                let arg_self_ = self.into_raw();
                let arg_name = arg_name
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_name);
            }
        }
    }
    fn get_raw(&self) -> *mut _cef_textfield_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_textfield_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Textfield {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_textfield_t> for &Textfield {
    fn into_raw(self) -> *mut _cef_textfield_t {
        ImplTextfield::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_textfield_t> for &mut Textfield {
    fn into_raw(self) -> *mut _cef_textfield_t {
        ImplTextfield::get_raw(self)
    }
}
impl ConvertReturnValue<Textfield> for *mut _cef_textfield_t {
    fn wrap_result(self) -> Textfield {
        Textfield(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Textfield> for *mut _cef_textfield_t {
    fn from(value: Textfield) -> Self {
        let object = ImplTextfield::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Textfield {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_browser_view_delegate_t`] for more documentation.
#[derive(Clone)]
pub struct BrowserViewDelegate(RefGuard<_cef_browser_view_delegate_t>);
impl BrowserViewDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapBrowserViewDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplBrowserViewDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapBrowserViewDelegate>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_browser_view_delegate_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapBrowserViewDelegate: ImplBrowserViewDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_browser_view_delegate_t, Self>);
}
pub trait ImplBrowserViewDelegate: ImplViewDelegate {
    #[doc = "See [`_cef_browser_view_delegate_t::on_browser_created`] for more documentation."]
    fn on_browser_created(
        &self,
        browser_view: Option<&mut BrowserView>,
        browser: Option<&mut Browser>,
    ) {
    }
    #[doc = "See [`_cef_browser_view_delegate_t::on_browser_destroyed`] for more documentation."]
    fn on_browser_destroyed(
        &self,
        browser_view: Option<&mut BrowserView>,
        browser: Option<&mut Browser>,
    ) {
    }
    #[doc = "See [`_cef_browser_view_delegate_t::get_delegate_for_popup_browser_view`] for more documentation."]
    fn delegate_for_popup_browser_view(
        &self,
        browser_view: Option<&mut BrowserView>,
        settings: Option<&BrowserSettings>,
        client: Option<&mut impl ImplClient>,
        is_devtools: ::std::os::raw::c_int,
    ) -> Option<BrowserViewDelegate> {
        Default::default()
    }
    #[doc = "See [`_cef_browser_view_delegate_t::on_popup_browser_view_created`] for more documentation."]
    fn on_popup_browser_view_created(
        &self,
        browser_view: Option<&mut BrowserView>,
        popup_browser_view: Option<&mut BrowserView>,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_browser_view_delegate_t::get_chrome_toolbar_type`] for more documentation."]
    fn chrome_toolbar_type(&self, browser_view: Option<&mut BrowserView>) -> ChromeToolbarType {
        Default::default()
    }
    #[doc = "See [`_cef_browser_view_delegate_t::use_frameless_window_for_picture_in_picture`] for more documentation."]
    fn use_frameless_window_for_picture_in_picture(
        &self,
        browser_view: Option<&mut BrowserView>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_browser_view_delegate_t::on_gesture_command`] for more documentation."]
    fn on_gesture_command(
        &self,
        browser_view: Option<&mut BrowserView>,
        gesture_command: GestureCommand,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_browser_view_delegate_t::get_browser_runtime_style`] for more documentation."]
    fn browser_runtime_style(&self) -> RuntimeStyle {
        Default::default()
    }
    fn init_methods(object: &mut _cef_browser_view_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_browser_view_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_browser_view_delegate_t {
        <Self as ImplViewDelegate>::get_raw(self).cast()
    }
}
mod impl_cef_browser_view_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplBrowserViewDelegate>(object: &mut _cef_browser_view_delegate_t) {
        object.on_browser_created = Some(on_browser_created::<I>);
        object.on_browser_destroyed = Some(on_browser_destroyed::<I>);
        object.get_delegate_for_popup_browser_view = Some(get_delegate_for_popup_browser_view::<I>);
        object.on_popup_browser_view_created = Some(on_popup_browser_view_created::<I>);
        object.get_chrome_toolbar_type = Some(get_chrome_toolbar_type::<I>);
        object.use_frameless_window_for_picture_in_picture =
            Some(use_frameless_window_for_picture_in_picture::<I>);
        object.on_gesture_command = Some(on_gesture_command::<I>);
        object.get_browser_runtime_style = Some(get_browser_runtime_style::<I>);
    }
    extern "C" fn on_browser_created<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser_view, arg_browser) = (self_, browser_view, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplBrowserViewDelegate::on_browser_created(
            &arg_self_.interface,
            arg_browser_view,
            arg_browser,
        )
    }
    extern "C" fn on_browser_destroyed<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        browser: *mut _cef_browser_t,
    ) {
        let (arg_self_, arg_browser_view, arg_browser) = (self_, browser_view, browser);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let mut arg_browser =
            unsafe { arg_browser.as_mut() }.map(|arg| Browser(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser = arg_browser.as_mut();
        ImplBrowserViewDelegate::on_browser_destroyed(
            &arg_self_.interface,
            arg_browser_view,
            arg_browser,
        )
    }
    extern "C" fn get_delegate_for_popup_browser_view<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        settings: *const _cef_browser_settings_t,
        client: *mut _cef_client_t,
        is_devtools: ::std::os::raw::c_int,
    ) -> *mut _cef_browser_view_delegate_t {
        let (arg_self_, arg_browser_view, arg_settings, arg_client, arg_is_devtools) =
            (self_, browser_view, settings, client, is_devtools);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let arg_settings = if arg_settings.is_null() {
            None
        } else {
            Some(WrapParamRef::<BrowserSettings, _>::from(arg_settings))
        };
        let arg_settings = arg_settings.as_ref().map(|arg| arg.as_ref());
        let mut arg_client =
            unsafe { arg_client.as_mut() }.map(|arg| Client(unsafe { RefGuard::from_raw(arg) }));
        let arg_client = arg_client.as_mut();
        let arg_is_devtools = arg_is_devtools.into_raw();
        let result = ImplBrowserViewDelegate::delegate_for_popup_browser_view(
            &arg_self_.interface,
            arg_browser_view,
            arg_settings,
            arg_client,
            arg_is_devtools,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn on_popup_browser_view_created<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        popup_browser_view: *mut _cef_browser_view_t,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view, arg_popup_browser_view, arg_is_devtools) =
            (self_, browser_view, popup_browser_view, is_devtools);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let mut arg_popup_browser_view = unsafe { arg_popup_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_popup_browser_view = arg_popup_browser_view.as_mut();
        let arg_is_devtools = arg_is_devtools.into_raw();
        ImplBrowserViewDelegate::on_popup_browser_view_created(
            &arg_self_.interface,
            arg_browser_view,
            arg_popup_browser_view,
            arg_is_devtools,
        )
    }
    extern "C" fn get_chrome_toolbar_type<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
    ) -> cef_chrome_toolbar_type_t {
        let (arg_self_, arg_browser_view) = (self_, browser_view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let result =
            ImplBrowserViewDelegate::chrome_toolbar_type(&arg_self_.interface, arg_browser_view);
        result.into()
    }
    extern "C" fn use_frameless_window_for_picture_in_picture<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view) = (self_, browser_view);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        ImplBrowserViewDelegate::use_frameless_window_for_picture_in_picture(
            &arg_self_.interface,
            arg_browser_view,
        )
    }
    extern "C" fn on_gesture_command<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
        browser_view: *mut _cef_browser_view_t,
        gesture_command: cef_gesture_command_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_browser_view, arg_gesture_command) =
            (self_, browser_view, gesture_command);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_browser_view = unsafe { arg_browser_view.as_mut() }
            .map(|arg| BrowserView(unsafe { RefGuard::from_raw(arg) }));
        let arg_browser_view = arg_browser_view.as_mut();
        let arg_gesture_command = arg_gesture_command.into_raw();
        ImplBrowserViewDelegate::on_gesture_command(
            &arg_self_.interface,
            arg_browser_view,
            arg_gesture_command,
        )
    }
    extern "C" fn get_browser_runtime_style<I: ImplBrowserViewDelegate>(
        self_: *mut _cef_browser_view_delegate_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplBrowserViewDelegate::browser_runtime_style(&arg_self_.interface);
        result.into()
    }
}
impl ImplViewDelegate for BrowserViewDelegate {
    fn preferred_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .preferred_size(view)
    }
    fn minimum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .minimum_size(view)
    }
    fn maximum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .maximum_size(view)
    }
    fn height_for_width(
        &self,
        view: Option<&mut View>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        child: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut View>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut View>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl ImplBrowserViewDelegate for BrowserViewDelegate {
    fn on_browser_created(
        &self,
        browser_view: Option<&mut BrowserView>,
        browser: Option<&mut Browser>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_browser_created {
                let (arg_browser_view, arg_browser) = (browser_view, browser);
                let arg_self_ = self.into_raw();
                let arg_browser_view = arg_browser_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowserView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser_view, arg_browser);
            }
        }
    }
    fn on_browser_destroyed(
        &self,
        browser_view: Option<&mut BrowserView>,
        browser: Option<&mut Browser>,
    ) {
        unsafe {
            if let Some(f) = self.0.on_browser_destroyed {
                let (arg_browser_view, arg_browser) = (browser_view, browser);
                let arg_self_ = self.into_raw();
                let arg_browser_view = arg_browser_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowserView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_browser = arg_browser
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowser::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser_view, arg_browser);
            }
        }
    }
    fn delegate_for_popup_browser_view(
        &self,
        browser_view: Option<&mut BrowserView>,
        settings: Option<&BrowserSettings>,
        client: Option<&mut impl ImplClient>,
        is_devtools: ::std::os::raw::c_int,
    ) -> Option<BrowserViewDelegate> {
        unsafe {
            self.0
                .get_delegate_for_popup_browser_view
                .map(|f| {
                    let (arg_browser_view, arg_settings, arg_client, arg_is_devtools) =
                        (browser_view, settings, client, is_devtools);
                    let arg_self_ = self.into_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let arg_client = arg_client
                        .map(|arg| {
                            arg.add_ref();
                            ImplClient::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser_view,
                        arg_settings,
                        arg_client,
                        arg_is_devtools,
                    );
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn on_popup_browser_view_created(
        &self,
        browser_view: Option<&mut BrowserView>,
        popup_browser_view: Option<&mut BrowserView>,
        is_devtools: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_popup_browser_view_created
                .map(|f| {
                    let (arg_browser_view, arg_popup_browser_view, arg_is_devtools) =
                        (browser_view, popup_browser_view, is_devtools);
                    let arg_self_ = self.into_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_popup_browser_view = arg_popup_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(
                        arg_self_,
                        arg_browser_view,
                        arg_popup_browser_view,
                        arg_is_devtools,
                    );
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn chrome_toolbar_type(&self, browser_view: Option<&mut BrowserView>) -> ChromeToolbarType {
        unsafe {
            self.0
                .get_chrome_toolbar_type
                .map(|f| {
                    let arg_browser_view = browser_view;
                    let arg_self_ = self.into_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser_view);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn use_frameless_window_for_picture_in_picture(
        &self,
        browser_view: Option<&mut BrowserView>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .use_frameless_window_for_picture_in_picture
                .map(|f| {
                    let arg_browser_view = browser_view;
                    let arg_self_ = self.into_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_browser_view);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_gesture_command(
        &self,
        browser_view: Option<&mut BrowserView>,
        gesture_command: GestureCommand,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_gesture_command
                .map(|f| {
                    let (arg_browser_view, arg_gesture_command) = (browser_view, gesture_command);
                    let arg_self_ = self.into_raw();
                    let arg_browser_view = arg_browser_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplBrowserView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_gesture_command = arg_gesture_command.into_raw();
                    let result = f(arg_self_, arg_browser_view, arg_gesture_command);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn browser_runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_browser_runtime_style
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_view_delegate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_browser_view_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserViewDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_view_delegate_t> for &BrowserViewDelegate {
    fn into_raw(self) -> *mut _cef_browser_view_delegate_t {
        ImplBrowserViewDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_view_delegate_t> for &mut BrowserViewDelegate {
    fn into_raw(self) -> *mut _cef_browser_view_delegate_t {
        ImplBrowserViewDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<BrowserViewDelegate> for *mut _cef_browser_view_delegate_t {
    fn wrap_result(self) -> BrowserViewDelegate {
        BrowserViewDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<BrowserViewDelegate> for *mut _cef_browser_view_delegate_t {
    fn from(value: BrowserViewDelegate) -> Self {
        let object = ImplBrowserViewDelegate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for BrowserViewDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_browser_view_t`] for more documentation.
#[derive(Clone)]
pub struct BrowserView(RefGuard<_cef_browser_view_t>);
pub trait ImplBrowserView: ImplView {
    #[doc = "See [`_cef_browser_view_t::get_browser`] for more documentation."]
    fn browser(&self) -> Option<Browser>;
    #[doc = "See [`_cef_browser_view_t::get_chrome_toolbar`] for more documentation."]
    fn chrome_toolbar(&self) -> Option<View>;
    #[doc = "See [`_cef_browser_view_t::set_prefer_accelerators`] for more documentation."]
    fn set_prefer_accelerators(&self, prefer_accelerators: ::std::os::raw::c_int);
    #[doc = "See [`_cef_browser_view_t::get_runtime_style`] for more documentation."]
    fn runtime_style(&self) -> RuntimeStyle;
    fn get_raw(&self) -> *mut _cef_browser_view_t {
        <Self as ImplView>::get_raw(self).cast()
    }
}
impl ImplView for BrowserView {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View::from(self).as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View::from(self).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View::from(self).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View::from(self).as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View::from(self).as_textfield()
    }
    fn type_string(&self) -> CefStringUserfree {
        View::from(self).type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        View::from(self).to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View::from(self).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View::from(self).is_attached()
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        View::from(self).is_same(that)
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        View::from(self).delegate()
    }
    fn window(&self) -> Option<Window> {
        View::from(self).window()
    }
    fn id(&self) -> ::std::os::raw::c_int {
        View::from(self).id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View::from(self).set_id(id)
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        View::from(self).group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View::from(self).set_group_id(group_id)
    }
    fn parent_view(&self) -> Option<View> {
        View::from(self).parent_view()
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View::from(self).view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View::from(self).set_bounds(bounds)
    }
    fn bounds(&self) -> Rect {
        View::from(self).bounds()
    }
    fn bounds_in_screen(&self) -> Rect {
        View::from(self).bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View::from(self).set_size(size)
    }
    fn size(&self) -> Size {
        View::from(self).size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View::from(self).set_position(position)
    }
    fn position(&self) -> Point {
        View::from(self).position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View::from(self).set_insets(insets)
    }
    fn insets(&self) -> Insets {
        View::from(self).insets()
    }
    fn preferred_size(&self) -> Size {
        View::from(self).preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View::from(self).size_to_preferred_size()
    }
    fn minimum_size(&self) -> Size {
        View::from(self).minimum_size()
    }
    fn maximum_size(&self) -> Size {
        View::from(self).maximum_size()
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View::from(self).height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View::from(self).invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View::from(self).set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View::from(self).is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View::from(self).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View::from(self).set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View::from(self).is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View::from(self).set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View::from(self).has_focus()
    }
    fn request_focus(&self) {
        View::from(self).request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View::from(self).set_background_color(color)
    }
    fn background_color(&self) -> cef_color_t {
        View::from(self).background_color()
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View::from(self).theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&BrowserView> for View {
    fn from(from: &BrowserView) -> Self {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplBrowserView for BrowserView {
    fn browser(&self) -> Option<Browser> {
        unsafe {
            self.0
                .get_browser
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn chrome_toolbar(&self) -> Option<View> {
        unsafe {
            self.0
                .get_chrome_toolbar
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_prefer_accelerators(&self, prefer_accelerators: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_prefer_accelerators {
                let arg_prefer_accelerators = prefer_accelerators;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_prefer_accelerators);
            }
        }
    }
    fn runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_browser_view_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_browser_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for BrowserView {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_browser_view_t> for &BrowserView {
    fn into_raw(self) -> *mut _cef_browser_view_t {
        ImplBrowserView::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_browser_view_t> for &mut BrowserView {
    fn into_raw(self) -> *mut _cef_browser_view_t {
        ImplBrowserView::get_raw(self)
    }
}
impl ConvertReturnValue<BrowserView> for *mut _cef_browser_view_t {
    fn wrap_result(self) -> BrowserView {
        BrowserView(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<BrowserView> for *mut _cef_browser_view_t {
    fn from(value: BrowserView) -> Self {
        let object = ImplBrowserView::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for BrowserView {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_scroll_view_t`] for more documentation.
#[derive(Clone)]
pub struct ScrollView(RefGuard<_cef_scroll_view_t>);
pub trait ImplScrollView: ImplView {
    #[doc = "See [`_cef_scroll_view_t::set_content_view`] for more documentation."]
    fn set_content_view(&self, view: Option<&mut View>);
    #[doc = "See [`_cef_scroll_view_t::get_content_view`] for more documentation."]
    fn content_view(&self) -> Option<View>;
    #[doc = "See [`_cef_scroll_view_t::get_visible_content_rect`] for more documentation."]
    fn visible_content_rect(&self) -> Rect;
    #[doc = "See [`_cef_scroll_view_t::has_horizontal_scrollbar`] for more documentation."]
    fn has_horizontal_scrollbar(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_scroll_view_t::get_horizontal_scrollbar_height`] for more documentation."]
    fn horizontal_scrollbar_height(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_scroll_view_t::has_vertical_scrollbar`] for more documentation."]
    fn has_vertical_scrollbar(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_scroll_view_t::get_vertical_scrollbar_width`] for more documentation."]
    fn vertical_scrollbar_width(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_scroll_view_t {
        <Self as ImplView>::get_raw(self).cast()
    }
}
impl ImplView for ScrollView {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View::from(self).as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View::from(self).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View::from(self).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View::from(self).as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View::from(self).as_textfield()
    }
    fn type_string(&self) -> CefStringUserfree {
        View::from(self).type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        View::from(self).to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View::from(self).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View::from(self).is_attached()
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        View::from(self).is_same(that)
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        View::from(self).delegate()
    }
    fn window(&self) -> Option<Window> {
        View::from(self).window()
    }
    fn id(&self) -> ::std::os::raw::c_int {
        View::from(self).id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View::from(self).set_id(id)
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        View::from(self).group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View::from(self).set_group_id(group_id)
    }
    fn parent_view(&self) -> Option<View> {
        View::from(self).parent_view()
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View::from(self).view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View::from(self).set_bounds(bounds)
    }
    fn bounds(&self) -> Rect {
        View::from(self).bounds()
    }
    fn bounds_in_screen(&self) -> Rect {
        View::from(self).bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View::from(self).set_size(size)
    }
    fn size(&self) -> Size {
        View::from(self).size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View::from(self).set_position(position)
    }
    fn position(&self) -> Point {
        View::from(self).position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View::from(self).set_insets(insets)
    }
    fn insets(&self) -> Insets {
        View::from(self).insets()
    }
    fn preferred_size(&self) -> Size {
        View::from(self).preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View::from(self).size_to_preferred_size()
    }
    fn minimum_size(&self) -> Size {
        View::from(self).minimum_size()
    }
    fn maximum_size(&self) -> Size {
        View::from(self).maximum_size()
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View::from(self).height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View::from(self).invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View::from(self).set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View::from(self).is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View::from(self).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View::from(self).set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View::from(self).is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View::from(self).set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View::from(self).has_focus()
    }
    fn request_focus(&self) {
        View::from(self).request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View::from(self).set_background_color(color)
    }
    fn background_color(&self) -> cef_color_t {
        View::from(self).background_color()
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View::from(self).theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&ScrollView> for View {
    fn from(from: &ScrollView) -> Self {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplScrollView for ScrollView {
    fn set_content_view(&self, view: Option<&mut View>) {
        unsafe {
            if let Some(f) = self.0.set_content_view {
                let arg_view = view;
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view);
            }
        }
    }
    fn content_view(&self) -> Option<View> {
        unsafe {
            self.0
                .get_content_view
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn visible_content_rect(&self) -> Rect {
        unsafe {
            self.0
                .get_visible_content_rect
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_horizontal_scrollbar(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_horizontal_scrollbar
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn horizontal_scrollbar_height(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_horizontal_scrollbar_height
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn has_vertical_scrollbar(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .has_vertical_scrollbar
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn vertical_scrollbar_width(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_vertical_scrollbar_width
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_scroll_view_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_scroll_view_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for ScrollView {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_scroll_view_t> for &ScrollView {
    fn into_raw(self) -> *mut _cef_scroll_view_t {
        ImplScrollView::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_scroll_view_t> for &mut ScrollView {
    fn into_raw(self) -> *mut _cef_scroll_view_t {
        ImplScrollView::get_raw(self)
    }
}
impl ConvertReturnValue<ScrollView> for *mut _cef_scroll_view_t {
    fn wrap_result(self) -> ScrollView {
        ScrollView(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<ScrollView> for *mut _cef_scroll_view_t {
    fn from(value: ScrollView) -> Self {
        let object = ImplScrollView::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for ScrollView {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_display_t`] for more documentation.
#[derive(Clone)]
pub struct Display(RefGuard<_cef_display_t>);
pub trait ImplDisplay: Clone + Sized + Rc {
    #[doc = "See [`_cef_display_t::get_id`] for more documentation."]
    fn id(&self) -> i64;
    #[doc = "See [`_cef_display_t::get_device_scale_factor`] for more documentation."]
    fn device_scale_factor(&self) -> f32;
    #[doc = "See [`_cef_display_t::convert_point_to_pixels`] for more documentation."]
    fn convert_point_to_pixels(&self, point: Option<&mut Point>);
    #[doc = "See [`_cef_display_t::convert_point_from_pixels`] for more documentation."]
    fn convert_point_from_pixels(&self, point: Option<&mut Point>);
    #[doc = "See [`_cef_display_t::get_bounds`] for more documentation."]
    fn bounds(&self) -> Rect;
    #[doc = "See [`_cef_display_t::get_work_area`] for more documentation."]
    fn work_area(&self) -> Rect;
    #[doc = "See [`_cef_display_t::get_rotation`] for more documentation."]
    fn rotation(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_display_t;
}
impl ImplDisplay for Display {
    fn id(&self) -> i64 {
        unsafe {
            self.0
                .get_id
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn device_scale_factor(&self) -> f32 {
        unsafe {
            self.0
                .get_device_scale_factor
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn convert_point_to_pixels(&self, point: Option<&mut Point>) {
        unsafe {
            if let Some(f) = self.0.convert_point_to_pixels {
                let arg_point = point;
                let arg_self_ = self.into_raw();
                let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                let arg_point = arg_point
                    .as_mut()
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_point);
            }
        }
    }
    fn convert_point_from_pixels(&self, point: Option<&mut Point>) {
        unsafe {
            if let Some(f) = self.0.convert_point_from_pixels {
                let arg_point = point;
                let arg_self_ = self.into_raw();
                let mut arg_point = arg_point.cloned().map(|arg| arg.into());
                let arg_point = arg_point
                    .as_mut()
                    .map(std::ptr::from_mut)
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_point);
            }
        }
    }
    fn bounds(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn work_area(&self) -> Rect {
        unsafe {
            self.0
                .get_work_area
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn rotation(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_rotation
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_display_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_display_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Display {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_display_t> for &Display {
    fn into_raw(self) -> *mut _cef_display_t {
        ImplDisplay::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_display_t> for &mut Display {
    fn into_raw(self) -> *mut _cef_display_t {
        ImplDisplay::get_raw(self)
    }
}
impl ConvertReturnValue<Display> for *mut _cef_display_t {
    fn wrap_result(self) -> Display {
        Display(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Display> for *mut _cef_display_t {
    fn from(value: Display) -> Self {
        let object = ImplDisplay::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Display {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_overlay_controller_t`] for more documentation.
#[derive(Clone)]
pub struct OverlayController(RefGuard<_cef_overlay_controller_t>);
pub trait ImplOverlayController: Clone + Sized + Rc {
    #[doc = "See [`_cef_overlay_controller_t::is_valid`] for more documentation."]
    fn is_valid(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_overlay_controller_t::is_same`] for more documentation."]
    fn is_same(&self, that: Option<&mut OverlayController>) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_overlay_controller_t::get_contents_view`] for more documentation."]
    fn contents_view(&self) -> Option<View>;
    #[doc = "See [`_cef_overlay_controller_t::get_window`] for more documentation."]
    fn window(&self) -> Option<Window>;
    #[doc = "See [`_cef_overlay_controller_t::get_docking_mode`] for more documentation."]
    fn docking_mode(&self) -> DockingMode;
    #[doc = "See [`_cef_overlay_controller_t::destroy`] for more documentation."]
    fn destroy(&self);
    #[doc = "See [`_cef_overlay_controller_t::set_bounds`] for more documentation."]
    fn set_bounds(&self, bounds: Option<&Rect>);
    #[doc = "See [`_cef_overlay_controller_t::get_bounds`] for more documentation."]
    fn bounds(&self) -> Rect;
    #[doc = "See [`_cef_overlay_controller_t::get_bounds_in_screen`] for more documentation."]
    fn bounds_in_screen(&self) -> Rect;
    #[doc = "See [`_cef_overlay_controller_t::set_size`] for more documentation."]
    fn set_size(&self, size: Option<&Size>);
    #[doc = "See [`_cef_overlay_controller_t::get_size`] for more documentation."]
    fn size(&self) -> Size;
    #[doc = "See [`_cef_overlay_controller_t::set_position`] for more documentation."]
    fn set_position(&self, position: Option<&Point>);
    #[doc = "See [`_cef_overlay_controller_t::get_position`] for more documentation."]
    fn position(&self) -> Point;
    #[doc = "See [`_cef_overlay_controller_t::set_insets`] for more documentation."]
    fn set_insets(&self, insets: Option<&Insets>);
    #[doc = "See [`_cef_overlay_controller_t::get_insets`] for more documentation."]
    fn insets(&self) -> Insets;
    #[doc = "See [`_cef_overlay_controller_t::size_to_preferred_size`] for more documentation."]
    fn size_to_preferred_size(&self);
    #[doc = "See [`_cef_overlay_controller_t::set_visible`] for more documentation."]
    fn set_visible(&self, visible: ::std::os::raw::c_int);
    #[doc = "See [`_cef_overlay_controller_t::is_visible`] for more documentation."]
    fn is_visible(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_overlay_controller_t::is_drawn`] for more documentation."]
    fn is_drawn(&self) -> ::std::os::raw::c_int;
    fn get_raw(&self) -> *mut _cef_overlay_controller_t;
}
impl ImplOverlayController for OverlayController {
    fn is_valid(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_valid
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_same(&self, that: Option<&mut OverlayController>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_same
                .map(|f| {
                    let arg_that = that;
                    let arg_self_ = self.into_raw();
                    let arg_that = arg_that
                        .map(|arg| {
                            arg.add_ref();
                            ImplOverlayController::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_that);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn contents_view(&self) -> Option<View> {
        unsafe {
            self.0
                .get_contents_view
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn window(&self) -> Option<Window> {
        unsafe {
            self.0
                .get_window
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn docking_mode(&self) -> DockingMode {
        unsafe {
            self.0
                .get_docking_mode
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn destroy(&self) {
        unsafe {
            if let Some(f) = self.0.destroy {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        unsafe {
            if let Some(f) = self.0.set_bounds {
                let arg_bounds = bounds;
                let arg_self_ = self.into_raw();
                let arg_bounds = arg_bounds.cloned().map(|arg| arg.into());
                let arg_bounds = arg_bounds
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_bounds);
            }
        }
    }
    fn bounds(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn bounds_in_screen(&self) -> Rect {
        unsafe {
            self.0
                .get_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_size(&self, size: Option<&Size>) {
        unsafe {
            if let Some(f) = self.0.set_size {
                let arg_size = size;
                let arg_self_ = self.into_raw();
                let arg_size = arg_size.cloned().map(|arg| arg.into());
                let arg_size = arg_size
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_size);
            }
        }
    }
    fn size(&self) -> Size {
        unsafe {
            self.0
                .get_size
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_position(&self, position: Option<&Point>) {
        unsafe {
            if let Some(f) = self.0.set_position {
                let arg_position = position;
                let arg_self_ = self.into_raw();
                let arg_position = arg_position.cloned().map(|arg| arg.into());
                let arg_position = arg_position
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_position);
            }
        }
    }
    fn position(&self) -> Point {
        unsafe {
            self.0
                .get_position
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        unsafe {
            if let Some(f) = self.0.set_insets {
                let arg_insets = insets;
                let arg_self_ = self.into_raw();
                let arg_insets = arg_insets.cloned().map(|arg| arg.into());
                let arg_insets = arg_insets
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_insets);
            }
        }
    }
    fn insets(&self) -> Insets {
        unsafe {
            self.0
                .get_insets
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn size_to_preferred_size(&self) {
        unsafe {
            if let Some(f) = self.0.size_to_preferred_size {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_visible {
                let arg_visible = visible;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_visible);
            }
        }
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_visible
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_drawn
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_overlay_controller_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_overlay_controller_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for OverlayController {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_overlay_controller_t> for &OverlayController {
    fn into_raw(self) -> *mut _cef_overlay_controller_t {
        ImplOverlayController::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_overlay_controller_t> for &mut OverlayController {
    fn into_raw(self) -> *mut _cef_overlay_controller_t {
        ImplOverlayController::get_raw(self)
    }
}
impl ConvertReturnValue<OverlayController> for *mut _cef_overlay_controller_t {
    fn wrap_result(self) -> OverlayController {
        OverlayController(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<OverlayController> for *mut _cef_overlay_controller_t {
    fn from(value: OverlayController) -> Self {
        let object = ImplOverlayController::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for OverlayController {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_panel_delegate_t`] for more documentation.
#[derive(Clone)]
pub struct PanelDelegate(RefGuard<_cef_panel_delegate_t>);
impl PanelDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapPanelDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplPanelDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapPanelDelegate>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_panel_delegate_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapPanelDelegate: ImplPanelDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_panel_delegate_t, Self>);
}
pub trait ImplPanelDelegate: ImplViewDelegate {
    fn init_methods(object: &mut _cef_panel_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_panel_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_panel_delegate_t {
        <Self as ImplViewDelegate>::get_raw(self).cast()
    }
}
mod impl_cef_panel_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplPanelDelegate>(object: &mut _cef_panel_delegate_t) {}
}
impl ImplViewDelegate for PanelDelegate {
    fn preferred_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .preferred_size(view)
    }
    fn minimum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .minimum_size(view)
    }
    fn maximum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .maximum_size(view)
    }
    fn height_for_width(
        &self,
        view: Option<&mut View>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        child: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut View>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut View>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl ImplPanelDelegate for PanelDelegate {
    fn get_raw(&self) -> *mut _cef_panel_delegate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_panel_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for PanelDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_panel_delegate_t> for &PanelDelegate {
    fn into_raw(self) -> *mut _cef_panel_delegate_t {
        ImplPanelDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_panel_delegate_t> for &mut PanelDelegate {
    fn into_raw(self) -> *mut _cef_panel_delegate_t {
        ImplPanelDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<PanelDelegate> for *mut _cef_panel_delegate_t {
    fn wrap_result(self) -> PanelDelegate {
        PanelDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<PanelDelegate> for *mut _cef_panel_delegate_t {
    fn from(value: PanelDelegate) -> Self {
        let object = ImplPanelDelegate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for PanelDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_panel_t`] for more documentation.
#[derive(Clone)]
pub struct Panel(RefGuard<_cef_panel_t>);
pub trait ImplPanel: ImplView {
    #[doc = "See [`_cef_panel_t::as_window`] for more documentation."]
    fn as_window(&self) -> Option<Window>;
    #[doc = "See [`_cef_panel_t::set_to_fill_layout`] for more documentation."]
    fn set_to_fill_layout(&self) -> Option<FillLayout>;
    #[doc = "See [`_cef_panel_t::set_to_box_layout`] for more documentation."]
    fn set_to_box_layout(&self, settings: Option<&BoxLayoutSettings>) -> Option<BoxLayout>;
    #[doc = "See [`_cef_panel_t::get_layout`] for more documentation."]
    fn get_layout(&self) -> Option<Layout>;
    #[doc = "See [`_cef_panel_t::layout`] for more documentation."]
    fn layout(&self);
    #[doc = "See [`_cef_panel_t::add_child_view`] for more documentation."]
    fn add_child_view(&self, view: Option<&mut View>);
    #[doc = "See [`_cef_panel_t::add_child_view_at`] for more documentation."]
    fn add_child_view_at(&self, view: Option<&mut View>, index: ::std::os::raw::c_int);
    #[doc = "See [`_cef_panel_t::reorder_child_view`] for more documentation."]
    fn reorder_child_view(&self, view: Option<&mut View>, index: ::std::os::raw::c_int);
    #[doc = "See [`_cef_panel_t::remove_child_view`] for more documentation."]
    fn remove_child_view(&self, view: Option<&mut View>);
    #[doc = "See [`_cef_panel_t::remove_all_child_views`] for more documentation."]
    fn remove_all_child_views(&self);
    #[doc = "See [`_cef_panel_t::get_child_view_count`] for more documentation."]
    fn child_view_count(&self) -> usize;
    #[doc = "See [`_cef_panel_t::get_child_view_at`] for more documentation."]
    fn child_view_at(&self, index: ::std::os::raw::c_int) -> Option<View>;
    fn get_raw(&self) -> *mut _cef_panel_t {
        <Self as ImplView>::get_raw(self).cast()
    }
}
impl ImplView for Panel {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View::from(self).as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View::from(self).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View::from(self).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View::from(self).as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View::from(self).as_textfield()
    }
    fn type_string(&self) -> CefStringUserfree {
        View::from(self).type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        View::from(self).to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View::from(self).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View::from(self).is_attached()
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        View::from(self).is_same(that)
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        View::from(self).delegate()
    }
    fn window(&self) -> Option<Window> {
        View::from(self).window()
    }
    fn id(&self) -> ::std::os::raw::c_int {
        View::from(self).id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View::from(self).set_id(id)
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        View::from(self).group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View::from(self).set_group_id(group_id)
    }
    fn parent_view(&self) -> Option<View> {
        View::from(self).parent_view()
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View::from(self).view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View::from(self).set_bounds(bounds)
    }
    fn bounds(&self) -> Rect {
        View::from(self).bounds()
    }
    fn bounds_in_screen(&self) -> Rect {
        View::from(self).bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View::from(self).set_size(size)
    }
    fn size(&self) -> Size {
        View::from(self).size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View::from(self).set_position(position)
    }
    fn position(&self) -> Point {
        View::from(self).position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View::from(self).set_insets(insets)
    }
    fn insets(&self) -> Insets {
        View::from(self).insets()
    }
    fn preferred_size(&self) -> Size {
        View::from(self).preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View::from(self).size_to_preferred_size()
    }
    fn minimum_size(&self) -> Size {
        View::from(self).minimum_size()
    }
    fn maximum_size(&self) -> Size {
        View::from(self).maximum_size()
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View::from(self).height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View::from(self).invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View::from(self).set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View::from(self).is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View::from(self).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View::from(self).set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View::from(self).is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View::from(self).set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View::from(self).has_focus()
    }
    fn request_focus(&self) {
        View::from(self).request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View::from(self).set_background_color(color)
    }
    fn background_color(&self) -> cef_color_t {
        View::from(self).background_color()
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View::from(self).theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&Panel> for View {
    fn from(from: &Panel) -> Self {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplPanel for Panel {
    fn as_window(&self) -> Option<Window> {
        unsafe {
            self.0
                .as_window
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_to_fill_layout(&self) -> Option<FillLayout> {
        unsafe {
            self.0
                .set_to_fill_layout
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_to_box_layout(&self, settings: Option<&BoxLayoutSettings>) -> Option<BoxLayout> {
        unsafe {
            self.0
                .set_to_box_layout
                .map(|f| {
                    let arg_settings = settings;
                    let arg_self_ = self.into_raw();
                    let arg_settings = arg_settings.cloned().map(|arg| arg.into());
                    let arg_settings = arg_settings
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_settings);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_layout(&self) -> Option<Layout> {
        unsafe {
            self.0
                .get_layout
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn layout(&self) {
        unsafe {
            if let Some(f) = self.0.layout {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn add_child_view(&self, view: Option<&mut View>) {
        unsafe {
            if let Some(f) = self.0.add_child_view {
                let arg_view = view;
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view);
            }
        }
    }
    fn add_child_view_at(&self, view: Option<&mut View>, index: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.add_child_view_at {
                let (arg_view, arg_index) = (view, index);
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view, arg_index);
            }
        }
    }
    fn reorder_child_view(&self, view: Option<&mut View>, index: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.reorder_child_view {
                let (arg_view, arg_index) = (view, index);
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view, arg_index);
            }
        }
    }
    fn remove_child_view(&self, view: Option<&mut View>) {
        unsafe {
            if let Some(f) = self.0.remove_child_view {
                let arg_view = view;
                let arg_self_ = self.into_raw();
                let arg_view = arg_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_view);
            }
        }
    }
    fn remove_all_child_views(&self) {
        unsafe {
            if let Some(f) = self.0.remove_all_child_views {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn child_view_count(&self) -> usize {
        unsafe {
            self.0
                .get_child_view_count
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn child_view_at(&self, index: ::std::os::raw::c_int) -> Option<View> {
        unsafe {
            self.0
                .get_child_view_at
                .map(|f| {
                    let arg_index = index;
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_, arg_index);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_panel_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_panel_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Panel {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_panel_t> for &Panel {
    fn into_raw(self) -> *mut _cef_panel_t {
        ImplPanel::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_panel_t> for &mut Panel {
    fn into_raw(self) -> *mut _cef_panel_t {
        ImplPanel::get_raw(self)
    }
}
impl ConvertReturnValue<Panel> for *mut _cef_panel_t {
    fn wrap_result(self) -> Panel {
        Panel(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Panel> for *mut _cef_panel_t {
    fn from(value: Panel) -> Self {
        let object = ImplPanel::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Panel {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_window_delegate_t`] for more documentation.
#[derive(Clone)]
pub struct WindowDelegate(RefGuard<_cef_window_delegate_t>);
impl WindowDelegate {
    pub fn new<T>(interface: T) -> Self
    where
        T: WrapWindowDelegate,
    {
        unsafe {
            let mut cef_object = std::mem::zeroed();
            <T as ImplWindowDelegate>::init_methods(&mut cef_object);
            let object = RcImpl::new(cef_object, interface);
            <T as WrapWindowDelegate>::wrap_rc(&mut (*object).interface, object);
            let object: *mut _cef_window_delegate_t = object.cast();
            object.wrap_result()
        }
    }
}
pub trait WrapWindowDelegate: ImplWindowDelegate {
    fn wrap_rc(&mut self, object: *mut RcImpl<_cef_window_delegate_t, Self>);
}
pub trait ImplWindowDelegate: ImplPanelDelegate {
    #[doc = "See [`_cef_window_delegate_t::on_window_created`] for more documentation."]
    fn on_window_created(&self, window: Option<&mut Window>) {}
    #[doc = "See [`_cef_window_delegate_t::on_window_closing`] for more documentation."]
    fn on_window_closing(&self, window: Option<&mut Window>) {}
    #[doc = "See [`_cef_window_delegate_t::on_window_destroyed`] for more documentation."]
    fn on_window_destroyed(&self, window: Option<&mut Window>) {}
    #[doc = "See [`_cef_window_delegate_t::on_window_activation_changed`] for more documentation."]
    fn on_window_activation_changed(
        &self,
        window: Option<&mut Window>,
        active: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_window_delegate_t::on_window_bounds_changed`] for more documentation."]
    fn on_window_bounds_changed(&self, window: Option<&mut Window>, new_bounds: Option<&Rect>) {}
    #[doc = "See [`_cef_window_delegate_t::on_window_fullscreen_transition`] for more documentation."]
    fn on_window_fullscreen_transition(
        &self,
        window: Option<&mut Window>,
        is_completed: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_window_delegate_t::get_parent_window`] for more documentation."]
    fn parent_window(
        &self,
        window: Option<&mut Window>,
        is_menu: Option<&mut ::std::os::raw::c_int>,
        can_activate_menu: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<Window> {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::is_window_modal_dialog`] for more documentation."]
    fn is_window_modal_dialog(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::get_initial_bounds`] for more documentation."]
    fn initial_bounds(&self, window: Option<&mut Window>) -> Rect {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::get_initial_show_state`] for more documentation."]
    fn initial_show_state(&self, window: Option<&mut Window>) -> ShowState {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::is_frameless`] for more documentation."]
    fn is_frameless(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::with_standard_window_buttons`] for more documentation."]
    fn with_standard_window_buttons(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::get_titlebar_height`] for more documentation."]
    fn titlebar_height(
        &self,
        window: Option<&mut Window>,
        titlebar_height: Option<&mut f32>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::accepts_first_mouse`] for more documentation."]
    fn accepts_first_mouse(&self, window: Option<&mut Window>) -> State {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::can_resize`] for more documentation."]
    fn can_resize(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::can_maximize`] for more documentation."]
    fn can_maximize(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::can_minimize`] for more documentation."]
    fn can_minimize(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::can_close`] for more documentation."]
    fn can_close(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::on_accelerator`] for more documentation."]
    fn on_accelerator(
        &self,
        window: Option<&mut Window>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::on_key_event`] for more documentation."]
    fn on_key_event(
        &self,
        window: Option<&mut Window>,
        event: Option<&KeyEvent>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::on_theme_colors_changed`] for more documentation."]
    fn on_theme_colors_changed(
        &self,
        window: Option<&mut Window>,
        chrome_theme: ::std::os::raw::c_int,
    ) {
    }
    #[doc = "See [`_cef_window_delegate_t::get_window_runtime_style`] for more documentation."]
    fn window_runtime_style(&self) -> RuntimeStyle {
        Default::default()
    }
    #[doc = "See [`_cef_window_delegate_t::get_linux_window_properties`] for more documentation."]
    fn linux_window_properties(
        &self,
        window: Option<&mut Window>,
        properties: Option<&mut LinuxWindowProperties>,
    ) -> ::std::os::raw::c_int {
        Default::default()
    }
    fn init_methods(object: &mut _cef_window_delegate_t) {
        impl_cef_view_delegate_t::init_methods::<Self>(&mut object.base.base);
        impl_cef_panel_delegate_t::init_methods::<Self>(&mut object.base);
        impl_cef_window_delegate_t::init_methods::<Self>(object);
    }
    fn get_raw(&self) -> *mut _cef_window_delegate_t {
        <Self as ImplPanelDelegate>::get_raw(self).cast()
    }
}
mod impl_cef_window_delegate_t {
    use super::*;
    pub fn init_methods<I: ImplWindowDelegate>(object: &mut _cef_window_delegate_t) {
        object.on_window_created = Some(on_window_created::<I>);
        object.on_window_closing = Some(on_window_closing::<I>);
        object.on_window_destroyed = Some(on_window_destroyed::<I>);
        object.on_window_activation_changed = Some(on_window_activation_changed::<I>);
        object.on_window_bounds_changed = Some(on_window_bounds_changed::<I>);
        object.on_window_fullscreen_transition = Some(on_window_fullscreen_transition::<I>);
        object.get_parent_window = Some(get_parent_window::<I>);
        object.is_window_modal_dialog = Some(is_window_modal_dialog::<I>);
        object.get_initial_bounds = Some(get_initial_bounds::<I>);
        object.get_initial_show_state = Some(get_initial_show_state::<I>);
        object.is_frameless = Some(is_frameless::<I>);
        object.with_standard_window_buttons = Some(with_standard_window_buttons::<I>);
        object.get_titlebar_height = Some(get_titlebar_height::<I>);
        object.accepts_first_mouse = Some(accepts_first_mouse::<I>);
        object.can_resize = Some(can_resize::<I>);
        object.can_maximize = Some(can_maximize::<I>);
        object.can_minimize = Some(can_minimize::<I>);
        object.can_close = Some(can_close::<I>);
        object.on_accelerator = Some(on_accelerator::<I>);
        object.on_key_event = Some(on_key_event::<I>);
        object.on_theme_colors_changed = Some(on_theme_colors_changed::<I>);
        object.get_window_runtime_style = Some(get_window_runtime_style::<I>);
        object.get_linux_window_properties = Some(get_linux_window_properties::<I>);
    }
    extern "C" fn on_window_created<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::on_window_created(&arg_self_.interface, arg_window)
    }
    extern "C" fn on_window_closing<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::on_window_closing(&arg_self_.interface, arg_window)
    }
    extern "C" fn on_window_destroyed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::on_window_destroyed(&arg_self_.interface, arg_window)
    }
    extern "C" fn on_window_activation_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        active: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_active) = (self_, window, active);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_active = arg_active.into_raw();
        ImplWindowDelegate::on_window_activation_changed(
            &arg_self_.interface,
            arg_window,
            arg_active,
        )
    }
    extern "C" fn on_window_bounds_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        new_bounds: *const _cef_rect_t,
    ) {
        let (arg_self_, arg_window, arg_new_bounds) = (self_, window, new_bounds);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_new_bounds = if arg_new_bounds.is_null() {
            None
        } else {
            Some(WrapParamRef::<Rect, _>::from(arg_new_bounds))
        };
        let arg_new_bounds = arg_new_bounds.as_ref().map(|arg| arg.as_ref());
        ImplWindowDelegate::on_window_bounds_changed(
            &arg_self_.interface,
            arg_window,
            arg_new_bounds,
        )
    }
    extern "C" fn on_window_fullscreen_transition<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        is_completed: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_is_completed) = (self_, window, is_completed);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_is_completed = arg_is_completed.into_raw();
        ImplWindowDelegate::on_window_fullscreen_transition(
            &arg_self_.interface,
            arg_window,
            arg_is_completed,
        )
    }
    extern "C" fn get_parent_window<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        is_menu: *mut ::std::os::raw::c_int,
        can_activate_menu: *mut ::std::os::raw::c_int,
    ) -> *mut _cef_window_t {
        let (arg_self_, arg_window, arg_is_menu, arg_can_activate_menu) =
            (self_, window, is_menu, can_activate_menu);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let mut arg_is_menu = if arg_is_menu.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(arg_is_menu))
        };
        let arg_is_menu = arg_is_menu.as_mut().map(|arg| arg.as_mut());
        let mut arg_can_activate_menu = if arg_can_activate_menu.is_null() {
            None
        } else {
            Some(WrapParamRef::<::std::os::raw::c_int, _>::from(
                arg_can_activate_menu,
            ))
        };
        let arg_can_activate_menu = arg_can_activate_menu.as_mut().map(|arg| arg.as_mut());
        let result = ImplWindowDelegate::parent_window(
            &arg_self_.interface,
            arg_window,
            arg_is_menu,
            arg_can_activate_menu,
        );
        result
            .map(|result| result.into())
            .unwrap_or(std::ptr::null_mut())
    }
    extern "C" fn is_window_modal_dialog<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::is_window_modal_dialog(&arg_self_.interface, arg_window)
    }
    extern "C" fn get_initial_bounds<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> _cef_rect_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::initial_bounds(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn get_initial_show_state<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> cef_show_state_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::initial_show_state(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn is_frameless<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::is_frameless(&arg_self_.interface, arg_window)
    }
    extern "C" fn with_standard_window_buttons<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::with_standard_window_buttons(&arg_self_.interface, arg_window)
    }
    extern "C" fn get_titlebar_height<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        titlebar_height: *mut f32,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_titlebar_height) = (self_, window, titlebar_height);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let mut arg_titlebar_height = if arg_titlebar_height.is_null() {
            None
        } else {
            Some(WrapParamRef::<f32, _>::from(arg_titlebar_height))
        };
        let arg_titlebar_height = arg_titlebar_height.as_mut().map(|arg| arg.as_mut());
        ImplWindowDelegate::titlebar_height(&arg_self_.interface, arg_window, arg_titlebar_height)
    }
    extern "C" fn accepts_first_mouse<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> cef_state_t {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let result = ImplWindowDelegate::accepts_first_mouse(&arg_self_.interface, arg_window);
        result.into()
    }
    extern "C" fn can_resize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::can_resize(&arg_self_.interface, arg_window)
    }
    extern "C" fn can_maximize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::can_maximize(&arg_self_.interface, arg_window)
    }
    extern "C" fn can_minimize<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::can_minimize(&arg_self_.interface, arg_window)
    }
    extern "C" fn can_close<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window) = (self_, window);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        ImplWindowDelegate::can_close(&arg_self_.interface, arg_window)
    }
    extern "C" fn on_accelerator<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_command_id) = (self_, window, command_id);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_command_id = arg_command_id.into_raw();
        ImplWindowDelegate::on_accelerator(&arg_self_.interface, arg_window, arg_command_id)
    }
    extern "C" fn on_key_event<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        event: *const _cef_key_event_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_event) = (self_, window, event);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_event = if arg_event.is_null() {
            None
        } else {
            Some(WrapParamRef::<KeyEvent, _>::from(arg_event))
        };
        let arg_event = arg_event.as_ref().map(|arg| arg.as_ref());
        ImplWindowDelegate::on_key_event(&arg_self_.interface, arg_window, arg_event)
    }
    extern "C" fn on_theme_colors_changed<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        chrome_theme: ::std::os::raw::c_int,
    ) {
        let (arg_self_, arg_window, arg_chrome_theme) = (self_, window, chrome_theme);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let arg_chrome_theme = arg_chrome_theme.into_raw();
        ImplWindowDelegate::on_theme_colors_changed(
            &arg_self_.interface,
            arg_window,
            arg_chrome_theme,
        )
    }
    extern "C" fn get_window_runtime_style<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
    ) -> cef_runtime_style_t {
        let arg_self_ = self_;
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let result = ImplWindowDelegate::window_runtime_style(&arg_self_.interface);
        result.into()
    }
    extern "C" fn get_linux_window_properties<I: ImplWindowDelegate>(
        self_: *mut _cef_window_delegate_t,
        window: *mut _cef_window_t,
        properties: *mut _cef_linux_window_properties_t,
    ) -> ::std::os::raw::c_int {
        let (arg_self_, arg_window, arg_properties) = (self_, window, properties);
        let arg_self_: &RcImpl<_, I> = RcImpl::get(arg_self_);
        let mut arg_window =
            unsafe { arg_window.as_mut() }.map(|arg| Window(unsafe { RefGuard::from_raw(arg) }));
        let arg_window = arg_window.as_mut();
        let mut arg_properties = if arg_properties.is_null() {
            None
        } else {
            Some(WrapParamRef::<LinuxWindowProperties, _>::from(
                arg_properties,
            ))
        };
        let arg_properties = arg_properties.as_mut().map(|arg| arg.as_mut());
        ImplWindowDelegate::linux_window_properties(
            &arg_self_.interface,
            arg_window,
            arg_properties,
        )
    }
}
impl ImplViewDelegate for WindowDelegate {
    fn preferred_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .preferred_size(view)
    }
    fn minimum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .minimum_size(view)
    }
    fn maximum_size(&self, view: Option<&mut View>) -> Size {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .maximum_size(view)
    }
    fn height_for_width(
        &self,
        view: Option<&mut View>,
        width: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .height_for_width(view, width)
    }
    fn on_parent_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        parent: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_parent_view_changed(view, added, parent)
    }
    fn on_child_view_changed(
        &self,
        view: Option<&mut View>,
        added: ::std::os::raw::c_int,
        child: Option<&mut View>,
    ) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_child_view_changed(view, added, child)
    }
    fn on_window_changed(&self, view: Option<&mut View>, added: ::std::os::raw::c_int) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_window_changed(view, added)
    }
    fn on_layout_changed(&self, view: Option<&mut View>, new_bounds: Option<&Rect>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_layout_changed(view, new_bounds)
    }
    fn on_focus(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_focus(view)
    }
    fn on_blur(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_blur(view)
    }
    fn on_theme_changed(&self, view: Option<&mut View>) {
        ViewDelegate(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&self.0).cast()) })
            .on_theme_changed(view)
    }
    fn get_raw(&self) -> *mut _cef_view_delegate_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl ImplPanelDelegate for WindowDelegate {
    fn get_raw(&self) -> *mut _cef_panel_delegate_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl ImplWindowDelegate for WindowDelegate {
    fn on_window_created(&self, window: Option<&mut Window>) {
        unsafe {
            if let Some(f) = self.0.on_window_created {
                let arg_window = window;
                let arg_self_ = self.into_raw();
                let arg_window = arg_window
                    .map(|arg| {
                        arg.add_ref();
                        ImplWindow::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_window);
            }
        }
    }
    fn on_window_closing(&self, window: Option<&mut Window>) {
        unsafe {
            if let Some(f) = self.0.on_window_closing {
                let arg_window = window;
                let arg_self_ = self.into_raw();
                let arg_window = arg_window
                    .map(|arg| {
                        arg.add_ref();
                        ImplWindow::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_window);
            }
        }
    }
    fn on_window_destroyed(&self, window: Option<&mut Window>) {
        unsafe {
            if let Some(f) = self.0.on_window_destroyed {
                let arg_window = window;
                let arg_self_ = self.into_raw();
                let arg_window = arg_window
                    .map(|arg| {
                        arg.add_ref();
                        ImplWindow::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_window);
            }
        }
    }
    fn on_window_activation_changed(
        &self,
        window: Option<&mut Window>,
        active: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_window_activation_changed {
                let (arg_window, arg_active) = (window, active);
                let arg_self_ = self.into_raw();
                let arg_window = arg_window
                    .map(|arg| {
                        arg.add_ref();
                        ImplWindow::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_window, arg_active);
            }
        }
    }
    fn on_window_bounds_changed(&self, window: Option<&mut Window>, new_bounds: Option<&Rect>) {
        unsafe {
            if let Some(f) = self.0.on_window_bounds_changed {
                let (arg_window, arg_new_bounds) = (window, new_bounds);
                let arg_self_ = self.into_raw();
                let arg_window = arg_window
                    .map(|arg| {
                        arg.add_ref();
                        ImplWindow::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_new_bounds = arg_new_bounds.cloned().map(|arg| arg.into());
                let arg_new_bounds = arg_new_bounds
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_window, arg_new_bounds);
            }
        }
    }
    fn on_window_fullscreen_transition(
        &self,
        window: Option<&mut Window>,
        is_completed: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_window_fullscreen_transition {
                let (arg_window, arg_is_completed) = (window, is_completed);
                let arg_self_ = self.into_raw();
                let arg_window = arg_window
                    .map(|arg| {
                        arg.add_ref();
                        ImplWindow::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_window, arg_is_completed);
            }
        }
    }
    fn parent_window(
        &self,
        window: Option<&mut Window>,
        is_menu: Option<&mut ::std::os::raw::c_int>,
        can_activate_menu: Option<&mut ::std::os::raw::c_int>,
    ) -> Option<Window> {
        unsafe {
            self.0
                .get_parent_window
                .map(|f| {
                    let (arg_window, arg_is_menu, arg_can_activate_menu) =
                        (window, is_menu, can_activate_menu);
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_is_menu = arg_is_menu
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let arg_can_activate_menu = arg_can_activate_menu
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window, arg_is_menu, arg_can_activate_menu);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn is_window_modal_dialog(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_window_modal_dialog
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn initial_bounds(&self, window: Option<&mut Window>) -> Rect {
        unsafe {
            self.0
                .get_initial_bounds
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn initial_show_state(&self, window: Option<&mut Window>) -> ShowState {
        unsafe {
            self.0
                .get_initial_show_state
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_frameless(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_frameless
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn with_standard_window_buttons(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .with_standard_window_buttons
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn titlebar_height(
        &self,
        window: Option<&mut Window>,
        titlebar_height: Option<&mut f32>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_titlebar_height
                .map(|f| {
                    let (arg_window, arg_titlebar_height) = (window, titlebar_height);
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_titlebar_height = arg_titlebar_height
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window, arg_titlebar_height);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn accepts_first_mouse(&self, window: Option<&mut Window>) -> State {
        unsafe {
            self.0
                .accepts_first_mouse
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn can_resize(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_resize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn can_maximize(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_maximize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn can_minimize(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_minimize
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn can_close(&self, window: Option<&mut Window>) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .can_close
                .map(|f| {
                    let arg_window = window;
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_accelerator(
        &self,
        window: Option<&mut Window>,
        command_id: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_accelerator
                .map(|f| {
                    let (arg_window, arg_command_id) = (window, command_id);
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window, arg_command_id);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_key_event(
        &self,
        window: Option<&mut Window>,
        event: Option<&KeyEvent>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .on_key_event
                .map(|f| {
                    let (arg_window, arg_event) = (window, event);
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_event = arg_event.cloned().map(|arg| arg.into());
                    let arg_event = arg_event
                        .as_ref()
                        .map(std::ptr::from_ref)
                        .unwrap_or(std::ptr::null());
                    let result = f(arg_self_, arg_window, arg_event);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn on_theme_colors_changed(
        &self,
        window: Option<&mut Window>,
        chrome_theme: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.on_theme_colors_changed {
                let (arg_window, arg_chrome_theme) = (window, chrome_theme);
                let arg_self_ = self.into_raw();
                let arg_window = arg_window
                    .map(|arg| {
                        arg.add_ref();
                        ImplWindow::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_window, arg_chrome_theme);
            }
        }
    }
    fn window_runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_window_runtime_style
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn linux_window_properties(
        &self,
        window: Option<&mut Window>,
        properties: Option<&mut LinuxWindowProperties>,
    ) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .get_linux_window_properties
                .map(|f| {
                    let (arg_window, arg_properties) = (window, properties);
                    let arg_self_ = self.into_raw();
                    let arg_window = arg_window
                        .map(|arg| {
                            arg.add_ref();
                            ImplWindow::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let mut arg_properties = arg_properties.cloned().map(|arg| arg.into());
                    let arg_properties = arg_properties
                        .as_mut()
                        .map(std::ptr::from_mut)
                        .unwrap_or(std::ptr::null_mut());
                    let result = f(arg_self_, arg_window, arg_properties);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_window_delegate_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_window_delegate_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for WindowDelegate {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_window_delegate_t> for &WindowDelegate {
    fn into_raw(self) -> *mut _cef_window_delegate_t {
        ImplWindowDelegate::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_window_delegate_t> for &mut WindowDelegate {
    fn into_raw(self) -> *mut _cef_window_delegate_t {
        ImplWindowDelegate::get_raw(self)
    }
}
impl ConvertReturnValue<WindowDelegate> for *mut _cef_window_delegate_t {
    fn wrap_result(self) -> WindowDelegate {
        WindowDelegate(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<WindowDelegate> for *mut _cef_window_delegate_t {
    fn from(value: WindowDelegate) -> Self {
        let object = ImplWindowDelegate::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for WindowDelegate {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`_cef_window_t`] for more documentation.
#[derive(Clone)]
pub struct Window(RefGuard<_cef_window_t>);
pub trait ImplWindow: ImplPanel {
    #[doc = "See [`_cef_window_t::show`] for more documentation."]
    fn show(&self);
    #[doc = "See [`_cef_window_t::show_as_browser_modal_dialog`] for more documentation."]
    fn show_as_browser_modal_dialog(&self, browser_view: Option<&mut BrowserView>);
    #[doc = "See [`_cef_window_t::hide`] for more documentation."]
    fn hide(&self);
    #[doc = "See [`_cef_window_t::center_window`] for more documentation."]
    fn center_window(&self, size: Option<&Size>);
    #[doc = "See [`_cef_window_t::close`] for more documentation."]
    fn close(&self);
    #[doc = "See [`_cef_window_t::is_closed`] for more documentation."]
    fn is_closed(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_window_t::activate`] for more documentation."]
    fn activate(&self);
    #[doc = "See [`_cef_window_t::deactivate`] for more documentation."]
    fn deactivate(&self);
    #[doc = "See [`_cef_window_t::is_active`] for more documentation."]
    fn is_active(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_window_t::bring_to_top`] for more documentation."]
    fn bring_to_top(&self);
    #[doc = "See [`_cef_window_t::set_always_on_top`] for more documentation."]
    fn set_always_on_top(&self, on_top: ::std::os::raw::c_int);
    #[doc = "See [`_cef_window_t::is_always_on_top`] for more documentation."]
    fn is_always_on_top(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_window_t::maximize`] for more documentation."]
    fn maximize(&self);
    #[doc = "See [`_cef_window_t::minimize`] for more documentation."]
    fn minimize(&self);
    #[doc = "See [`_cef_window_t::restore`] for more documentation."]
    fn restore(&self);
    #[doc = "See [`_cef_window_t::set_fullscreen`] for more documentation."]
    fn set_fullscreen(&self, fullscreen: ::std::os::raw::c_int);
    #[doc = "See [`_cef_window_t::is_maximized`] for more documentation."]
    fn is_maximized(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_window_t::is_minimized`] for more documentation."]
    fn is_minimized(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_window_t::is_fullscreen`] for more documentation."]
    fn is_fullscreen(&self) -> ::std::os::raw::c_int;
    #[doc = "See [`_cef_window_t::get_focused_view`] for more documentation."]
    fn focused_view(&self) -> Option<View>;
    #[doc = "See [`_cef_window_t::set_title`] for more documentation."]
    fn set_title(&self, title: Option<&CefString>);
    #[doc = "See [`_cef_window_t::get_title`] for more documentation."]
    fn title(&self) -> CefStringUserfree;
    #[doc = "See [`_cef_window_t::set_window_icon`] for more documentation."]
    fn set_window_icon(&self, image: Option<&mut Image>);
    #[doc = "See [`_cef_window_t::get_window_icon`] for more documentation."]
    fn window_icon(&self) -> Option<Image>;
    #[doc = "See [`_cef_window_t::set_window_app_icon`] for more documentation."]
    fn set_window_app_icon(&self, image: Option<&mut Image>);
    #[doc = "See [`_cef_window_t::get_window_app_icon`] for more documentation."]
    fn window_app_icon(&self) -> Option<Image>;
    #[doc = "See [`_cef_window_t::add_overlay_view`] for more documentation."]
    fn add_overlay_view(
        &self,
        view: Option<&mut View>,
        docking_mode: DockingMode,
        can_activate: ::std::os::raw::c_int,
    ) -> Option<OverlayController>;
    #[doc = "See [`_cef_window_t::show_menu`] for more documentation."]
    fn show_menu(
        &self,
        menu_model: Option<&mut MenuModel>,
        screen_point: Option<&Point>,
        anchor_position: MenuAnchorPosition,
    );
    #[doc = "See [`_cef_window_t::cancel_menu`] for more documentation."]
    fn cancel_menu(&self);
    #[doc = "See [`_cef_window_t::get_display`] for more documentation."]
    fn display(&self) -> Option<Display>;
    #[doc = "See [`_cef_window_t::get_client_area_bounds_in_screen`] for more documentation."]
    fn client_area_bounds_in_screen(&self) -> Rect;
    #[doc = "See [`_cef_window_t::set_draggable_regions`] for more documentation."]
    fn set_draggable_regions(&self, regions_count: usize, regions: Option<&DraggableRegion>);
    #[doc = "See [`_cef_window_t::get_window_handle`] for more documentation."]
    fn window_handle(&self) -> cef_window_handle_t;
    #[doc = "See [`_cef_window_t::send_key_press`] for more documentation."]
    fn send_key_press(&self, key_code: ::std::os::raw::c_int, event_flags: u32);
    #[doc = "See [`_cef_window_t::send_mouse_move`] for more documentation."]
    fn send_mouse_move(&self, screen_x: ::std::os::raw::c_int, screen_y: ::std::os::raw::c_int);
    #[doc = "See [`_cef_window_t::send_mouse_events`] for more documentation."]
    fn send_mouse_events(
        &self,
        button: MouseButtonType,
        mouse_down: ::std::os::raw::c_int,
        mouse_up: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_window_t::set_accelerator`] for more documentation."]
    fn set_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
        high_priority: ::std::os::raw::c_int,
    );
    #[doc = "See [`_cef_window_t::remove_accelerator`] for more documentation."]
    fn remove_accelerator(&self, command_id: ::std::os::raw::c_int);
    #[doc = "See [`_cef_window_t::remove_all_accelerators`] for more documentation."]
    fn remove_all_accelerators(&self);
    #[doc = "See [`_cef_window_t::set_theme_color`] for more documentation."]
    fn set_theme_color(&self, color_id: ::std::os::raw::c_int, color: u32);
    #[doc = "See [`_cef_window_t::theme_changed`] for more documentation."]
    fn theme_changed(&self);
    #[doc = "See [`_cef_window_t::get_runtime_style`] for more documentation."]
    fn runtime_style(&self) -> RuntimeStyle;
    fn get_raw(&self) -> *mut _cef_window_t {
        <Self as ImplPanel>::get_raw(self).cast()
    }
}
impl ImplView for Window {
    fn as_browser_view(&self) -> Option<BrowserView> {
        View::from(self).as_browser_view()
    }
    fn as_button(&self) -> Option<Button> {
        View::from(self).as_button()
    }
    fn as_panel(&self) -> Option<Panel> {
        View::from(self).as_panel()
    }
    fn as_scroll_view(&self) -> Option<ScrollView> {
        View::from(self).as_scroll_view()
    }
    fn as_textfield(&self) -> Option<Textfield> {
        View::from(self).as_textfield()
    }
    fn type_string(&self) -> CefStringUserfree {
        View::from(self).type_string()
    }
    fn to_string(&self, include_children: ::std::os::raw::c_int) -> CefStringUserfree {
        View::from(self).to_string(include_children)
    }
    fn is_valid(&self) -> ::std::os::raw::c_int {
        View::from(self).is_valid()
    }
    fn is_attached(&self) -> ::std::os::raw::c_int {
        View::from(self).is_attached()
    }
    fn is_same(&self, that: Option<&mut View>) -> ::std::os::raw::c_int {
        View::from(self).is_same(that)
    }
    fn delegate(&self) -> Option<ViewDelegate> {
        View::from(self).delegate()
    }
    fn window(&self) -> Option<Window> {
        View::from(self).window()
    }
    fn id(&self) -> ::std::os::raw::c_int {
        View::from(self).id()
    }
    fn set_id(&self, id: ::std::os::raw::c_int) {
        View::from(self).set_id(id)
    }
    fn group_id(&self) -> ::std::os::raw::c_int {
        View::from(self).group_id()
    }
    fn set_group_id(&self, group_id: ::std::os::raw::c_int) {
        View::from(self).set_group_id(group_id)
    }
    fn parent_view(&self) -> Option<View> {
        View::from(self).parent_view()
    }
    fn view_for_id(&self, id: ::std::os::raw::c_int) -> Option<View> {
        View::from(self).view_for_id(id)
    }
    fn set_bounds(&self, bounds: Option<&Rect>) {
        View::from(self).set_bounds(bounds)
    }
    fn bounds(&self) -> Rect {
        View::from(self).bounds()
    }
    fn bounds_in_screen(&self) -> Rect {
        View::from(self).bounds_in_screen()
    }
    fn set_size(&self, size: Option<&Size>) {
        View::from(self).set_size(size)
    }
    fn size(&self) -> Size {
        View::from(self).size()
    }
    fn set_position(&self, position: Option<&Point>) {
        View::from(self).set_position(position)
    }
    fn position(&self) -> Point {
        View::from(self).position()
    }
    fn set_insets(&self, insets: Option<&Insets>) {
        View::from(self).set_insets(insets)
    }
    fn insets(&self) -> Insets {
        View::from(self).insets()
    }
    fn preferred_size(&self) -> Size {
        View::from(self).preferred_size()
    }
    fn size_to_preferred_size(&self) {
        View::from(self).size_to_preferred_size()
    }
    fn minimum_size(&self) -> Size {
        View::from(self).minimum_size()
    }
    fn maximum_size(&self) -> Size {
        View::from(self).maximum_size()
    }
    fn height_for_width(&self, width: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        View::from(self).height_for_width(width)
    }
    fn invalidate_layout(&self) {
        View::from(self).invalidate_layout()
    }
    fn set_visible(&self, visible: ::std::os::raw::c_int) {
        View::from(self).set_visible(visible)
    }
    fn is_visible(&self) -> ::std::os::raw::c_int {
        View::from(self).is_visible()
    }
    fn is_drawn(&self) -> ::std::os::raw::c_int {
        View::from(self).is_drawn()
    }
    fn set_enabled(&self, enabled: ::std::os::raw::c_int) {
        View::from(self).set_enabled(enabled)
    }
    fn is_enabled(&self) -> ::std::os::raw::c_int {
        View::from(self).is_enabled()
    }
    fn set_focusable(&self, focusable: ::std::os::raw::c_int) {
        View::from(self).set_focusable(focusable)
    }
    fn is_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_focusable()
    }
    fn is_accessibility_focusable(&self) -> ::std::os::raw::c_int {
        View::from(self).is_accessibility_focusable()
    }
    fn has_focus(&self) -> ::std::os::raw::c_int {
        View::from(self).has_focus()
    }
    fn request_focus(&self) {
        View::from(self).request_focus()
    }
    fn set_background_color(&self, color: u32) {
        View::from(self).set_background_color(color)
    }
    fn background_color(&self) -> cef_color_t {
        View::from(self).background_color()
    }
    fn theme_color(&self, color_id: ::std::os::raw::c_int) -> cef_color_t {
        View::from(self).theme_color(color_id)
    }
    fn convert_point_to_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_screen(point)
    }
    fn convert_point_from_screen(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_screen(point)
    }
    fn convert_point_to_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_window(point)
    }
    fn convert_point_from_window(&self, point: Option<&mut Point>) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_window(point)
    }
    fn convert_point_to_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_to_view(view, point)
    }
    fn convert_point_from_view(
        &self,
        view: Option<&mut View>,
        point: Option<&mut Point>,
    ) -> ::std::os::raw::c_int {
        View::from(self).convert_point_from_view(view, point)
    }
    fn get_raw(&self) -> *mut _cef_view_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&Window> for View {
    fn from(from: &Window) -> Self {
        View(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplPanel for Window {
    fn as_window(&self) -> Option<Window> {
        Panel::from(self).as_window()
    }
    fn set_to_fill_layout(&self) -> Option<FillLayout> {
        Panel::from(self).set_to_fill_layout()
    }
    fn set_to_box_layout(&self, settings: Option<&BoxLayoutSettings>) -> Option<BoxLayout> {
        Panel::from(self).set_to_box_layout(settings)
    }
    fn get_layout(&self) -> Option<Layout> {
        Panel::from(self).get_layout()
    }
    fn layout(&self) {
        Panel::from(self).layout()
    }
    fn add_child_view(&self, view: Option<&mut View>) {
        Panel::from(self).add_child_view(view)
    }
    fn add_child_view_at(&self, view: Option<&mut View>, index: ::std::os::raw::c_int) {
        Panel::from(self).add_child_view_at(view, index)
    }
    fn reorder_child_view(&self, view: Option<&mut View>, index: ::std::os::raw::c_int) {
        Panel::from(self).reorder_child_view(view, index)
    }
    fn remove_child_view(&self, view: Option<&mut View>) {
        Panel::from(self).remove_child_view(view)
    }
    fn remove_all_child_views(&self) {
        Panel::from(self).remove_all_child_views()
    }
    fn child_view_count(&self) -> usize {
        Panel::from(self).child_view_count()
    }
    fn child_view_at(&self, index: ::std::os::raw::c_int) -> Option<View> {
        Panel::from(self).child_view_at(index)
    }
    fn get_raw(&self) -> *mut _cef_panel_t {
        unsafe { RefGuard::into_raw(&self.0).cast() }
    }
}
impl std::convert::From<&Window> for Panel {
    fn from(from: &Window) -> Self {
        Panel(unsafe { RefGuard::from_raw_add_ref(RefGuard::into_raw(&from.0).cast()) })
    }
}
impl ImplWindow for Window {
    fn show(&self) {
        unsafe {
            if let Some(f) = self.0.show {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn show_as_browser_modal_dialog(&self, browser_view: Option<&mut BrowserView>) {
        unsafe {
            if let Some(f) = self.0.show_as_browser_modal_dialog {
                let arg_browser_view = browser_view;
                let arg_self_ = self.into_raw();
                let arg_browser_view = arg_browser_view
                    .map(|arg| {
                        arg.add_ref();
                        ImplBrowserView::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_browser_view);
            }
        }
    }
    fn hide(&self) {
        unsafe {
            if let Some(f) = self.0.hide {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn center_window(&self, size: Option<&Size>) {
        unsafe {
            if let Some(f) = self.0.center_window {
                let arg_size = size;
                let arg_self_ = self.into_raw();
                let arg_size = arg_size.cloned().map(|arg| arg.into());
                let arg_size = arg_size
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_size);
            }
        }
    }
    fn close(&self) {
        unsafe {
            if let Some(f) = self.0.close {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn is_closed(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_closed
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn activate(&self) {
        unsafe {
            if let Some(f) = self.0.activate {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn deactivate(&self) {
        unsafe {
            if let Some(f) = self.0.deactivate {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn is_active(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_active
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn bring_to_top(&self) {
        unsafe {
            if let Some(f) = self.0.bring_to_top {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_always_on_top(&self, on_top: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_always_on_top {
                let arg_on_top = on_top;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_on_top);
            }
        }
    }
    fn is_always_on_top(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_always_on_top
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn maximize(&self) {
        unsafe {
            if let Some(f) = self.0.maximize {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn minimize(&self) {
        unsafe {
            if let Some(f) = self.0.minimize {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn restore(&self) {
        unsafe {
            if let Some(f) = self.0.restore {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_fullscreen(&self, fullscreen: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.set_fullscreen {
                let arg_fullscreen = fullscreen;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_fullscreen);
            }
        }
    }
    fn is_maximized(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_maximized
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_minimized(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_minimized
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn is_fullscreen(&self) -> ::std::os::raw::c_int {
        unsafe {
            self.0
                .is_fullscreen
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn focused_view(&self) -> Option<View> {
        unsafe {
            self.0
                .get_focused_view
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_title(&self, title: Option<&CefString>) {
        unsafe {
            if let Some(f) = self.0.set_title {
                let arg_title = title;
                let arg_self_ = self.into_raw();
                let arg_title = arg_title
                    .map(|arg| arg.into_raw())
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_title);
            }
        }
    }
    fn title(&self) -> CefStringUserfree {
        unsafe {
            self.0
                .get_title
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_window_icon(&self, image: Option<&mut Image>) {
        unsafe {
            if let Some(f) = self.0.set_window_icon {
                let arg_image = image;
                let arg_self_ = self.into_raw();
                let arg_image = arg_image
                    .map(|arg| {
                        arg.add_ref();
                        ImplImage::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_image);
            }
        }
    }
    fn window_icon(&self) -> Option<Image> {
        unsafe {
            self.0
                .get_window_icon
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn set_window_app_icon(&self, image: Option<&mut Image>) {
        unsafe {
            if let Some(f) = self.0.set_window_app_icon {
                let arg_image = image;
                let arg_self_ = self.into_raw();
                let arg_image = arg_image
                    .map(|arg| {
                        arg.add_ref();
                        ImplImage::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                f(arg_self_, arg_image);
            }
        }
    }
    fn window_app_icon(&self) -> Option<Image> {
        unsafe {
            self.0
                .get_window_app_icon
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn add_overlay_view(
        &self,
        view: Option<&mut View>,
        docking_mode: DockingMode,
        can_activate: ::std::os::raw::c_int,
    ) -> Option<OverlayController> {
        unsafe {
            self.0
                .add_overlay_view
                .map(|f| {
                    let (arg_view, arg_docking_mode, arg_can_activate) =
                        (view, docking_mode, can_activate);
                    let arg_self_ = self.into_raw();
                    let arg_view = arg_view
                        .map(|arg| {
                            arg.add_ref();
                            ImplView::get_raw(arg)
                        })
                        .unwrap_or(std::ptr::null_mut());
                    let arg_docking_mode = arg_docking_mode.into_raw();
                    let result = f(arg_self_, arg_view, arg_docking_mode, arg_can_activate);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn show_menu(
        &self,
        menu_model: Option<&mut MenuModel>,
        screen_point: Option<&Point>,
        anchor_position: MenuAnchorPosition,
    ) {
        unsafe {
            if let Some(f) = self.0.show_menu {
                let (arg_menu_model, arg_screen_point, arg_anchor_position) =
                    (menu_model, screen_point, anchor_position);
                let arg_self_ = self.into_raw();
                let arg_menu_model = arg_menu_model
                    .map(|arg| {
                        arg.add_ref();
                        ImplMenuModel::get_raw(arg)
                    })
                    .unwrap_or(std::ptr::null_mut());
                let arg_screen_point = arg_screen_point.cloned().map(|arg| arg.into());
                let arg_screen_point = arg_screen_point
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                let arg_anchor_position = arg_anchor_position.into_raw();
                f(
                    arg_self_,
                    arg_menu_model,
                    arg_screen_point,
                    arg_anchor_position,
                );
            }
        }
    }
    fn cancel_menu(&self) {
        unsafe {
            if let Some(f) = self.0.cancel_menu {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn display(&self) -> Option<Display> {
        unsafe {
            self.0
                .get_display
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    if result.is_null() {
                        None
                    } else {
                        Some(result.wrap_result())
                    }
                })
                .unwrap_or_default()
        }
    }
    fn client_area_bounds_in_screen(&self) -> Rect {
        unsafe {
            self.0
                .get_client_area_bounds_in_screen
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn set_draggable_regions(&self, regions_count: usize, regions: Option<&DraggableRegion>) {
        unsafe {
            if let Some(f) = self.0.set_draggable_regions {
                let (arg_regions_count, arg_regions) = (regions_count, regions);
                let arg_self_ = self.into_raw();
                let arg_regions = arg_regions.cloned().map(|arg| arg.into());
                let arg_regions = arg_regions
                    .as_ref()
                    .map(std::ptr::from_ref)
                    .unwrap_or(std::ptr::null());
                f(arg_self_, arg_regions_count, arg_regions);
            }
        }
    }
    fn window_handle(&self) -> cef_window_handle_t {
        unsafe {
            self.0
                .get_window_handle
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_else(|| std::mem::zeroed())
        }
    }
    fn send_key_press(&self, key_code: ::std::os::raw::c_int, event_flags: u32) {
        unsafe {
            if let Some(f) = self.0.send_key_press {
                let (arg_key_code, arg_event_flags) = (key_code, event_flags);
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_key_code, arg_event_flags);
            }
        }
    }
    fn send_mouse_move(&self, screen_x: ::std::os::raw::c_int, screen_y: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.send_mouse_move {
                let (arg_screen_x, arg_screen_y) = (screen_x, screen_y);
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_screen_x, arg_screen_y);
            }
        }
    }
    fn send_mouse_events(
        &self,
        button: MouseButtonType,
        mouse_down: ::std::os::raw::c_int,
        mouse_up: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.send_mouse_events {
                let (arg_button, arg_mouse_down, arg_mouse_up) = (button, mouse_down, mouse_up);
                let arg_self_ = self.into_raw();
                let arg_button = arg_button.into_raw();
                f(arg_self_, arg_button, arg_mouse_down, arg_mouse_up);
            }
        }
    }
    fn set_accelerator(
        &self,
        command_id: ::std::os::raw::c_int,
        key_code: ::std::os::raw::c_int,
        shift_pressed: ::std::os::raw::c_int,
        ctrl_pressed: ::std::os::raw::c_int,
        alt_pressed: ::std::os::raw::c_int,
        high_priority: ::std::os::raw::c_int,
    ) {
        unsafe {
            if let Some(f) = self.0.set_accelerator {
                let (
                    arg_command_id,
                    arg_key_code,
                    arg_shift_pressed,
                    arg_ctrl_pressed,
                    arg_alt_pressed,
                    arg_high_priority,
                ) = (
                    command_id,
                    key_code,
                    shift_pressed,
                    ctrl_pressed,
                    alt_pressed,
                    high_priority,
                );
                let arg_self_ = self.into_raw();
                f(
                    arg_self_,
                    arg_command_id,
                    arg_key_code,
                    arg_shift_pressed,
                    arg_ctrl_pressed,
                    arg_alt_pressed,
                    arg_high_priority,
                );
            }
        }
    }
    fn remove_accelerator(&self, command_id: ::std::os::raw::c_int) {
        unsafe {
            if let Some(f) = self.0.remove_accelerator {
                let arg_command_id = command_id;
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_command_id);
            }
        }
    }
    fn remove_all_accelerators(&self) {
        unsafe {
            if let Some(f) = self.0.remove_all_accelerators {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn set_theme_color(&self, color_id: ::std::os::raw::c_int, color: u32) {
        unsafe {
            if let Some(f) = self.0.set_theme_color {
                let (arg_color_id, arg_color) = (color_id, color);
                let arg_self_ = self.into_raw();
                f(arg_self_, arg_color_id, arg_color);
            }
        }
    }
    fn theme_changed(&self) {
        unsafe {
            if let Some(f) = self.0.theme_changed {
                let arg_self_ = self.into_raw();
                f(arg_self_);
            }
        }
    }
    fn runtime_style(&self) -> RuntimeStyle {
        unsafe {
            self.0
                .get_runtime_style
                .map(|f| {
                    let arg_self_ = self.into_raw();
                    let result = f(arg_self_);
                    result.wrap_result()
                })
                .unwrap_or_default()
        }
    }
    fn get_raw(&self) -> *mut _cef_window_t {
        unsafe { RefGuard::into_raw(&self.0) }
    }
}
impl Rc for _cef_window_t {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.base.as_base()
    }
}
impl Rc for Window {
    fn as_base(&self) -> &_cef_base_ref_counted_t {
        self.0.as_base()
    }
}
impl ConvertParam<*mut _cef_window_t> for &Window {
    fn into_raw(self) -> *mut _cef_window_t {
        ImplWindow::get_raw(self)
    }
}
impl ConvertParam<*mut _cef_window_t> for &mut Window {
    fn into_raw(self) -> *mut _cef_window_t {
        ImplWindow::get_raw(self)
    }
}
impl ConvertReturnValue<Window> for *mut _cef_window_t {
    fn wrap_result(self) -> Window {
        Window(unsafe { RefGuard::from_raw(self) })
    }
}
impl From<Window> for *mut _cef_window_t {
    fn from(value: Window) -> Self {
        let object = ImplWindow::get_raw(&value);
        std::mem::forget(value);
        object
    }
}
impl Default for Window {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`cef_content_setting_types_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContentSettingTypes(cef_content_setting_types_t);
impl AsRef<cef_content_setting_types_t> for ContentSettingTypes {
    fn as_ref(&self) -> &cef_content_setting_types_t {
        &self.0
    }
}
impl AsMut<cef_content_setting_types_t> for ContentSettingTypes {
    fn as_mut(&mut self) -> &mut cef_content_setting_types_t {
        &mut self.0
    }
}
impl From<cef_content_setting_types_t> for ContentSettingTypes {
    fn from(value: cef_content_setting_types_t) -> Self {
        Self(value)
    }
}
impl From<ContentSettingTypes> for cef_content_setting_types_t {
    fn from(value: ContentSettingTypes) -> Self {
        value.0
    }
}
impl Default for ContentSettingTypes {
    fn default() -> Self {
        Self(cef_content_setting_types_t::CEF_CONTENT_SETTING_TYPE_COOKIES)
    }
}

/// See [`cef_content_setting_values_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContentSettingValues(cef_content_setting_values_t);
impl AsRef<cef_content_setting_values_t> for ContentSettingValues {
    fn as_ref(&self) -> &cef_content_setting_values_t {
        &self.0
    }
}
impl AsMut<cef_content_setting_values_t> for ContentSettingValues {
    fn as_mut(&mut self) -> &mut cef_content_setting_values_t {
        &mut self.0
    }
}
impl From<cef_content_setting_values_t> for ContentSettingValues {
    fn from(value: cef_content_setting_values_t) -> Self {
        Self(value)
    }
}
impl From<ContentSettingValues> for cef_content_setting_values_t {
    fn from(value: ContentSettingValues) -> Self {
        value.0
    }
}
impl Default for ContentSettingValues {
    fn default() -> Self {
        Self(cef_content_setting_values_t::CEF_CONTENT_SETTING_VALUE_DEFAULT)
    }
}

/// See [`cef_color_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorType(cef_color_type_t);
impl AsRef<cef_color_type_t> for ColorType {
    fn as_ref(&self) -> &cef_color_type_t {
        &self.0
    }
}
impl AsMut<cef_color_type_t> for ColorType {
    fn as_mut(&mut self) -> &mut cef_color_type_t {
        &mut self.0
    }
}
impl From<cef_color_type_t> for ColorType {
    fn from(value: cef_color_type_t) -> Self {
        Self(value)
    }
}
impl From<ColorType> for cef_color_type_t {
    fn from(value: ColorType) -> Self {
        value.0
    }
}
impl Default for ColorType {
    fn default() -> Self {
        Self(cef_color_type_t::CEF_COLOR_TYPE_RGBA_8888)
    }
}

/// See [`cef_runtime_style_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct RuntimeStyle(cef_runtime_style_t);
impl AsRef<cef_runtime_style_t> for RuntimeStyle {
    fn as_ref(&self) -> &cef_runtime_style_t {
        &self.0
    }
}
impl AsMut<cef_runtime_style_t> for RuntimeStyle {
    fn as_mut(&mut self) -> &mut cef_runtime_style_t {
        &mut self.0
    }
}
impl From<cef_runtime_style_t> for RuntimeStyle {
    fn from(value: cef_runtime_style_t) -> Self {
        Self(value)
    }
}
impl From<RuntimeStyle> for cef_runtime_style_t {
    fn from(value: RuntimeStyle) -> Self {
        value.0
    }
}
impl Default for RuntimeStyle {
    fn default() -> Self {
        Self(cef_runtime_style_t::CEF_RUNTIME_STYLE_DEFAULT)
    }
}

/// See [`cef_log_severity_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LogSeverity(cef_log_severity_t);
impl AsRef<cef_log_severity_t> for LogSeverity {
    fn as_ref(&self) -> &cef_log_severity_t {
        &self.0
    }
}
impl AsMut<cef_log_severity_t> for LogSeverity {
    fn as_mut(&mut self) -> &mut cef_log_severity_t {
        &mut self.0
    }
}
impl From<cef_log_severity_t> for LogSeverity {
    fn from(value: cef_log_severity_t) -> Self {
        Self(value)
    }
}
impl From<LogSeverity> for cef_log_severity_t {
    fn from(value: LogSeverity) -> Self {
        value.0
    }
}
impl Default for LogSeverity {
    fn default() -> Self {
        Self(cef_log_severity_t::LOGSEVERITY_DEFAULT)
    }
}

/// See [`cef_log_items_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct LogItems(cef_log_items_t);
impl AsRef<cef_log_items_t> for LogItems {
    fn as_ref(&self) -> &cef_log_items_t {
        &self.0
    }
}
impl AsMut<cef_log_items_t> for LogItems {
    fn as_mut(&mut self) -> &mut cef_log_items_t {
        &mut self.0
    }
}
impl From<cef_log_items_t> for LogItems {
    fn from(value: cef_log_items_t) -> Self {
        Self(value)
    }
}
impl From<LogItems> for cef_log_items_t {
    fn from(value: LogItems) -> Self {
        value.0
    }
}
impl Default for LogItems {
    fn default() -> Self {
        Self(cef_log_items_t::LOG_ITEMS_DEFAULT)
    }
}

/// See [`cef_state_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct State(cef_state_t);
impl AsRef<cef_state_t> for State {
    fn as_ref(&self) -> &cef_state_t {
        &self.0
    }
}
impl AsMut<cef_state_t> for State {
    fn as_mut(&mut self) -> &mut cef_state_t {
        &mut self.0
    }
}
impl From<cef_state_t> for State {
    fn from(value: cef_state_t) -> Self {
        Self(value)
    }
}
impl From<State> for cef_state_t {
    fn from(value: State) -> Self {
        value.0
    }
}
impl Default for State {
    fn default() -> Self {
        Self(cef_state_t::STATE_DEFAULT)
    }
}

/// See [`cef_return_value_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ReturnValue(cef_return_value_t);
impl AsRef<cef_return_value_t> for ReturnValue {
    fn as_ref(&self) -> &cef_return_value_t {
        &self.0
    }
}
impl AsMut<cef_return_value_t> for ReturnValue {
    fn as_mut(&mut self) -> &mut cef_return_value_t {
        &mut self.0
    }
}
impl From<cef_return_value_t> for ReturnValue {
    fn from(value: cef_return_value_t) -> Self {
        Self(value)
    }
}
impl From<ReturnValue> for cef_return_value_t {
    fn from(value: ReturnValue) -> Self {
        value.0
    }
}
impl Default for ReturnValue {
    fn default() -> Self {
        Self(cef_return_value_t::RV_CANCEL)
    }
}

/// See [`cef_cookie_priority_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CookiePriority(cef_cookie_priority_t);
impl AsRef<cef_cookie_priority_t> for CookiePriority {
    fn as_ref(&self) -> &cef_cookie_priority_t {
        &self.0
    }
}
impl AsMut<cef_cookie_priority_t> for CookiePriority {
    fn as_mut(&mut self) -> &mut cef_cookie_priority_t {
        &mut self.0
    }
}
impl From<cef_cookie_priority_t> for CookiePriority {
    fn from(value: cef_cookie_priority_t) -> Self {
        Self(value)
    }
}
impl From<CookiePriority> for cef_cookie_priority_t {
    fn from(value: CookiePriority) -> Self {
        value.0
    }
}
impl Default for CookiePriority {
    fn default() -> Self {
        Self(cef_cookie_priority_t::CEF_COOKIE_PRIORITY_LOW)
    }
}

/// See [`cef_cookie_same_site_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CookieSameSite(cef_cookie_same_site_t);
impl AsRef<cef_cookie_same_site_t> for CookieSameSite {
    fn as_ref(&self) -> &cef_cookie_same_site_t {
        &self.0
    }
}
impl AsMut<cef_cookie_same_site_t> for CookieSameSite {
    fn as_mut(&mut self) -> &mut cef_cookie_same_site_t {
        &mut self.0
    }
}
impl From<cef_cookie_same_site_t> for CookieSameSite {
    fn from(value: cef_cookie_same_site_t) -> Self {
        Self(value)
    }
}
impl From<CookieSameSite> for cef_cookie_same_site_t {
    fn from(value: CookieSameSite) -> Self {
        value.0
    }
}
impl Default for CookieSameSite {
    fn default() -> Self {
        Self(cef_cookie_same_site_t::CEF_COOKIE_SAME_SITE_UNSPECIFIED)
    }
}

/// See [`cef_termination_status_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TerminationStatus(cef_termination_status_t);
impl AsRef<cef_termination_status_t> for TerminationStatus {
    fn as_ref(&self) -> &cef_termination_status_t {
        &self.0
    }
}
impl AsMut<cef_termination_status_t> for TerminationStatus {
    fn as_mut(&mut self) -> &mut cef_termination_status_t {
        &mut self.0
    }
}
impl From<cef_termination_status_t> for TerminationStatus {
    fn from(value: cef_termination_status_t) -> Self {
        Self(value)
    }
}
impl From<TerminationStatus> for cef_termination_status_t {
    fn from(value: TerminationStatus) -> Self {
        value.0
    }
}
impl Default for TerminationStatus {
    fn default() -> Self {
        Self(cef_termination_status_t::TS_ABNORMAL_TERMINATION)
    }
}

/// See [`cef_path_key_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PathKey(cef_path_key_t);
impl AsRef<cef_path_key_t> for PathKey {
    fn as_ref(&self) -> &cef_path_key_t {
        &self.0
    }
}
impl AsMut<cef_path_key_t> for PathKey {
    fn as_mut(&mut self) -> &mut cef_path_key_t {
        &mut self.0
    }
}
impl From<cef_path_key_t> for PathKey {
    fn from(value: cef_path_key_t) -> Self {
        Self(value)
    }
}
impl From<PathKey> for cef_path_key_t {
    fn from(value: PathKey) -> Self {
        value.0
    }
}
impl Default for PathKey {
    fn default() -> Self {
        Self(cef_path_key_t::PK_DIR_CURRENT)
    }
}

/// See [`cef_storage_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct StorageType(cef_storage_type_t);
impl AsRef<cef_storage_type_t> for StorageType {
    fn as_ref(&self) -> &cef_storage_type_t {
        &self.0
    }
}
impl AsMut<cef_storage_type_t> for StorageType {
    fn as_mut(&mut self) -> &mut cef_storage_type_t {
        &mut self.0
    }
}
impl From<cef_storage_type_t> for StorageType {
    fn from(value: cef_storage_type_t) -> Self {
        Self(value)
    }
}
impl From<StorageType> for cef_storage_type_t {
    fn from(value: StorageType) -> Self {
        value.0
    }
}
impl Default for StorageType {
    fn default() -> Self {
        Self(cef_storage_type_t::ST_LOCALSTORAGE)
    }
}

/// See [`cef_errorcode_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Errorcode(cef_errorcode_t);
impl AsRef<cef_errorcode_t> for Errorcode {
    fn as_ref(&self) -> &cef_errorcode_t {
        &self.0
    }
}
impl AsMut<cef_errorcode_t> for Errorcode {
    fn as_mut(&mut self) -> &mut cef_errorcode_t {
        &mut self.0
    }
}
impl From<cef_errorcode_t> for Errorcode {
    fn from(value: cef_errorcode_t) -> Self {
        Self(value)
    }
}
impl From<Errorcode> for cef_errorcode_t {
    fn from(value: Errorcode) -> Self {
        value.0
    }
}
impl Default for Errorcode {
    fn default() -> Self {
        Self(cef_errorcode_t::ERR_NONE)
    }
}

/// See [`cef_cert_status_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CertStatus(cef_cert_status_t);
impl AsRef<cef_cert_status_t> for CertStatus {
    fn as_ref(&self) -> &cef_cert_status_t {
        &self.0
    }
}
impl AsMut<cef_cert_status_t> for CertStatus {
    fn as_mut(&mut self) -> &mut cef_cert_status_t {
        &mut self.0
    }
}
impl From<cef_cert_status_t> for CertStatus {
    fn from(value: cef_cert_status_t) -> Self {
        Self(value)
    }
}
impl From<CertStatus> for cef_cert_status_t {
    fn from(value: CertStatus) -> Self {
        value.0
    }
}
impl Default for CertStatus {
    fn default() -> Self {
        Self(cef_cert_status_t::CERT_STATUS_NONE)
    }
}

/// See [`cef_resultcode_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct Resultcode(cef_resultcode_t);
impl AsRef<cef_resultcode_t> for Resultcode {
    fn as_ref(&self) -> &cef_resultcode_t {
        &self.0
    }
}
impl AsMut<cef_resultcode_t> for Resultcode {
    fn as_mut(&mut self) -> &mut cef_resultcode_t {
        &mut self.0
    }
}
impl From<cef_resultcode_t> for Resultcode {
    fn from(value: cef_resultcode_t) -> Self {
        Self(value)
    }
}
impl From<Resultcode> for cef_resultcode_t {
    fn from(value: Resultcode) -> Self {
        value.0
    }
}
impl Default for Resultcode {
    fn default() -> Self {
        Self(cef_resultcode_t::CEF_RESULT_CODE_NORMAL_EXIT)
    }
}

/// See [`cef_window_open_disposition_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct WindowOpenDisposition(cef_window_open_disposition_t);
impl AsRef<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn as_ref(&self) -> &cef_window_open_disposition_t {
        &self.0
    }
}
impl AsMut<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn as_mut(&mut self) -> &mut cef_window_open_disposition_t {
        &mut self.0
    }
}
impl From<cef_window_open_disposition_t> for WindowOpenDisposition {
    fn from(value: cef_window_open_disposition_t) -> Self {
        Self(value)
    }
}
impl From<WindowOpenDisposition> for cef_window_open_disposition_t {
    fn from(value: WindowOpenDisposition) -> Self {
        value.0
    }
}
impl Default for WindowOpenDisposition {
    fn default() -> Self {
        Self(cef_window_open_disposition_t::CEF_WOD_UNKNOWN)
    }
}

/// See [`cef_drag_operations_mask_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DragOperationsMask(cef_drag_operations_mask_t);
impl AsRef<cef_drag_operations_mask_t> for DragOperationsMask {
    fn as_ref(&self) -> &cef_drag_operations_mask_t {
        &self.0
    }
}
impl AsMut<cef_drag_operations_mask_t> for DragOperationsMask {
    fn as_mut(&mut self) -> &mut cef_drag_operations_mask_t {
        &mut self.0
    }
}
impl From<cef_drag_operations_mask_t> for DragOperationsMask {
    fn from(value: cef_drag_operations_mask_t) -> Self {
        Self(value)
    }
}
impl From<DragOperationsMask> for cef_drag_operations_mask_t {
    fn from(value: DragOperationsMask) -> Self {
        value.0
    }
}
impl Default for DragOperationsMask {
    fn default() -> Self {
        unsafe { std::mem::zeroed() }
    }
}

/// See [`cef_text_input_mode_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextInputMode(cef_text_input_mode_t);
impl AsRef<cef_text_input_mode_t> for TextInputMode {
    fn as_ref(&self) -> &cef_text_input_mode_t {
        &self.0
    }
}
impl AsMut<cef_text_input_mode_t> for TextInputMode {
    fn as_mut(&mut self) -> &mut cef_text_input_mode_t {
        &mut self.0
    }
}
impl From<cef_text_input_mode_t> for TextInputMode {
    fn from(value: cef_text_input_mode_t) -> Self {
        Self(value)
    }
}
impl From<TextInputMode> for cef_text_input_mode_t {
    fn from(value: TextInputMode) -> Self {
        value.0
    }
}
impl Default for TextInputMode {
    fn default() -> Self {
        Self(cef_text_input_mode_t::CEF_TEXT_INPUT_MODE_DEFAULT)
    }
}

/// See [`cef_v8_propertyattribute_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct V8Propertyattribute(cef_v8_propertyattribute_t);
impl AsRef<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn as_ref(&self) -> &cef_v8_propertyattribute_t {
        &self.0
    }
}
impl AsMut<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn as_mut(&mut self) -> &mut cef_v8_propertyattribute_t {
        &mut self.0
    }
}
impl From<cef_v8_propertyattribute_t> for V8Propertyattribute {
    fn from(value: cef_v8_propertyattribute_t) -> Self {
        Self(value)
    }
}
impl From<V8Propertyattribute> for cef_v8_propertyattribute_t {
    fn from(value: V8Propertyattribute) -> Self {
        value.0
    }
}
impl Default for V8Propertyattribute {
    fn default() -> Self {
        Self(cef_v8_propertyattribute_t::V8_PROPERTY_ATTRIBUTE_NONE)
    }
}

/// See [`cef_postdataelement_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PostdataelementType(cef_postdataelement_type_t);
impl AsRef<cef_postdataelement_type_t> for PostdataelementType {
    fn as_ref(&self) -> &cef_postdataelement_type_t {
        &self.0
    }
}
impl AsMut<cef_postdataelement_type_t> for PostdataelementType {
    fn as_mut(&mut self) -> &mut cef_postdataelement_type_t {
        &mut self.0
    }
}
impl From<cef_postdataelement_type_t> for PostdataelementType {
    fn from(value: cef_postdataelement_type_t) -> Self {
        Self(value)
    }
}
impl From<PostdataelementType> for cef_postdataelement_type_t {
    fn from(value: PostdataelementType) -> Self {
        value.0
    }
}
impl Default for PostdataelementType {
    fn default() -> Self {
        Self(cef_postdataelement_type_t::PDE_TYPE_EMPTY)
    }
}

/// See [`cef_resource_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResourceType(cef_resource_type_t);
impl AsRef<cef_resource_type_t> for ResourceType {
    fn as_ref(&self) -> &cef_resource_type_t {
        &self.0
    }
}
impl AsMut<cef_resource_type_t> for ResourceType {
    fn as_mut(&mut self) -> &mut cef_resource_type_t {
        &mut self.0
    }
}
impl From<cef_resource_type_t> for ResourceType {
    fn from(value: cef_resource_type_t) -> Self {
        Self(value)
    }
}
impl From<ResourceType> for cef_resource_type_t {
    fn from(value: ResourceType) -> Self {
        value.0
    }
}
impl Default for ResourceType {
    fn default() -> Self {
        Self(cef_resource_type_t::RT_MAIN_FRAME)
    }
}

/// See [`cef_transition_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TransitionType(cef_transition_type_t);
impl AsRef<cef_transition_type_t> for TransitionType {
    fn as_ref(&self) -> &cef_transition_type_t {
        &self.0
    }
}
impl AsMut<cef_transition_type_t> for TransitionType {
    fn as_mut(&mut self) -> &mut cef_transition_type_t {
        &mut self.0
    }
}
impl From<cef_transition_type_t> for TransitionType {
    fn from(value: cef_transition_type_t) -> Self {
        Self(value)
    }
}
impl From<TransitionType> for cef_transition_type_t {
    fn from(value: TransitionType) -> Self {
        value.0
    }
}
impl Default for TransitionType {
    fn default() -> Self {
        Self(cef_transition_type_t::TT_LINK)
    }
}

/// See [`cef_urlrequest_flags_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UrlrequestFlags(cef_urlrequest_flags_t);
impl AsRef<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn as_ref(&self) -> &cef_urlrequest_flags_t {
        &self.0
    }
}
impl AsMut<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn as_mut(&mut self) -> &mut cef_urlrequest_flags_t {
        &mut self.0
    }
}
impl From<cef_urlrequest_flags_t> for UrlrequestFlags {
    fn from(value: cef_urlrequest_flags_t) -> Self {
        Self(value)
    }
}
impl From<UrlrequestFlags> for cef_urlrequest_flags_t {
    fn from(value: UrlrequestFlags) -> Self {
        value.0
    }
}
impl Default for UrlrequestFlags {
    fn default() -> Self {
        Self(cef_urlrequest_flags_t::UR_FLAG_NONE)
    }
}

/// See [`cef_urlrequest_status_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UrlrequestStatus(cef_urlrequest_status_t);
impl AsRef<cef_urlrequest_status_t> for UrlrequestStatus {
    fn as_ref(&self) -> &cef_urlrequest_status_t {
        &self.0
    }
}
impl AsMut<cef_urlrequest_status_t> for UrlrequestStatus {
    fn as_mut(&mut self) -> &mut cef_urlrequest_status_t {
        &mut self.0
    }
}
impl From<cef_urlrequest_status_t> for UrlrequestStatus {
    fn from(value: cef_urlrequest_status_t) -> Self {
        Self(value)
    }
}
impl From<UrlrequestStatus> for cef_urlrequest_status_t {
    fn from(value: UrlrequestStatus) -> Self {
        value.0
    }
}
impl Default for UrlrequestStatus {
    fn default() -> Self {
        Self(cef_urlrequest_status_t::UR_UNKNOWN)
    }
}

/// See [`cef_process_id_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ProcessId(cef_process_id_t);
impl AsRef<cef_process_id_t> for ProcessId {
    fn as_ref(&self) -> &cef_process_id_t {
        &self.0
    }
}
impl AsMut<cef_process_id_t> for ProcessId {
    fn as_mut(&mut self) -> &mut cef_process_id_t {
        &mut self.0
    }
}
impl From<cef_process_id_t> for ProcessId {
    fn from(value: cef_process_id_t) -> Self {
        Self(value)
    }
}
impl From<ProcessId> for cef_process_id_t {
    fn from(value: ProcessId) -> Self {
        value.0
    }
}
impl Default for ProcessId {
    fn default() -> Self {
        Self(cef_process_id_t::PID_BROWSER)
    }
}

/// See [`cef_thread_id_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ThreadId(cef_thread_id_t);
impl AsRef<cef_thread_id_t> for ThreadId {
    fn as_ref(&self) -> &cef_thread_id_t {
        &self.0
    }
}
impl AsMut<cef_thread_id_t> for ThreadId {
    fn as_mut(&mut self) -> &mut cef_thread_id_t {
        &mut self.0
    }
}
impl From<cef_thread_id_t> for ThreadId {
    fn from(value: cef_thread_id_t) -> Self {
        Self(value)
    }
}
impl From<ThreadId> for cef_thread_id_t {
    fn from(value: ThreadId) -> Self {
        value.0
    }
}
impl Default for ThreadId {
    fn default() -> Self {
        Self(cef_thread_id_t::TID_UI)
    }
}

/// See [`cef_thread_priority_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ThreadPriority(cef_thread_priority_t);
impl AsRef<cef_thread_priority_t> for ThreadPriority {
    fn as_ref(&self) -> &cef_thread_priority_t {
        &self.0
    }
}
impl AsMut<cef_thread_priority_t> for ThreadPriority {
    fn as_mut(&mut self) -> &mut cef_thread_priority_t {
        &mut self.0
    }
}
impl From<cef_thread_priority_t> for ThreadPriority {
    fn from(value: cef_thread_priority_t) -> Self {
        Self(value)
    }
}
impl From<ThreadPriority> for cef_thread_priority_t {
    fn from(value: ThreadPriority) -> Self {
        value.0
    }
}
impl Default for ThreadPriority {
    fn default() -> Self {
        Self(cef_thread_priority_t::TP_BACKGROUND)
    }
}

/// See [`cef_message_loop_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MessageLoopType(cef_message_loop_type_t);
impl AsRef<cef_message_loop_type_t> for MessageLoopType {
    fn as_ref(&self) -> &cef_message_loop_type_t {
        &self.0
    }
}
impl AsMut<cef_message_loop_type_t> for MessageLoopType {
    fn as_mut(&mut self) -> &mut cef_message_loop_type_t {
        &mut self.0
    }
}
impl From<cef_message_loop_type_t> for MessageLoopType {
    fn from(value: cef_message_loop_type_t) -> Self {
        Self(value)
    }
}
impl From<MessageLoopType> for cef_message_loop_type_t {
    fn from(value: MessageLoopType) -> Self {
        value.0
    }
}
impl Default for MessageLoopType {
    fn default() -> Self {
        Self(cef_message_loop_type_t::ML_TYPE_DEFAULT)
    }
}

/// See [`cef_com_init_mode_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ComInitMode(cef_com_init_mode_t);
impl AsRef<cef_com_init_mode_t> for ComInitMode {
    fn as_ref(&self) -> &cef_com_init_mode_t {
        &self.0
    }
}
impl AsMut<cef_com_init_mode_t> for ComInitMode {
    fn as_mut(&mut self) -> &mut cef_com_init_mode_t {
        &mut self.0
    }
}
impl From<cef_com_init_mode_t> for ComInitMode {
    fn from(value: cef_com_init_mode_t) -> Self {
        Self(value)
    }
}
impl From<ComInitMode> for cef_com_init_mode_t {
    fn from(value: ComInitMode) -> Self {
        value.0
    }
}
impl Default for ComInitMode {
    fn default() -> Self {
        Self(cef_com_init_mode_t::COM_INIT_MODE_NONE)
    }
}

/// See [`cef_value_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ValueType(cef_value_type_t);
impl AsRef<cef_value_type_t> for ValueType {
    fn as_ref(&self) -> &cef_value_type_t {
        &self.0
    }
}
impl AsMut<cef_value_type_t> for ValueType {
    fn as_mut(&mut self) -> &mut cef_value_type_t {
        &mut self.0
    }
}
impl From<cef_value_type_t> for ValueType {
    fn from(value: cef_value_type_t) -> Self {
        Self(value)
    }
}
impl From<ValueType> for cef_value_type_t {
    fn from(value: ValueType) -> Self {
        value.0
    }
}
impl Default for ValueType {
    fn default() -> Self {
        Self(cef_value_type_t::VTYPE_INVALID)
    }
}

/// See [`cef_jsdialog_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsdialogType(cef_jsdialog_type_t);
impl AsRef<cef_jsdialog_type_t> for JsdialogType {
    fn as_ref(&self) -> &cef_jsdialog_type_t {
        &self.0
    }
}
impl AsMut<cef_jsdialog_type_t> for JsdialogType {
    fn as_mut(&mut self) -> &mut cef_jsdialog_type_t {
        &mut self.0
    }
}
impl From<cef_jsdialog_type_t> for JsdialogType {
    fn from(value: cef_jsdialog_type_t) -> Self {
        Self(value)
    }
}
impl From<JsdialogType> for cef_jsdialog_type_t {
    fn from(value: JsdialogType) -> Self {
        value.0
    }
}
impl Default for JsdialogType {
    fn default() -> Self {
        Self(cef_jsdialog_type_t::JSDIALOGTYPE_ALERT)
    }
}

/// See [`cef_menu_id_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuId(cef_menu_id_t);
impl AsRef<cef_menu_id_t> for MenuId {
    fn as_ref(&self) -> &cef_menu_id_t {
        &self.0
    }
}
impl AsMut<cef_menu_id_t> for MenuId {
    fn as_mut(&mut self) -> &mut cef_menu_id_t {
        &mut self.0
    }
}
impl From<cef_menu_id_t> for MenuId {
    fn from(value: cef_menu_id_t) -> Self {
        Self(value)
    }
}
impl From<MenuId> for cef_menu_id_t {
    fn from(value: MenuId) -> Self {
        value.0
    }
}
impl Default for MenuId {
    fn default() -> Self {
        Self(cef_menu_id_t::MENU_ID_BACK)
    }
}

/// See [`cef_mouse_button_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MouseButtonType(cef_mouse_button_type_t);
impl AsRef<cef_mouse_button_type_t> for MouseButtonType {
    fn as_ref(&self) -> &cef_mouse_button_type_t {
        &self.0
    }
}
impl AsMut<cef_mouse_button_type_t> for MouseButtonType {
    fn as_mut(&mut self) -> &mut cef_mouse_button_type_t {
        &mut self.0
    }
}
impl From<cef_mouse_button_type_t> for MouseButtonType {
    fn from(value: cef_mouse_button_type_t) -> Self {
        Self(value)
    }
}
impl From<MouseButtonType> for cef_mouse_button_type_t {
    fn from(value: MouseButtonType) -> Self {
        value.0
    }
}
impl Default for MouseButtonType {
    fn default() -> Self {
        Self(cef_mouse_button_type_t::MBT_LEFT)
    }
}

/// See [`cef_touch_event_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TouchEventType(cef_touch_event_type_t);
impl AsRef<cef_touch_event_type_t> for TouchEventType {
    fn as_ref(&self) -> &cef_touch_event_type_t {
        &self.0
    }
}
impl AsMut<cef_touch_event_type_t> for TouchEventType {
    fn as_mut(&mut self) -> &mut cef_touch_event_type_t {
        &mut self.0
    }
}
impl From<cef_touch_event_type_t> for TouchEventType {
    fn from(value: cef_touch_event_type_t) -> Self {
        Self(value)
    }
}
impl From<TouchEventType> for cef_touch_event_type_t {
    fn from(value: TouchEventType) -> Self {
        value.0
    }
}
impl Default for TouchEventType {
    fn default() -> Self {
        Self(cef_touch_event_type_t::CEF_TET_RELEASED)
    }
}

/// See [`cef_pointer_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PointerType(cef_pointer_type_t);
impl AsRef<cef_pointer_type_t> for PointerType {
    fn as_ref(&self) -> &cef_pointer_type_t {
        &self.0
    }
}
impl AsMut<cef_pointer_type_t> for PointerType {
    fn as_mut(&mut self) -> &mut cef_pointer_type_t {
        &mut self.0
    }
}
impl From<cef_pointer_type_t> for PointerType {
    fn from(value: cef_pointer_type_t) -> Self {
        Self(value)
    }
}
impl From<PointerType> for cef_pointer_type_t {
    fn from(value: PointerType) -> Self {
        value.0
    }
}
impl Default for PointerType {
    fn default() -> Self {
        Self(cef_pointer_type_t::CEF_POINTER_TYPE_TOUCH)
    }
}

/// See [`cef_paint_element_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PaintElementType(cef_paint_element_type_t);
impl AsRef<cef_paint_element_type_t> for PaintElementType {
    fn as_ref(&self) -> &cef_paint_element_type_t {
        &self.0
    }
}
impl AsMut<cef_paint_element_type_t> for PaintElementType {
    fn as_mut(&mut self) -> &mut cef_paint_element_type_t {
        &mut self.0
    }
}
impl From<cef_paint_element_type_t> for PaintElementType {
    fn from(value: cef_paint_element_type_t) -> Self {
        Self(value)
    }
}
impl From<PaintElementType> for cef_paint_element_type_t {
    fn from(value: PaintElementType) -> Self {
        value.0
    }
}
impl Default for PaintElementType {
    fn default() -> Self {
        Self(cef_paint_element_type_t::PET_VIEW)
    }
}

/// See [`cef_event_flags_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct EventFlags(cef_event_flags_t);
impl AsRef<cef_event_flags_t> for EventFlags {
    fn as_ref(&self) -> &cef_event_flags_t {
        &self.0
    }
}
impl AsMut<cef_event_flags_t> for EventFlags {
    fn as_mut(&mut self) -> &mut cef_event_flags_t {
        &mut self.0
    }
}
impl From<cef_event_flags_t> for EventFlags {
    fn from(value: cef_event_flags_t) -> Self {
        Self(value)
    }
}
impl From<EventFlags> for cef_event_flags_t {
    fn from(value: EventFlags) -> Self {
        value.0
    }
}
impl Default for EventFlags {
    fn default() -> Self {
        Self(cef_event_flags_t::EVENTFLAG_NONE)
    }
}

/// See [`cef_menu_item_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuItemType(cef_menu_item_type_t);
impl AsRef<cef_menu_item_type_t> for MenuItemType {
    fn as_ref(&self) -> &cef_menu_item_type_t {
        &self.0
    }
}
impl AsMut<cef_menu_item_type_t> for MenuItemType {
    fn as_mut(&mut self) -> &mut cef_menu_item_type_t {
        &mut self.0
    }
}
impl From<cef_menu_item_type_t> for MenuItemType {
    fn from(value: cef_menu_item_type_t) -> Self {
        Self(value)
    }
}
impl From<MenuItemType> for cef_menu_item_type_t {
    fn from(value: MenuItemType) -> Self {
        value.0
    }
}
impl Default for MenuItemType {
    fn default() -> Self {
        Self(cef_menu_item_type_t::MENUITEMTYPE_NONE)
    }
}

/// See [`cef_context_menu_type_flags_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuTypeFlags(cef_context_menu_type_flags_t);
impl AsRef<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn as_ref(&self) -> &cef_context_menu_type_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_type_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_type_flags_t> for ContextMenuTypeFlags {
    fn from(value: cef_context_menu_type_flags_t) -> Self {
        Self(value)
    }
}
impl From<ContextMenuTypeFlags> for cef_context_menu_type_flags_t {
    fn from(value: ContextMenuTypeFlags) -> Self {
        value.0
    }
}
impl Default for ContextMenuTypeFlags {
    fn default() -> Self {
        Self(cef_context_menu_type_flags_t::CM_TYPEFLAG_NONE)
    }
}

/// See [`cef_context_menu_media_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuMediaType(cef_context_menu_media_type_t);
impl AsRef<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn as_ref(&self) -> &cef_context_menu_media_type_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn as_mut(&mut self) -> &mut cef_context_menu_media_type_t {
        &mut self.0
    }
}
impl From<cef_context_menu_media_type_t> for ContextMenuMediaType {
    fn from(value: cef_context_menu_media_type_t) -> Self {
        Self(value)
    }
}
impl From<ContextMenuMediaType> for cef_context_menu_media_type_t {
    fn from(value: ContextMenuMediaType) -> Self {
        value.0
    }
}
impl Default for ContextMenuMediaType {
    fn default() -> Self {
        Self(cef_context_menu_media_type_t::CM_MEDIATYPE_NONE)
    }
}

/// See [`cef_context_menu_media_state_flags_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuMediaStateFlags(cef_context_menu_media_state_flags_t);
impl AsRef<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn as_ref(&self) -> &cef_context_menu_media_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_media_state_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_media_state_flags_t> for ContextMenuMediaStateFlags {
    fn from(value: cef_context_menu_media_state_flags_t) -> Self {
        Self(value)
    }
}
impl From<ContextMenuMediaStateFlags> for cef_context_menu_media_state_flags_t {
    fn from(value: ContextMenuMediaStateFlags) -> Self {
        value.0
    }
}
impl Default for ContextMenuMediaStateFlags {
    fn default() -> Self {
        Self(cef_context_menu_media_state_flags_t::CM_MEDIAFLAG_NONE)
    }
}

/// See [`cef_context_menu_edit_state_flags_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ContextMenuEditStateFlags(cef_context_menu_edit_state_flags_t);
impl AsRef<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn as_ref(&self) -> &cef_context_menu_edit_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn as_mut(&mut self) -> &mut cef_context_menu_edit_state_flags_t {
        &mut self.0
    }
}
impl From<cef_context_menu_edit_state_flags_t> for ContextMenuEditStateFlags {
    fn from(value: cef_context_menu_edit_state_flags_t) -> Self {
        Self(value)
    }
}
impl From<ContextMenuEditStateFlags> for cef_context_menu_edit_state_flags_t {
    fn from(value: ContextMenuEditStateFlags) -> Self {
        value.0
    }
}
impl Default for ContextMenuEditStateFlags {
    fn default() -> Self {
        Self(cef_context_menu_edit_state_flags_t::CM_EDITFLAG_NONE)
    }
}

/// See [`cef_quick_menu_edit_state_flags_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct QuickMenuEditStateFlags(cef_quick_menu_edit_state_flags_t);
impl AsRef<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn as_ref(&self) -> &cef_quick_menu_edit_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn as_mut(&mut self) -> &mut cef_quick_menu_edit_state_flags_t {
        &mut self.0
    }
}
impl From<cef_quick_menu_edit_state_flags_t> for QuickMenuEditStateFlags {
    fn from(value: cef_quick_menu_edit_state_flags_t) -> Self {
        Self(value)
    }
}
impl From<QuickMenuEditStateFlags> for cef_quick_menu_edit_state_flags_t {
    fn from(value: QuickMenuEditStateFlags) -> Self {
        value.0
    }
}
impl Default for QuickMenuEditStateFlags {
    fn default() -> Self {
        Self(cef_quick_menu_edit_state_flags_t::QM_EDITFLAG_NONE)
    }
}

/// See [`cef_key_event_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct KeyEventType(cef_key_event_type_t);
impl AsRef<cef_key_event_type_t> for KeyEventType {
    fn as_ref(&self) -> &cef_key_event_type_t {
        &self.0
    }
}
impl AsMut<cef_key_event_type_t> for KeyEventType {
    fn as_mut(&mut self) -> &mut cef_key_event_type_t {
        &mut self.0
    }
}
impl From<cef_key_event_type_t> for KeyEventType {
    fn from(value: cef_key_event_type_t) -> Self {
        Self(value)
    }
}
impl From<KeyEventType> for cef_key_event_type_t {
    fn from(value: KeyEventType) -> Self {
        value.0
    }
}
impl Default for KeyEventType {
    fn default() -> Self {
        Self(cef_key_event_type_t::KEYEVENT_RAWKEYDOWN)
    }
}

/// See [`cef_focus_source_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FocusSource(cef_focus_source_t);
impl AsRef<cef_focus_source_t> for FocusSource {
    fn as_ref(&self) -> &cef_focus_source_t {
        &self.0
    }
}
impl AsMut<cef_focus_source_t> for FocusSource {
    fn as_mut(&mut self) -> &mut cef_focus_source_t {
        &mut self.0
    }
}
impl From<cef_focus_source_t> for FocusSource {
    fn from(value: cef_focus_source_t) -> Self {
        Self(value)
    }
}
impl From<FocusSource> for cef_focus_source_t {
    fn from(value: FocusSource) -> Self {
        value.0
    }
}
impl Default for FocusSource {
    fn default() -> Self {
        Self(cef_focus_source_t::FOCUS_SOURCE_NAVIGATION)
    }
}

/// See [`cef_navigation_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct NavigationType(cef_navigation_type_t);
impl AsRef<cef_navigation_type_t> for NavigationType {
    fn as_ref(&self) -> &cef_navigation_type_t {
        &self.0
    }
}
impl AsMut<cef_navigation_type_t> for NavigationType {
    fn as_mut(&mut self) -> &mut cef_navigation_type_t {
        &mut self.0
    }
}
impl From<cef_navigation_type_t> for NavigationType {
    fn from(value: cef_navigation_type_t) -> Self {
        Self(value)
    }
}
impl From<NavigationType> for cef_navigation_type_t {
    fn from(value: NavigationType) -> Self {
        value.0
    }
}
impl Default for NavigationType {
    fn default() -> Self {
        Self(cef_navigation_type_t::NAVIGATION_LINK_CLICKED)
    }
}

/// See [`cef_xml_encoding_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct XmlEncodingType(cef_xml_encoding_type_t);
impl AsRef<cef_xml_encoding_type_t> for XmlEncodingType {
    fn as_ref(&self) -> &cef_xml_encoding_type_t {
        &self.0
    }
}
impl AsMut<cef_xml_encoding_type_t> for XmlEncodingType {
    fn as_mut(&mut self) -> &mut cef_xml_encoding_type_t {
        &mut self.0
    }
}
impl From<cef_xml_encoding_type_t> for XmlEncodingType {
    fn from(value: cef_xml_encoding_type_t) -> Self {
        Self(value)
    }
}
impl From<XmlEncodingType> for cef_xml_encoding_type_t {
    fn from(value: XmlEncodingType) -> Self {
        value.0
    }
}
impl Default for XmlEncodingType {
    fn default() -> Self {
        Self(cef_xml_encoding_type_t::XML_ENCODING_NONE)
    }
}

/// See [`cef_xml_node_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct XmlNodeType(cef_xml_node_type_t);
impl AsRef<cef_xml_node_type_t> for XmlNodeType {
    fn as_ref(&self) -> &cef_xml_node_type_t {
        &self.0
    }
}
impl AsMut<cef_xml_node_type_t> for XmlNodeType {
    fn as_mut(&mut self) -> &mut cef_xml_node_type_t {
        &mut self.0
    }
}
impl From<cef_xml_node_type_t> for XmlNodeType {
    fn from(value: cef_xml_node_type_t) -> Self {
        Self(value)
    }
}
impl From<XmlNodeType> for cef_xml_node_type_t {
    fn from(value: XmlNodeType) -> Self {
        value.0
    }
}
impl Default for XmlNodeType {
    fn default() -> Self {
        Self(cef_xml_node_type_t::XML_NODE_UNSUPPORTED)
    }
}

/// See [`cef_dom_document_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomDocumentType(cef_dom_document_type_t);
impl AsRef<cef_dom_document_type_t> for DomDocumentType {
    fn as_ref(&self) -> &cef_dom_document_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_document_type_t> for DomDocumentType {
    fn as_mut(&mut self) -> &mut cef_dom_document_type_t {
        &mut self.0
    }
}
impl From<cef_dom_document_type_t> for DomDocumentType {
    fn from(value: cef_dom_document_type_t) -> Self {
        Self(value)
    }
}
impl From<DomDocumentType> for cef_dom_document_type_t {
    fn from(value: DomDocumentType) -> Self {
        value.0
    }
}
impl Default for DomDocumentType {
    fn default() -> Self {
        Self(cef_dom_document_type_t::DOM_DOCUMENT_TYPE_UNKNOWN)
    }
}

/// See [`cef_dom_event_category_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomEventCategory(cef_dom_event_category_t);
impl AsRef<cef_dom_event_category_t> for DomEventCategory {
    fn as_ref(&self) -> &cef_dom_event_category_t {
        &self.0
    }
}
impl AsMut<cef_dom_event_category_t> for DomEventCategory {
    fn as_mut(&mut self) -> &mut cef_dom_event_category_t {
        &mut self.0
    }
}
impl From<cef_dom_event_category_t> for DomEventCategory {
    fn from(value: cef_dom_event_category_t) -> Self {
        Self(value)
    }
}
impl From<DomEventCategory> for cef_dom_event_category_t {
    fn from(value: DomEventCategory) -> Self {
        value.0
    }
}
impl Default for DomEventCategory {
    fn default() -> Self {
        Self(cef_dom_event_category_t::DOM_EVENT_CATEGORY_UNKNOWN)
    }
}

/// See [`cef_dom_event_phase_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomEventPhase(cef_dom_event_phase_t);
impl AsRef<cef_dom_event_phase_t> for DomEventPhase {
    fn as_ref(&self) -> &cef_dom_event_phase_t {
        &self.0
    }
}
impl AsMut<cef_dom_event_phase_t> for DomEventPhase {
    fn as_mut(&mut self) -> &mut cef_dom_event_phase_t {
        &mut self.0
    }
}
impl From<cef_dom_event_phase_t> for DomEventPhase {
    fn from(value: cef_dom_event_phase_t) -> Self {
        Self(value)
    }
}
impl From<DomEventPhase> for cef_dom_event_phase_t {
    fn from(value: DomEventPhase) -> Self {
        value.0
    }
}
impl Default for DomEventPhase {
    fn default() -> Self {
        Self(cef_dom_event_phase_t::DOM_EVENT_PHASE_UNKNOWN)
    }
}

/// See [`cef_dom_node_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomNodeType(cef_dom_node_type_t);
impl AsRef<cef_dom_node_type_t> for DomNodeType {
    fn as_ref(&self) -> &cef_dom_node_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_node_type_t> for DomNodeType {
    fn as_mut(&mut self) -> &mut cef_dom_node_type_t {
        &mut self.0
    }
}
impl From<cef_dom_node_type_t> for DomNodeType {
    fn from(value: cef_dom_node_type_t) -> Self {
        Self(value)
    }
}
impl From<DomNodeType> for cef_dom_node_type_t {
    fn from(value: DomNodeType) -> Self {
        value.0
    }
}
impl Default for DomNodeType {
    fn default() -> Self {
        Self(cef_dom_node_type_t::DOM_NODE_TYPE_UNSUPPORTED)
    }
}

/// See [`cef_dom_form_control_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DomFormControlType(cef_dom_form_control_type_t);
impl AsRef<cef_dom_form_control_type_t> for DomFormControlType {
    fn as_ref(&self) -> &cef_dom_form_control_type_t {
        &self.0
    }
}
impl AsMut<cef_dom_form_control_type_t> for DomFormControlType {
    fn as_mut(&mut self) -> &mut cef_dom_form_control_type_t {
        &mut self.0
    }
}
impl From<cef_dom_form_control_type_t> for DomFormControlType {
    fn from(value: cef_dom_form_control_type_t) -> Self {
        Self(value)
    }
}
impl From<DomFormControlType> for cef_dom_form_control_type_t {
    fn from(value: DomFormControlType) -> Self {
        value.0
    }
}
impl Default for DomFormControlType {
    fn default() -> Self {
        Self(cef_dom_form_control_type_t::DOM_FORM_CONTROL_TYPE_UNSUPPORTED)
    }
}

/// See [`cef_file_dialog_mode_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct FileDialogMode(cef_file_dialog_mode_t);
impl AsRef<cef_file_dialog_mode_t> for FileDialogMode {
    fn as_ref(&self) -> &cef_file_dialog_mode_t {
        &self.0
    }
}
impl AsMut<cef_file_dialog_mode_t> for FileDialogMode {
    fn as_mut(&mut self) -> &mut cef_file_dialog_mode_t {
        &mut self.0
    }
}
impl From<cef_file_dialog_mode_t> for FileDialogMode {
    fn from(value: cef_file_dialog_mode_t) -> Self {
        Self(value)
    }
}
impl From<FileDialogMode> for cef_file_dialog_mode_t {
    fn from(value: FileDialogMode) -> Self {
        value.0
    }
}
impl Default for FileDialogMode {
    fn default() -> Self {
        Self(cef_file_dialog_mode_t::FILE_DIALOG_OPEN)
    }
}

/// See [`cef_color_model_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorModel(cef_color_model_t);
impl AsRef<cef_color_model_t> for ColorModel {
    fn as_ref(&self) -> &cef_color_model_t {
        &self.0
    }
}
impl AsMut<cef_color_model_t> for ColorModel {
    fn as_mut(&mut self) -> &mut cef_color_model_t {
        &mut self.0
    }
}
impl From<cef_color_model_t> for ColorModel {
    fn from(value: cef_color_model_t) -> Self {
        Self(value)
    }
}
impl From<ColorModel> for cef_color_model_t {
    fn from(value: ColorModel) -> Self {
        value.0
    }
}
impl Default for ColorModel {
    fn default() -> Self {
        Self(cef_color_model_t::COLOR_MODEL_UNKNOWN)
    }
}

/// See [`cef_duplex_mode_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DuplexMode(cef_duplex_mode_t);
impl AsRef<cef_duplex_mode_t> for DuplexMode {
    fn as_ref(&self) -> &cef_duplex_mode_t {
        &self.0
    }
}
impl AsMut<cef_duplex_mode_t> for DuplexMode {
    fn as_mut(&mut self) -> &mut cef_duplex_mode_t {
        &mut self.0
    }
}
impl From<cef_duplex_mode_t> for DuplexMode {
    fn from(value: cef_duplex_mode_t) -> Self {
        Self(value)
    }
}
impl From<DuplexMode> for cef_duplex_mode_t {
    fn from(value: DuplexMode) -> Self {
        value.0
    }
}
impl Default for DuplexMode {
    fn default() -> Self {
        Self(cef_duplex_mode_t::DUPLEX_MODE_UNKNOWN)
    }
}

/// See [`cef_cursor_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CursorType(cef_cursor_type_t);
impl AsRef<cef_cursor_type_t> for CursorType {
    fn as_ref(&self) -> &cef_cursor_type_t {
        &self.0
    }
}
impl AsMut<cef_cursor_type_t> for CursorType {
    fn as_mut(&mut self) -> &mut cef_cursor_type_t {
        &mut self.0
    }
}
impl From<cef_cursor_type_t> for CursorType {
    fn from(value: cef_cursor_type_t) -> Self {
        Self(value)
    }
}
impl From<CursorType> for cef_cursor_type_t {
    fn from(value: CursorType) -> Self {
        value.0
    }
}
impl Default for CursorType {
    fn default() -> Self {
        Self(cef_cursor_type_t::CT_POINTER)
    }
}

/// See [`cef_uri_unescape_rule_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct UriUnescapeRule(cef_uri_unescape_rule_t);
impl AsRef<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn as_ref(&self) -> &cef_uri_unescape_rule_t {
        &self.0
    }
}
impl AsMut<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn as_mut(&mut self) -> &mut cef_uri_unescape_rule_t {
        &mut self.0
    }
}
impl From<cef_uri_unescape_rule_t> for UriUnescapeRule {
    fn from(value: cef_uri_unescape_rule_t) -> Self {
        Self(value)
    }
}
impl From<UriUnescapeRule> for cef_uri_unescape_rule_t {
    fn from(value: UriUnescapeRule) -> Self {
        value.0
    }
}
impl Default for UriUnescapeRule {
    fn default() -> Self {
        Self(cef_uri_unescape_rule_t::UU_NONE)
    }
}

/// See [`cef_json_parser_options_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsonParserOptions(cef_json_parser_options_t);
impl AsRef<cef_json_parser_options_t> for JsonParserOptions {
    fn as_ref(&self) -> &cef_json_parser_options_t {
        &self.0
    }
}
impl AsMut<cef_json_parser_options_t> for JsonParserOptions {
    fn as_mut(&mut self) -> &mut cef_json_parser_options_t {
        &mut self.0
    }
}
impl From<cef_json_parser_options_t> for JsonParserOptions {
    fn from(value: cef_json_parser_options_t) -> Self {
        Self(value)
    }
}
impl From<JsonParserOptions> for cef_json_parser_options_t {
    fn from(value: JsonParserOptions) -> Self {
        value.0
    }
}
impl Default for JsonParserOptions {
    fn default() -> Self {
        Self(cef_json_parser_options_t::JSON_PARSER_RFC)
    }
}

/// See [`cef_json_writer_options_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct JsonWriterOptions(cef_json_writer_options_t);
impl AsRef<cef_json_writer_options_t> for JsonWriterOptions {
    fn as_ref(&self) -> &cef_json_writer_options_t {
        &self.0
    }
}
impl AsMut<cef_json_writer_options_t> for JsonWriterOptions {
    fn as_mut(&mut self) -> &mut cef_json_writer_options_t {
        &mut self.0
    }
}
impl From<cef_json_writer_options_t> for JsonWriterOptions {
    fn from(value: cef_json_writer_options_t) -> Self {
        Self(value)
    }
}
impl From<JsonWriterOptions> for cef_json_writer_options_t {
    fn from(value: JsonWriterOptions) -> Self {
        value.0
    }
}
impl Default for JsonWriterOptions {
    fn default() -> Self {
        Self(cef_json_writer_options_t::JSON_WRITER_DEFAULT)
    }
}

/// See [`cef_pdf_print_margin_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PdfPrintMarginType(cef_pdf_print_margin_type_t);
impl AsRef<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn as_ref(&self) -> &cef_pdf_print_margin_type_t {
        &self.0
    }
}
impl AsMut<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn as_mut(&mut self) -> &mut cef_pdf_print_margin_type_t {
        &mut self.0
    }
}
impl From<cef_pdf_print_margin_type_t> for PdfPrintMarginType {
    fn from(value: cef_pdf_print_margin_type_t) -> Self {
        Self(value)
    }
}
impl From<PdfPrintMarginType> for cef_pdf_print_margin_type_t {
    fn from(value: PdfPrintMarginType) -> Self {
        value.0
    }
}
impl Default for PdfPrintMarginType {
    fn default() -> Self {
        Self(cef_pdf_print_margin_type_t::PDF_PRINT_MARGIN_DEFAULT)
    }
}

/// See [`cef_scale_factor_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ScaleFactor(cef_scale_factor_t);
impl AsRef<cef_scale_factor_t> for ScaleFactor {
    fn as_ref(&self) -> &cef_scale_factor_t {
        &self.0
    }
}
impl AsMut<cef_scale_factor_t> for ScaleFactor {
    fn as_mut(&mut self) -> &mut cef_scale_factor_t {
        &mut self.0
    }
}
impl From<cef_scale_factor_t> for ScaleFactor {
    fn from(value: cef_scale_factor_t) -> Self {
        Self(value)
    }
}
impl From<ScaleFactor> for cef_scale_factor_t {
    fn from(value: ScaleFactor) -> Self {
        value.0
    }
}
impl Default for ScaleFactor {
    fn default() -> Self {
        Self(cef_scale_factor_t::SCALE_FACTOR_NONE)
    }
}

/// See [`cef_referrer_policy_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ReferrerPolicy(cef_referrer_policy_t);
impl AsRef<cef_referrer_policy_t> for ReferrerPolicy {
    fn as_ref(&self) -> &cef_referrer_policy_t {
        &self.0
    }
}
impl AsMut<cef_referrer_policy_t> for ReferrerPolicy {
    fn as_mut(&mut self) -> &mut cef_referrer_policy_t {
        &mut self.0
    }
}
impl From<cef_referrer_policy_t> for ReferrerPolicy {
    fn from(value: cef_referrer_policy_t) -> Self {
        Self(value)
    }
}
impl From<ReferrerPolicy> for cef_referrer_policy_t {
    fn from(value: ReferrerPolicy) -> Self {
        value.0
    }
}
impl Default for ReferrerPolicy {
    fn default() -> Self {
        Self (cef_referrer_policy_t :: REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE)
    }
}

/// See [`cef_response_filter_status_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ResponseFilterStatus(cef_response_filter_status_t);
impl AsRef<cef_response_filter_status_t> for ResponseFilterStatus {
    fn as_ref(&self) -> &cef_response_filter_status_t {
        &self.0
    }
}
impl AsMut<cef_response_filter_status_t> for ResponseFilterStatus {
    fn as_mut(&mut self) -> &mut cef_response_filter_status_t {
        &mut self.0
    }
}
impl From<cef_response_filter_status_t> for ResponseFilterStatus {
    fn from(value: cef_response_filter_status_t) -> Self {
        Self(value)
    }
}
impl From<ResponseFilterStatus> for cef_response_filter_status_t {
    fn from(value: ResponseFilterStatus) -> Self {
        value.0
    }
}
impl Default for ResponseFilterStatus {
    fn default() -> Self {
        Self(cef_response_filter_status_t::RESPONSE_FILTER_NEED_MORE_DATA)
    }
}

/// See [`cef_alpha_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AlphaType(cef_alpha_type_t);
impl AsRef<cef_alpha_type_t> for AlphaType {
    fn as_ref(&self) -> &cef_alpha_type_t {
        &self.0
    }
}
impl AsMut<cef_alpha_type_t> for AlphaType {
    fn as_mut(&mut self) -> &mut cef_alpha_type_t {
        &mut self.0
    }
}
impl From<cef_alpha_type_t> for AlphaType {
    fn from(value: cef_alpha_type_t) -> Self {
        Self(value)
    }
}
impl From<AlphaType> for cef_alpha_type_t {
    fn from(value: AlphaType) -> Self {
        value.0
    }
}
impl Default for AlphaType {
    fn default() -> Self {
        Self(cef_alpha_type_t::CEF_ALPHA_TYPE_OPAQUE)
    }
}

/// See [`cef_text_style_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextStyle(cef_text_style_t);
impl AsRef<cef_text_style_t> for TextStyle {
    fn as_ref(&self) -> &cef_text_style_t {
        &self.0
    }
}
impl AsMut<cef_text_style_t> for TextStyle {
    fn as_mut(&mut self) -> &mut cef_text_style_t {
        &mut self.0
    }
}
impl From<cef_text_style_t> for TextStyle {
    fn from(value: cef_text_style_t) -> Self {
        Self(value)
    }
}
impl From<TextStyle> for cef_text_style_t {
    fn from(value: TextStyle) -> Self {
        value.0
    }
}
impl Default for TextStyle {
    fn default() -> Self {
        Self(cef_text_style_t::CEF_TEXT_STYLE_BOLD)
    }
}

/// See [`cef_axis_alignment_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct AxisAlignment(cef_axis_alignment_t);
impl AsRef<cef_axis_alignment_t> for AxisAlignment {
    fn as_ref(&self) -> &cef_axis_alignment_t {
        &self.0
    }
}
impl AsMut<cef_axis_alignment_t> for AxisAlignment {
    fn as_mut(&mut self) -> &mut cef_axis_alignment_t {
        &mut self.0
    }
}
impl From<cef_axis_alignment_t> for AxisAlignment {
    fn from(value: cef_axis_alignment_t) -> Self {
        Self(value)
    }
}
impl From<AxisAlignment> for cef_axis_alignment_t {
    fn from(value: AxisAlignment) -> Self {
        value.0
    }
}
impl Default for AxisAlignment {
    fn default() -> Self {
        Self(cef_axis_alignment_t::CEF_AXIS_ALIGNMENT_START)
    }
}

/// See [`cef_button_state_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ButtonState(cef_button_state_t);
impl AsRef<cef_button_state_t> for ButtonState {
    fn as_ref(&self) -> &cef_button_state_t {
        &self.0
    }
}
impl AsMut<cef_button_state_t> for ButtonState {
    fn as_mut(&mut self) -> &mut cef_button_state_t {
        &mut self.0
    }
}
impl From<cef_button_state_t> for ButtonState {
    fn from(value: cef_button_state_t) -> Self {
        Self(value)
    }
}
impl From<ButtonState> for cef_button_state_t {
    fn from(value: ButtonState) -> Self {
        value.0
    }
}
impl Default for ButtonState {
    fn default() -> Self {
        Self(cef_button_state_t::CEF_BUTTON_STATE_NORMAL)
    }
}

/// See [`cef_horizontal_alignment_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct HorizontalAlignment(cef_horizontal_alignment_t);
impl AsRef<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn as_ref(&self) -> &cef_horizontal_alignment_t {
        &self.0
    }
}
impl AsMut<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn as_mut(&mut self) -> &mut cef_horizontal_alignment_t {
        &mut self.0
    }
}
impl From<cef_horizontal_alignment_t> for HorizontalAlignment {
    fn from(value: cef_horizontal_alignment_t) -> Self {
        Self(value)
    }
}
impl From<HorizontalAlignment> for cef_horizontal_alignment_t {
    fn from(value: HorizontalAlignment) -> Self {
        value.0
    }
}
impl Default for HorizontalAlignment {
    fn default() -> Self {
        Self(cef_horizontal_alignment_t::CEF_HORIZONTAL_ALIGNMENT_LEFT)
    }
}

/// See [`cef_menu_anchor_position_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuAnchorPosition(cef_menu_anchor_position_t);
impl AsRef<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn as_ref(&self) -> &cef_menu_anchor_position_t {
        &self.0
    }
}
impl AsMut<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn as_mut(&mut self) -> &mut cef_menu_anchor_position_t {
        &mut self.0
    }
}
impl From<cef_menu_anchor_position_t> for MenuAnchorPosition {
    fn from(value: cef_menu_anchor_position_t) -> Self {
        Self(value)
    }
}
impl From<MenuAnchorPosition> for cef_menu_anchor_position_t {
    fn from(value: MenuAnchorPosition) -> Self {
        value.0
    }
}
impl Default for MenuAnchorPosition {
    fn default() -> Self {
        Self(cef_menu_anchor_position_t::CEF_MENU_ANCHOR_TOPLEFT)
    }
}

/// See [`cef_menu_color_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MenuColorType(cef_menu_color_type_t);
impl AsRef<cef_menu_color_type_t> for MenuColorType {
    fn as_ref(&self) -> &cef_menu_color_type_t {
        &self.0
    }
}
impl AsMut<cef_menu_color_type_t> for MenuColorType {
    fn as_mut(&mut self) -> &mut cef_menu_color_type_t {
        &mut self.0
    }
}
impl From<cef_menu_color_type_t> for MenuColorType {
    fn from(value: cef_menu_color_type_t) -> Self {
        Self(value)
    }
}
impl From<MenuColorType> for cef_menu_color_type_t {
    fn from(value: MenuColorType) -> Self {
        value.0
    }
}
impl Default for MenuColorType {
    fn default() -> Self {
        Self(cef_menu_color_type_t::CEF_MENU_COLOR_TEXT)
    }
}

/// See [`cef_ssl_version_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SslVersion(cef_ssl_version_t);
impl AsRef<cef_ssl_version_t> for SslVersion {
    fn as_ref(&self) -> &cef_ssl_version_t {
        &self.0
    }
}
impl AsMut<cef_ssl_version_t> for SslVersion {
    fn as_mut(&mut self) -> &mut cef_ssl_version_t {
        &mut self.0
    }
}
impl From<cef_ssl_version_t> for SslVersion {
    fn from(value: cef_ssl_version_t) -> Self {
        Self(value)
    }
}
impl From<SslVersion> for cef_ssl_version_t {
    fn from(value: SslVersion) -> Self {
        value.0
    }
}
impl Default for SslVersion {
    fn default() -> Self {
        Self(cef_ssl_version_t::SSL_CONNECTION_VERSION_UNKNOWN)
    }
}

/// See [`cef_ssl_content_status_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SslContentStatus(cef_ssl_content_status_t);
impl AsRef<cef_ssl_content_status_t> for SslContentStatus {
    fn as_ref(&self) -> &cef_ssl_content_status_t {
        &self.0
    }
}
impl AsMut<cef_ssl_content_status_t> for SslContentStatus {
    fn as_mut(&mut self) -> &mut cef_ssl_content_status_t {
        &mut self.0
    }
}
impl From<cef_ssl_content_status_t> for SslContentStatus {
    fn from(value: cef_ssl_content_status_t) -> Self {
        Self(value)
    }
}
impl From<SslContentStatus> for cef_ssl_content_status_t {
    fn from(value: SslContentStatus) -> Self {
        value.0
    }
}
impl Default for SslContentStatus {
    fn default() -> Self {
        Self(cef_ssl_content_status_t::SSL_CONTENT_NORMAL_CONTENT)
    }
}

/// See [`cef_scheme_options_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SchemeOptions(cef_scheme_options_t);
impl AsRef<cef_scheme_options_t> for SchemeOptions {
    fn as_ref(&self) -> &cef_scheme_options_t {
        &self.0
    }
}
impl AsMut<cef_scheme_options_t> for SchemeOptions {
    fn as_mut(&mut self) -> &mut cef_scheme_options_t {
        &mut self.0
    }
}
impl From<cef_scheme_options_t> for SchemeOptions {
    fn from(value: cef_scheme_options_t) -> Self {
        Self(value)
    }
}
impl From<SchemeOptions> for cef_scheme_options_t {
    fn from(value: SchemeOptions) -> Self {
        value.0
    }
}
impl Default for SchemeOptions {
    fn default() -> Self {
        Self(cef_scheme_options_t::CEF_SCHEME_OPTION_NONE)
    }
}

/// See [`cef_composition_underline_style_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct CompositionUnderlineStyle(cef_composition_underline_style_t);
impl AsRef<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn as_ref(&self) -> &cef_composition_underline_style_t {
        &self.0
    }
}
impl AsMut<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn as_mut(&mut self) -> &mut cef_composition_underline_style_t {
        &mut self.0
    }
}
impl From<cef_composition_underline_style_t> for CompositionUnderlineStyle {
    fn from(value: cef_composition_underline_style_t) -> Self {
        Self(value)
    }
}
impl From<CompositionUnderlineStyle> for cef_composition_underline_style_t {
    fn from(value: CompositionUnderlineStyle) -> Self {
        value.0
    }
}
impl Default for CompositionUnderlineStyle {
    fn default() -> Self {
        Self(cef_composition_underline_style_t::CEF_CUS_SOLID)
    }
}

/// See [`cef_channel_layout_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChannelLayout(cef_channel_layout_t);
impl AsRef<cef_channel_layout_t> for ChannelLayout {
    fn as_ref(&self) -> &cef_channel_layout_t {
        &self.0
    }
}
impl AsMut<cef_channel_layout_t> for ChannelLayout {
    fn as_mut(&mut self) -> &mut cef_channel_layout_t {
        &mut self.0
    }
}
impl From<cef_channel_layout_t> for ChannelLayout {
    fn from(value: cef_channel_layout_t) -> Self {
        Self(value)
    }
}
impl From<ChannelLayout> for cef_channel_layout_t {
    fn from(value: ChannelLayout) -> Self {
        value.0
    }
}
impl Default for ChannelLayout {
    fn default() -> Self {
        Self(cef_channel_layout_t::CEF_CHANNEL_LAYOUT_NONE)
    }
}

/// See [`cef_media_route_create_result_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaRouteCreateResult(cef_media_route_create_result_t);
impl AsRef<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn as_ref(&self) -> &cef_media_route_create_result_t {
        &self.0
    }
}
impl AsMut<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn as_mut(&mut self) -> &mut cef_media_route_create_result_t {
        &mut self.0
    }
}
impl From<cef_media_route_create_result_t> for MediaRouteCreateResult {
    fn from(value: cef_media_route_create_result_t) -> Self {
        Self(value)
    }
}
impl From<MediaRouteCreateResult> for cef_media_route_create_result_t {
    fn from(value: MediaRouteCreateResult) -> Self {
        value.0
    }
}
impl Default for MediaRouteCreateResult {
    fn default() -> Self {
        Self(cef_media_route_create_result_t::CEF_MRCR_UNKNOWN_ERROR)
    }
}

/// See [`cef_media_route_connection_state_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaRouteConnectionState(cef_media_route_connection_state_t);
impl AsRef<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn as_ref(&self) -> &cef_media_route_connection_state_t {
        &self.0
    }
}
impl AsMut<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn as_mut(&mut self) -> &mut cef_media_route_connection_state_t {
        &mut self.0
    }
}
impl From<cef_media_route_connection_state_t> for MediaRouteConnectionState {
    fn from(value: cef_media_route_connection_state_t) -> Self {
        Self(value)
    }
}
impl From<MediaRouteConnectionState> for cef_media_route_connection_state_t {
    fn from(value: MediaRouteConnectionState) -> Self {
        value.0
    }
}
impl Default for MediaRouteConnectionState {
    fn default() -> Self {
        Self(cef_media_route_connection_state_t::CEF_MRCS_UNKNOWN)
    }
}

/// See [`cef_media_sink_icon_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaSinkIconType(cef_media_sink_icon_type_t);
impl AsRef<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn as_ref(&self) -> &cef_media_sink_icon_type_t {
        &self.0
    }
}
impl AsMut<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn as_mut(&mut self) -> &mut cef_media_sink_icon_type_t {
        &mut self.0
    }
}
impl From<cef_media_sink_icon_type_t> for MediaSinkIconType {
    fn from(value: cef_media_sink_icon_type_t) -> Self {
        Self(value)
    }
}
impl From<MediaSinkIconType> for cef_media_sink_icon_type_t {
    fn from(value: MediaSinkIconType) -> Self {
        value.0
    }
}
impl Default for MediaSinkIconType {
    fn default() -> Self {
        Self(cef_media_sink_icon_type_t::CEF_MSIT_CAST)
    }
}

/// See [`cef_text_field_commands_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TextFieldCommands(cef_text_field_commands_t);
impl AsRef<cef_text_field_commands_t> for TextFieldCommands {
    fn as_ref(&self) -> &cef_text_field_commands_t {
        &self.0
    }
}
impl AsMut<cef_text_field_commands_t> for TextFieldCommands {
    fn as_mut(&mut self) -> &mut cef_text_field_commands_t {
        &mut self.0
    }
}
impl From<cef_text_field_commands_t> for TextFieldCommands {
    fn from(value: cef_text_field_commands_t) -> Self {
        Self(value)
    }
}
impl From<TextFieldCommands> for cef_text_field_commands_t {
    fn from(value: TextFieldCommands) -> Self {
        value.0
    }
}
impl Default for TextFieldCommands {
    fn default() -> Self {
        Self(cef_text_field_commands_t::CEF_TFC_UNKNOWN)
    }
}

/// See [`cef_chrome_toolbar_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromeToolbarType(cef_chrome_toolbar_type_t);
impl AsRef<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn as_ref(&self) -> &cef_chrome_toolbar_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn as_mut(&mut self) -> &mut cef_chrome_toolbar_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_toolbar_type_t> for ChromeToolbarType {
    fn from(value: cef_chrome_toolbar_type_t) -> Self {
        Self(value)
    }
}
impl From<ChromeToolbarType> for cef_chrome_toolbar_type_t {
    fn from(value: ChromeToolbarType) -> Self {
        value.0
    }
}
impl Default for ChromeToolbarType {
    fn default() -> Self {
        Self(cef_chrome_toolbar_type_t::CEF_CTT_UNKNOWN)
    }
}

/// See [`cef_chrome_page_action_icon_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromePageActionIconType(cef_chrome_page_action_icon_type_t);
impl AsRef<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn as_ref(&self) -> &cef_chrome_page_action_icon_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn as_mut(&mut self) -> &mut cef_chrome_page_action_icon_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_page_action_icon_type_t> for ChromePageActionIconType {
    fn from(value: cef_chrome_page_action_icon_type_t) -> Self {
        Self(value)
    }
}
impl From<ChromePageActionIconType> for cef_chrome_page_action_icon_type_t {
    fn from(value: ChromePageActionIconType) -> Self {
        value.0
    }
}
impl Default for ChromePageActionIconType {
    fn default() -> Self {
        Self(cef_chrome_page_action_icon_type_t::CEF_CPAIT_BOOKMARK_STAR)
    }
}

/// See [`cef_chrome_toolbar_button_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ChromeToolbarButtonType(cef_chrome_toolbar_button_type_t);
impl AsRef<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn as_ref(&self) -> &cef_chrome_toolbar_button_type_t {
        &self.0
    }
}
impl AsMut<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn as_mut(&mut self) -> &mut cef_chrome_toolbar_button_type_t {
        &mut self.0
    }
}
impl From<cef_chrome_toolbar_button_type_t> for ChromeToolbarButtonType {
    fn from(value: cef_chrome_toolbar_button_type_t) -> Self {
        Self(value)
    }
}
impl From<ChromeToolbarButtonType> for cef_chrome_toolbar_button_type_t {
    fn from(value: ChromeToolbarButtonType) -> Self {
        value.0
    }
}
impl Default for ChromeToolbarButtonType {
    fn default() -> Self {
        Self(cef_chrome_toolbar_button_type_t::CEF_CTBT_CAST)
    }
}

/// See [`cef_docking_mode_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DockingMode(cef_docking_mode_t);
impl AsRef<cef_docking_mode_t> for DockingMode {
    fn as_ref(&self) -> &cef_docking_mode_t {
        &self.0
    }
}
impl AsMut<cef_docking_mode_t> for DockingMode {
    fn as_mut(&mut self) -> &mut cef_docking_mode_t {
        &mut self.0
    }
}
impl From<cef_docking_mode_t> for DockingMode {
    fn from(value: cef_docking_mode_t) -> Self {
        Self(value)
    }
}
impl From<DockingMode> for cef_docking_mode_t {
    fn from(value: DockingMode) -> Self {
        value.0
    }
}
impl Default for DockingMode {
    fn default() -> Self {
        Self(cef_docking_mode_t::CEF_DOCKING_MODE_TOP_LEFT)
    }
}

/// See [`cef_show_state_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ShowState(cef_show_state_t);
impl AsRef<cef_show_state_t> for ShowState {
    fn as_ref(&self) -> &cef_show_state_t {
        &self.0
    }
}
impl AsMut<cef_show_state_t> for ShowState {
    fn as_mut(&mut self) -> &mut cef_show_state_t {
        &mut self.0
    }
}
impl From<cef_show_state_t> for ShowState {
    fn from(value: cef_show_state_t) -> Self {
        Self(value)
    }
}
impl From<ShowState> for cef_show_state_t {
    fn from(value: ShowState) -> Self {
        value.0
    }
}
impl Default for ShowState {
    fn default() -> Self {
        Self(cef_show_state_t::CEF_SHOW_STATE_NORMAL)
    }
}

/// See [`cef_touch_handle_state_flags_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TouchHandleStateFlags(cef_touch_handle_state_flags_t);
impl AsRef<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn as_ref(&self) -> &cef_touch_handle_state_flags_t {
        &self.0
    }
}
impl AsMut<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn as_mut(&mut self) -> &mut cef_touch_handle_state_flags_t {
        &mut self.0
    }
}
impl From<cef_touch_handle_state_flags_t> for TouchHandleStateFlags {
    fn from(value: cef_touch_handle_state_flags_t) -> Self {
        Self(value)
    }
}
impl From<TouchHandleStateFlags> for cef_touch_handle_state_flags_t {
    fn from(value: TouchHandleStateFlags) -> Self {
        value.0
    }
}
impl Default for TouchHandleStateFlags {
    fn default() -> Self {
        Self(cef_touch_handle_state_flags_t::CEF_THS_FLAG_NONE)
    }
}

/// See [`cef_media_access_permission_types_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct MediaAccessPermissionTypes(cef_media_access_permission_types_t);
impl AsRef<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn as_ref(&self) -> &cef_media_access_permission_types_t {
        &self.0
    }
}
impl AsMut<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn as_mut(&mut self) -> &mut cef_media_access_permission_types_t {
        &mut self.0
    }
}
impl From<cef_media_access_permission_types_t> for MediaAccessPermissionTypes {
    fn from(value: cef_media_access_permission_types_t) -> Self {
        Self(value)
    }
}
impl From<MediaAccessPermissionTypes> for cef_media_access_permission_types_t {
    fn from(value: MediaAccessPermissionTypes) -> Self {
        value.0
    }
}
impl Default for MediaAccessPermissionTypes {
    fn default() -> Self {
        Self(cef_media_access_permission_types_t::CEF_MEDIA_PERMISSION_NONE)
    }
}

/// See [`cef_permission_request_types_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PermissionRequestTypes(cef_permission_request_types_t);
impl AsRef<cef_permission_request_types_t> for PermissionRequestTypes {
    fn as_ref(&self) -> &cef_permission_request_types_t {
        &self.0
    }
}
impl AsMut<cef_permission_request_types_t> for PermissionRequestTypes {
    fn as_mut(&mut self) -> &mut cef_permission_request_types_t {
        &mut self.0
    }
}
impl From<cef_permission_request_types_t> for PermissionRequestTypes {
    fn from(value: cef_permission_request_types_t) -> Self {
        Self(value)
    }
}
impl From<PermissionRequestTypes> for cef_permission_request_types_t {
    fn from(value: PermissionRequestTypes) -> Self {
        value.0
    }
}
impl Default for PermissionRequestTypes {
    fn default() -> Self {
        Self(cef_permission_request_types_t::CEF_PERMISSION_TYPE_NONE)
    }
}

/// See [`cef_permission_request_result_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PermissionRequestResult(cef_permission_request_result_t);
impl AsRef<cef_permission_request_result_t> for PermissionRequestResult {
    fn as_ref(&self) -> &cef_permission_request_result_t {
        &self.0
    }
}
impl AsMut<cef_permission_request_result_t> for PermissionRequestResult {
    fn as_mut(&mut self) -> &mut cef_permission_request_result_t {
        &mut self.0
    }
}
impl From<cef_permission_request_result_t> for PermissionRequestResult {
    fn from(value: cef_permission_request_result_t) -> Self {
        Self(value)
    }
}
impl From<PermissionRequestResult> for cef_permission_request_result_t {
    fn from(value: PermissionRequestResult) -> Self {
        value.0
    }
}
impl Default for PermissionRequestResult {
    fn default() -> Self {
        Self(cef_permission_request_result_t::CEF_PERMISSION_RESULT_ACCEPT)
    }
}

/// See [`cef_test_cert_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TestCertType(cef_test_cert_type_t);
impl AsRef<cef_test_cert_type_t> for TestCertType {
    fn as_ref(&self) -> &cef_test_cert_type_t {
        &self.0
    }
}
impl AsMut<cef_test_cert_type_t> for TestCertType {
    fn as_mut(&mut self) -> &mut cef_test_cert_type_t {
        &mut self.0
    }
}
impl From<cef_test_cert_type_t> for TestCertType {
    fn from(value: cef_test_cert_type_t) -> Self {
        Self(value)
    }
}
impl From<TestCertType> for cef_test_cert_type_t {
    fn from(value: TestCertType) -> Self {
        value.0
    }
}
impl Default for TestCertType {
    fn default() -> Self {
        Self(cef_test_cert_type_t::CEF_TEST_CERT_OK_IP)
    }
}

/// See [`cef_preferences_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct PreferencesType(cef_preferences_type_t);
impl AsRef<cef_preferences_type_t> for PreferencesType {
    fn as_ref(&self) -> &cef_preferences_type_t {
        &self.0
    }
}
impl AsMut<cef_preferences_type_t> for PreferencesType {
    fn as_mut(&mut self) -> &mut cef_preferences_type_t {
        &mut self.0
    }
}
impl From<cef_preferences_type_t> for PreferencesType {
    fn from(value: cef_preferences_type_t) -> Self {
        Self(value)
    }
}
impl From<PreferencesType> for cef_preferences_type_t {
    fn from(value: PreferencesType) -> Self {
        value.0
    }
}
impl Default for PreferencesType {
    fn default() -> Self {
        Self(cef_preferences_type_t::CEF_PREFERENCES_TYPE_GLOBAL)
    }
}

/// See [`cef_download_interrupt_reason_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct DownloadInterruptReason(cef_download_interrupt_reason_t);
impl AsRef<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn as_ref(&self) -> &cef_download_interrupt_reason_t {
        &self.0
    }
}
impl AsMut<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn as_mut(&mut self) -> &mut cef_download_interrupt_reason_t {
        &mut self.0
    }
}
impl From<cef_download_interrupt_reason_t> for DownloadInterruptReason {
    fn from(value: cef_download_interrupt_reason_t) -> Self {
        Self(value)
    }
}
impl From<DownloadInterruptReason> for cef_download_interrupt_reason_t {
    fn from(value: DownloadInterruptReason) -> Self {
        value.0
    }
}
impl Default for DownloadInterruptReason {
    fn default() -> Self {
        Self(cef_download_interrupt_reason_t::CEF_DOWNLOAD_INTERRUPT_REASON_NONE)
    }
}

/// See [`cef_gesture_command_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct GestureCommand(cef_gesture_command_t);
impl AsRef<cef_gesture_command_t> for GestureCommand {
    fn as_ref(&self) -> &cef_gesture_command_t {
        &self.0
    }
}
impl AsMut<cef_gesture_command_t> for GestureCommand {
    fn as_mut(&mut self) -> &mut cef_gesture_command_t {
        &mut self.0
    }
}
impl From<cef_gesture_command_t> for GestureCommand {
    fn from(value: cef_gesture_command_t) -> Self {
        Self(value)
    }
}
impl From<GestureCommand> for cef_gesture_command_t {
    fn from(value: GestureCommand) -> Self {
        value.0
    }
}
impl Default for GestureCommand {
    fn default() -> Self {
        Self(cef_gesture_command_t::CEF_GESTURE_COMMAND_BACK)
    }
}

/// See [`cef_zoom_command_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ZoomCommand(cef_zoom_command_t);
impl AsRef<cef_zoom_command_t> for ZoomCommand {
    fn as_ref(&self) -> &cef_zoom_command_t {
        &self.0
    }
}
impl AsMut<cef_zoom_command_t> for ZoomCommand {
    fn as_mut(&mut self) -> &mut cef_zoom_command_t {
        &mut self.0
    }
}
impl From<cef_zoom_command_t> for ZoomCommand {
    fn from(value: cef_zoom_command_t) -> Self {
        Self(value)
    }
}
impl From<ZoomCommand> for cef_zoom_command_t {
    fn from(value: ZoomCommand) -> Self {
        value.0
    }
}
impl Default for ZoomCommand {
    fn default() -> Self {
        Self(cef_zoom_command_t::CEF_ZOOM_COMMAND_OUT)
    }
}

/// See [`cef_color_variant_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ColorVariant(cef_color_variant_t);
impl AsRef<cef_color_variant_t> for ColorVariant {
    fn as_ref(&self) -> &cef_color_variant_t {
        &self.0
    }
}
impl AsMut<cef_color_variant_t> for ColorVariant {
    fn as_mut(&mut self) -> &mut cef_color_variant_t {
        &mut self.0
    }
}
impl From<cef_color_variant_t> for ColorVariant {
    fn from(value: cef_color_variant_t) -> Self {
        Self(value)
    }
}
impl From<ColorVariant> for cef_color_variant_t {
    fn from(value: ColorVariant) -> Self {
        value.0
    }
}
impl Default for ColorVariant {
    fn default() -> Self {
        Self(cef_color_variant_t::CEF_COLOR_VARIANT_SYSTEM)
    }
}

/// See [`cef_task_type_t`] for more documentation.
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct TaskType(cef_task_type_t);
impl AsRef<cef_task_type_t> for TaskType {
    fn as_ref(&self) -> &cef_task_type_t {
        &self.0
    }
}
impl AsMut<cef_task_type_t> for TaskType {
    fn as_mut(&mut self) -> &mut cef_task_type_t {
        &mut self.0
    }
}
impl From<cef_task_type_t> for TaskType {
    fn from(value: cef_task_type_t) -> Self {
        Self(value)
    }
}
impl From<TaskType> for cef_task_type_t {
    fn from(value: TaskType) -> Self {
        value.0
    }
}
impl Default for TaskType {
    fn default() -> Self {
        Self(cef_task_type_t::CEF_TASK_TYPE_UNKNOWN)
    }
}

/// See [`cef_load_library`] for more documentation.
pub fn load_library(path: Option<&::std::os::raw::c_char>) -> ::std::os::raw::c_int {
    unsafe {
        let arg_path = path;
        let arg_path = arg_path.map(std::ptr::from_ref).unwrap_or(std::ptr::null());
        let result = cef_load_library(arg_path);
        result.wrap_result()
    }
}

/// See [`cef_unload_library`] for more documentation.
pub fn unload_library() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_unload_library();
        result.wrap_result()
    }
}

/// See [`cef_sandbox_initialize`] for more documentation.
pub fn sandbox_initialize(
    argc: ::std::os::raw::c_int,
    argv: *mut *mut ::std::os::raw::c_char,
) -> *mut ::std::os::raw::c_void {
    unsafe {
        let (arg_argc, arg_argv) = (argc, argv);
        let arg_argv = arg_argv.cast();
        let result = cef_sandbox_initialize(arg_argc, arg_argv);
        result.wrap_result()
    }
}

/// See [`cef_sandbox_destroy`] for more documentation.
pub fn sandbox_destroy(sandbox_context: *mut u8) {
    unsafe {
        let arg_sandbox_context = sandbox_context;
        let arg_sandbox_context = arg_sandbox_context.cast();
        cef_sandbox_destroy(arg_sandbox_context);
    }
}

/// See [`cef_api_hash`] for more documentation.
pub fn api_hash(
    version: ::std::os::raw::c_int,
    entry: ::std::os::raw::c_int,
) -> *const ::std::os::raw::c_char {
    unsafe {
        let (arg_version, arg_entry) = (version, entry);
        let result = cef_api_hash(arg_version, arg_entry);
        result.wrap_result()
    }
}

/// See [`cef_api_version`] for more documentation.
pub fn api_version() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_api_version();
        result.wrap_result()
    }
}

/// See [`cef_string_wide_set`] for more documentation.
pub fn string_wide_set(
    src: Option<&[wchar_t]>,
    output: Option<&mut CefStringWide>,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_wide_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.wrap_result()
    }
}

/// See [`cef_string_utf8_set`] for more documentation.
pub fn string_utf8_set(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringUtf8>,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf8_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.wrap_result()
    }
}

/// See [`cef_string_utf16_set`] for more documentation.
pub fn string_utf16_set(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringUtf16>,
    copy: ::std::os::raw::c_int,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output, arg_copy) = (src, output, copy);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_set(arg_src, arg_src_len, arg_output, arg_copy);
        result.wrap_result()
    }
}

/// See [`cef_string_wide_clear`] for more documentation.
pub fn string_wide_clear(str_: Option<&mut CefStringWide>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_wide_clear(arg_str_);
    }
}

/// See [`cef_string_utf8_clear`] for more documentation.
pub fn string_utf8_clear(str_: Option<&mut CefStringUtf8>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_utf8_clear(arg_str_);
    }
}

/// See [`cef_string_utf16_clear`] for more documentation.
pub fn string_utf16_clear(str_: Option<&mut CefStringUtf16>) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_utf16_clear(arg_str_);
    }
}

/// See [`cef_string_wide_cmp`] for more documentation.
pub fn string_wide_cmp(
    str_1: Option<&CefStringWide>,
    str_2: Option<&CefStringWide>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_str_2 = arg_str_2
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_wide_cmp(arg_str_1, arg_str_2);
        result.wrap_result()
    }
}

/// See [`cef_string_utf8_cmp`] for more documentation.
pub fn string_utf8_cmp(
    str_1: Option<&CefStringUtf8>,
    str_2: Option<&CefStringUtf8>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_str_2 = arg_str_2
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_utf8_cmp(arg_str_1, arg_str_2);
        result.wrap_result()
    }
}

/// See [`cef_string_utf16_cmp`] for more documentation.
pub fn string_utf16_cmp(
    str_1: Option<&CefStringUtf16>,
    str_2: Option<&CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_str_1, arg_str_2) = (str_1, str_2);
        let arg_str_1 = arg_str_1
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_str_2 = arg_str_2
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_utf16_cmp(arg_str_1, arg_str_2);
        result.wrap_result()
    }
}

/// See [`cef_string_wide_to_utf8`] for more documentation.
pub fn string_wide_to_utf8(
    src: Option<&[wchar_t]>,
    output: Option<&mut CefStringUtf8>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_wide_to_utf8(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_utf8_to_wide`] for more documentation.
pub fn string_utf8_to_wide(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringWide>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf8_to_wide(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_wide_to_utf16`] for more documentation.
pub fn string_wide_to_utf16(
    src: Option<&[wchar_t]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_wide_to_utf16(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_utf16_to_wide`] for more documentation.
pub fn string_utf16_to_wide(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringWide>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_to_wide(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_utf8_to_utf16`] for more documentation.
pub fn string_utf8_to_utf16(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf8_to_utf16(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_utf16_to_utf8`] for more documentation.
pub fn string_utf16_to_utf8(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringUtf8>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_to_utf8(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_ascii_to_wide`] for more documentation.
pub fn string_ascii_to_wide(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringWide>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_ascii_to_wide(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_ascii_to_utf16`] for more documentation.
pub fn string_ascii_to_utf16(
    src: Option<&[::std::os::raw::c_char]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_ascii_to_utf16(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_userfree_wide_alloc`] for more documentation.
pub fn string_userfree_wide_alloc() -> CefStringUserfreeWide {
    unsafe {
        let result = cef_string_userfree_wide_alloc();
        result.wrap_result()
    }
}

/// See [`cef_string_userfree_utf8_alloc`] for more documentation.
pub fn string_userfree_utf8_alloc() -> CefStringUserfreeUtf8 {
    unsafe {
        let result = cef_string_userfree_utf8_alloc();
        result.wrap_result()
    }
}

/// See [`cef_string_userfree_utf16_alloc`] for more documentation.
pub fn string_userfree_utf16_alloc() -> CefStringUserfreeUtf16 {
    unsafe {
        let result = cef_string_userfree_utf16_alloc();
        result.wrap_result()
    }
}

/// See [`cef_string_userfree_wide_free`] for more documentation.
pub fn string_userfree_wide_free(str_: CefStringUserfreeWide) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.into_raw();
        cef_string_userfree_wide_free(arg_str_);
    }
}

/// See [`cef_string_userfree_utf8_free`] for more documentation.
pub fn string_userfree_utf8_free(str_: CefStringUserfreeUtf8) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.into_raw();
        cef_string_userfree_utf8_free(arg_str_);
    }
}

/// See [`cef_string_userfree_utf16_free`] for more documentation.
pub fn string_userfree_utf16_free(str_: CefStringUserfreeUtf16) {
    unsafe {
        let arg_str_ = str_;
        let arg_str_ = arg_str_.into_raw();
        cef_string_userfree_utf16_free(arg_str_);
    }
}

/// See [`cef_string_utf16_to_lower`] for more documentation.
pub fn string_utf16_to_lower(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_to_lower(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_utf16_to_upper`] for more documentation.
pub fn string_utf16_to_upper(
    src: Option<&[char16_t]>,
    output: Option<&mut CefStringUtf16>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_src, arg_output) = (src, output);
        let arg_src_len = arg_src.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_src = arg_src
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let arg_output = arg_output
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_utf16_to_upper(arg_src, arg_src_len, arg_output);
        result.wrap_result()
    }
}

/// See [`cef_string_list_alloc`] for more documentation.
pub fn string_list_alloc() -> Option<CefStringList> {
    unsafe {
        let result = cef_string_list_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_string_list_size`] for more documentation.
pub fn string_list_size(list: Option<&mut CefStringList>) -> usize {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_list_size(arg_list);
        result.wrap_result()
    }
}

/// See [`cef_string_list_value`] for more documentation.
pub fn string_list_value(
    list: Option<&mut CefStringList>,
    index: usize,
    value: Option<&mut CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_list, arg_index, arg_value) = (list, index, value);
        let arg_list = arg_list
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_list_value(arg_list, arg_index, arg_value);
        result.wrap_result()
    }
}

/// See [`cef_string_list_append`] for more documentation.
pub fn string_list_append(list: Option<&mut CefStringList>, value: Option<&CefString>) {
    unsafe {
        let (arg_list, arg_value) = (list, value);
        let arg_list = arg_list
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        cef_string_list_append(arg_list, arg_value);
    }
}

/// See [`cef_string_list_clear`] for more documentation.
pub fn string_list_clear(list: Option<&mut CefStringList>) {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_list_clear(arg_list);
    }
}

/// See [`cef_string_list_free`] for more documentation.
pub fn string_list_free(list: Option<&mut CefStringList>) {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_list_free(arg_list);
    }
}

/// See [`cef_string_list_copy`] for more documentation.
pub fn string_list_copy(list: Option<&mut CefStringList>) -> Option<CefStringList> {
    unsafe {
        let arg_list = list;
        let arg_list = arg_list
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_list_copy(arg_list);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_string_map_alloc`] for more documentation.
pub fn string_map_alloc() -> Option<CefStringMap> {
    unsafe {
        let result = cef_string_map_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_string_map_size`] for more documentation.
pub fn string_map_size(map: Option<&mut CefStringMap>) -> usize {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_size(arg_map);
        result.wrap_result()
    }
}

/// See [`cef_string_map_find`] for more documentation.
pub fn string_map_find(
    map: Option<&mut CefStringMap>,
    key: Option<&CefString>,
    value: Option<&mut CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_find(arg_map, arg_key, arg_value);
        result.wrap_result()
    }
}

/// See [`cef_string_map_key`] for more documentation.
pub fn string_map_key(
    map: Option<&mut CefStringMap>,
    index: usize,
    key: Option<&mut CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_key) = (map, index, key);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_key(arg_map, arg_index, arg_key);
        result.wrap_result()
    }
}

/// See [`cef_string_map_value`] for more documentation.
pub fn string_map_value(
    map: Option<&mut CefStringMap>,
    index: usize,
    value: Option<&mut CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_value) = (map, index, value);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_map_value(arg_map, arg_index, arg_value);
        result.wrap_result()
    }
}

/// See [`cef_string_map_append`] for more documentation.
pub fn string_map_append(
    map: Option<&mut CefStringMap>,
    key: Option<&CefString>,
    value: Option<&CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_map_append(arg_map, arg_key, arg_value);
        result.wrap_result()
    }
}

/// See [`cef_string_map_clear`] for more documentation.
pub fn string_map_clear(map: Option<&mut CefStringMap>) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_map_clear(arg_map);
    }
}

/// See [`cef_string_map_free`] for more documentation.
pub fn string_map_free(map: Option<&mut CefStringMap>) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_map_free(arg_map);
    }
}

/// See [`cef_string_multimap_alloc`] for more documentation.
pub fn string_multimap_alloc() -> Option<CefStringMultimap> {
    unsafe {
        let result = cef_string_multimap_alloc();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_string_multimap_size`] for more documentation.
pub fn string_multimap_size(map: Option<&mut CefStringMultimap>) -> usize {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_size(arg_map);
        result.wrap_result()
    }
}

/// See [`cef_string_multimap_find_count`] for more documentation.
pub fn string_multimap_find_count(
    map: Option<&mut CefStringMultimap>,
    key: Option<&CefString>,
) -> usize {
    unsafe {
        let (arg_map, arg_key) = (map, key);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_multimap_find_count(arg_map, arg_key);
        result.wrap_result()
    }
}

/// See [`cef_string_multimap_enumerate`] for more documentation.
pub fn string_multimap_enumerate(
    map: Option<&mut CefStringMultimap>,
    key: Option<&CefString>,
    value_index: usize,
    value: Option<&mut CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value_index, arg_value) = (map, key, value_index, value);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_enumerate(arg_map, arg_key, arg_value_index, arg_value);
        result.wrap_result()
    }
}

/// See [`cef_string_multimap_key`] for more documentation.
pub fn string_multimap_key(
    map: Option<&mut CefStringMultimap>,
    index: usize,
    key: Option<&mut CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_key) = (map, index, key);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_key(arg_map, arg_index, arg_key);
        result.wrap_result()
    }
}

/// See [`cef_string_multimap_value`] for more documentation.
pub fn string_multimap_value(
    map: Option<&mut CefStringMultimap>,
    index: usize,
    value: Option<&mut CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_index, arg_value) = (map, index, value);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let result = cef_string_multimap_value(arg_map, arg_index, arg_value);
        result.wrap_result()
    }
}

/// See [`cef_string_multimap_append`] for more documentation.
pub fn string_multimap_append(
    map: Option<&mut CefStringMultimap>,
    key: Option<&CefString>,
    value: Option<&CefString>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_map, arg_key, arg_value) = (map, key, value);
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        let arg_key = arg_key
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_string_multimap_append(arg_map, arg_key, arg_value);
        result.wrap_result()
    }
}

/// See [`cef_string_multimap_clear`] for more documentation.
pub fn string_multimap_clear(map: Option<&mut CefStringMultimap>) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_multimap_clear(arg_map);
    }
}

/// See [`cef_string_multimap_free`] for more documentation.
pub fn string_multimap_free(map: Option<&mut CefStringMultimap>) {
    unsafe {
        let arg_map = map;
        let arg_map = arg_map
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_string_multimap_free(arg_map);
    }
}

/// See [`cef_time_to_timet`] for more documentation.
pub fn time_to_timet(cef_time: Option<&Time>, time: Option<&mut time_t>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time, arg_time) = (cef_time, time);
        let arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_time = arg_time
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_to_timet(arg_cef_time, arg_time);
        result.wrap_result()
    }
}

/// See [`cef_time_from_timet`] for more documentation.
pub fn time_from_timet(time: time_t, cef_time: Option<&mut Time>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_time, arg_cef_time) = (time, cef_time);
        let mut arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_from_timet(arg_time, arg_cef_time);
        result.wrap_result()
    }
}

/// See [`cef_time_to_doublet`] for more documentation.
pub fn time_to_doublet(cef_time: Option<&Time>, time: Option<&mut f64>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time, arg_time) = (cef_time, time);
        let arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_time = arg_time
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_to_doublet(arg_cef_time, arg_time);
        result.wrap_result()
    }
}

/// See [`cef_time_from_doublet`] for more documentation.
pub fn time_from_doublet(time: f64, cef_time: Option<&mut Time>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_time, arg_cef_time) = (time, cef_time);
        let mut arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_from_doublet(arg_time, arg_cef_time);
        result.wrap_result()
    }
}

/// See [`cef_time_now`] for more documentation.
pub fn time_now(cef_time: Option<&mut Time>) -> ::std::os::raw::c_int {
    unsafe {
        let arg_cef_time = cef_time;
        let mut arg_cef_time = arg_cef_time.cloned().map(|arg| arg.into());
        let arg_cef_time = arg_cef_time
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_now(arg_cef_time);
        result.wrap_result()
    }
}

/// See [`cef_basetime_now`] for more documentation.
pub fn basetime_now() -> Basetime {
    unsafe {
        let result = cef_basetime_now();
        result.wrap_result()
    }
}

/// See [`cef_time_delta`] for more documentation.
pub fn time_delta(
    cef_time_1: Option<&Time>,
    cef_time_2: Option<&Time>,
    delta: Option<&mut ::std::os::raw::c_longlong>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_cef_time_1, arg_cef_time_2, arg_delta) = (cef_time_1, cef_time_2, delta);
        let arg_cef_time_1 = arg_cef_time_1.cloned().map(|arg| arg.into());
        let arg_cef_time_1 = arg_cef_time_1
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_cef_time_2 = arg_cef_time_2.cloned().map(|arg| arg.into());
        let arg_cef_time_2 = arg_cef_time_2
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_delta = arg_delta
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_delta(arg_cef_time_1, arg_cef_time_2, arg_delta);
        result.wrap_result()
    }
}

/// See [`cef_time_to_basetime`] for more documentation.
pub fn time_to_basetime(from: Option<&Time>, to: Option<&mut Basetime>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_from, arg_to) = (from, to);
        let arg_from = arg_from.cloned().map(|arg| arg.into());
        let arg_from = arg_from
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let mut arg_to = arg_to.cloned().map(|arg| arg.into());
        let arg_to = arg_to
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_to_basetime(arg_from, arg_to);
        result.wrap_result()
    }
}

/// See [`cef_time_from_basetime`] for more documentation.
pub fn time_from_basetime(from: _cef_basetime_t, to: Option<&mut Time>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_from, arg_to) = (from, to);
        let mut arg_to = arg_to.cloned().map(|arg| arg.into());
        let arg_to = arg_to
            .as_mut()
            .map(std::ptr::from_mut)
            .unwrap_or(std::ptr::null_mut());
        let result = cef_time_from_basetime(arg_from, arg_to);
        result.wrap_result()
    }
}

/// See [`cef_value_create`] for more documentation.
pub fn value_create() -> Option<Value> {
    unsafe {
        let result = cef_value_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_binary_value_create`] for more documentation.
pub fn binary_value_create(data: Option<&[u8]>) -> Option<BinaryValue> {
    unsafe {
        let arg_data = data;
        let arg_data_size = arg_data.as_ref().map(|arg| arg.len()).unwrap_or_default();
        let arg_data = arg_data
            .and_then(|arg| {
                if arg.is_empty() {
                    None
                } else {
                    Some(arg.as_ptr().cast())
                }
            })
            .unwrap_or(std::ptr::null());
        let result = cef_binary_value_create(arg_data, arg_data_size);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_dictionary_value_create`] for more documentation.
pub fn dictionary_value_create() -> Option<DictionaryValue> {
    unsafe {
        let result = cef_dictionary_value_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_list_value_create`] for more documentation.
pub fn list_value_create() -> Option<ListValue> {
    unsafe {
        let result = cef_list_value_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_image_create`] for more documentation.
pub fn image_create() -> Option<Image> {
    unsafe {
        let result = cef_image_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_stream_reader_create_for_file`] for more documentation.
pub fn stream_reader_create_for_file(file_name: Option<&CefString>) -> Option<StreamReader> {
    unsafe {
        let arg_file_name = file_name;
        let arg_file_name = arg_file_name
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_stream_reader_create_for_file(arg_file_name);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_stream_reader_create_for_data`] for more documentation.
pub fn stream_reader_create_for_data(data: *mut u8, size: usize) -> Option<StreamReader> {
    unsafe {
        let (arg_data, arg_size) = (data, size);
        let arg_data = arg_data.cast();
        let result = cef_stream_reader_create_for_data(arg_data, arg_size);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_stream_reader_create_for_handler`] for more documentation.
pub fn stream_reader_create_for_handler(
    handler: Option<&mut impl ImplReadHandler>,
) -> Option<StreamReader> {
    unsafe {
        let arg_handler = handler;
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplReadHandler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_stream_reader_create_for_handler(arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_stream_writer_create_for_file`] for more documentation.
pub fn stream_writer_create_for_file(file_name: Option<&CefString>) -> Option<StreamWriter> {
    unsafe {
        let arg_file_name = file_name;
        let arg_file_name = arg_file_name
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_stream_writer_create_for_file(arg_file_name);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_stream_writer_create_for_handler`] for more documentation.
pub fn stream_writer_create_for_handler(
    handler: Option<&mut impl ImplWriteHandler>,
) -> Option<StreamWriter> {
    unsafe {
        let arg_handler = handler;
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplWriteHandler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_stream_writer_create_for_handler(arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_drag_data_create`] for more documentation.
pub fn drag_data_create() -> Option<DragData> {
    unsafe {
        let result = cef_drag_data_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_process_message_create`] for more documentation.
pub fn process_message_create(name: Option<&CefString>) -> Option<ProcessMessage> {
    unsafe {
        let arg_name = name;
        let arg_name = arg_name
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_process_message_create(arg_name);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_request_create`] for more documentation.
pub fn request_create() -> Option<Request> {
    unsafe {
        let result = cef_request_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_post_data_create`] for more documentation.
pub fn post_data_create() -> Option<PostData> {
    unsafe {
        let result = cef_post_data_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_post_data_element_create`] for more documentation.
pub fn post_data_element_create() -> Option<PostDataElement> {
    unsafe {
        let result = cef_post_data_element_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_cookie_manager_get_global_manager`] for more documentation.
pub fn cookie_manager_get_global_manager(
    callback: Option<&mut impl ImplCompletionCallback>,
) -> Option<CookieManager> {
    unsafe {
        let arg_callback = callback;
        let arg_callback = arg_callback
            .map(|arg| {
                arg.add_ref();
                ImplCompletionCallback::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_cookie_manager_get_global_manager(arg_callback);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_media_router_get_global`] for more documentation.
pub fn media_router_get_global(
    callback: Option<&mut impl ImplCompletionCallback>,
) -> Option<MediaRouter> {
    unsafe {
        let arg_callback = callback;
        let arg_callback = arg_callback
            .map(|arg| {
                arg.add_ref();
                ImplCompletionCallback::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_media_router_get_global(arg_callback);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_preference_manager_get_chrome_variations_as_switches`] for more documentation.
pub fn preference_manager_get_chrome_variations_as_switches(switches: Option<&mut CefStringList>) {
    unsafe {
        let arg_switches = switches;
        let arg_switches = arg_switches
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_preference_manager_get_chrome_variations_as_switches(arg_switches);
    }
}

/// See [`cef_preference_manager_get_chrome_variations_as_strings`] for more documentation.
pub fn preference_manager_get_chrome_variations_as_strings(strings: Option<&mut CefStringList>) {
    unsafe {
        let arg_strings = strings;
        let arg_strings = arg_strings
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null_mut());
        cef_preference_manager_get_chrome_variations_as_strings(arg_strings);
    }
}

/// See [`cef_preference_manager_get_global`] for more documentation.
pub fn preference_manager_get_global() -> Option<PreferenceManager> {
    unsafe {
        let result = cef_preference_manager_get_global();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_request_context_get_global_context`] for more documentation.
pub fn request_context_get_global_context() -> Option<RequestContext> {
    unsafe {
        let result = cef_request_context_get_global_context();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_request_context_create_context`] for more documentation.
pub fn request_context_create_context(
    settings: Option<&RequestContextSettings>,
    handler: Option<&mut impl ImplRequestContextHandler>,
) -> Option<RequestContext> {
    unsafe {
        let (arg_settings, arg_handler) = (settings, handler);
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplRequestContextHandler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_request_context_create_context(arg_settings, arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_request_context_cef_create_context_shared`] for more documentation.
pub fn request_context_cef_create_context_shared(
    other: Option<&mut RequestContext>,
    handler: Option<&mut impl ImplRequestContextHandler>,
) -> Option<RequestContext> {
    unsafe {
        let (arg_other, arg_handler) = (other, handler);
        let arg_other = arg_other
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplRequestContextHandler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_request_context_cef_create_context_shared(arg_other, arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_browser_host_create_browser`] for more documentation.
pub fn browser_host_create_browser(
    window_info: Option<&WindowInfo>,
    client: Option<&mut impl ImplClient>,
    url: Option<&CefString>,
    settings: Option<&BrowserSettings>,
    extra_info: Option<&mut DictionaryValue>,
    request_context: Option<&mut RequestContext>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        ) = (
            window_info,
            client,
            url,
            settings,
            extra_info,
            request_context,
        );
        let arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
        let arg_window_info = arg_window_info
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_client = arg_client
            .map(|arg| {
                arg.add_ref();
                ImplClient::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_url = arg_url
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_extra_info = arg_extra_info
            .map(|arg| {
                arg.add_ref();
                ImplDictionaryValue::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_request_context = arg_request_context
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_browser_host_create_browser(
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        );
        result.wrap_result()
    }
}

/// See [`cef_browser_host_create_browser_sync`] for more documentation.
pub fn browser_host_create_browser_sync(
    window_info: Option<&WindowInfo>,
    client: Option<&mut impl ImplClient>,
    url: Option<&CefString>,
    settings: Option<&BrowserSettings>,
    extra_info: Option<&mut DictionaryValue>,
    request_context: Option<&mut RequestContext>,
) -> Option<Browser> {
    unsafe {
        let (
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        ) = (
            window_info,
            client,
            url,
            settings,
            extra_info,
            request_context,
        );
        let arg_window_info = arg_window_info.cloned().map(|arg| arg.into());
        let arg_window_info = arg_window_info
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_client = arg_client
            .map(|arg| {
                arg.add_ref();
                ImplClient::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_url = arg_url
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_extra_info = arg_extra_info
            .map(|arg| {
                arg.add_ref();
                ImplDictionaryValue::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_request_context = arg_request_context
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_browser_host_create_browser_sync(
            arg_window_info,
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
        );
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_browser_host_get_browser_by_identifier`] for more documentation.
pub fn browser_host_get_browser_by_identifier(
    browser_id: ::std::os::raw::c_int,
) -> Option<Browser> {
    unsafe {
        let arg_browser_id = browser_id;
        let result = cef_browser_host_get_browser_by_identifier(arg_browser_id);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_menu_model_create`] for more documentation.
pub fn menu_model_create(delegate: Option<&mut impl ImplMenuModelDelegate>) -> Option<MenuModel> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplMenuModelDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_menu_model_create(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_print_settings_create`] for more documentation.
pub fn print_settings_create() -> Option<PrintSettings> {
    unsafe {
        let result = cef_print_settings_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_response_create`] for more documentation.
pub fn response_create() -> Option<Response> {
    unsafe {
        let result = cef_response_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_is_cert_status_error`] for more documentation.
pub fn is_cert_status_error(status: CertStatus) -> ::std::os::raw::c_int {
    unsafe {
        let arg_status = status;
        let arg_status = arg_status.into_raw();
        let result = cef_is_cert_status_error(arg_status);
        result.wrap_result()
    }
}

/// See [`cef_command_line_create`] for more documentation.
pub fn command_line_create() -> Option<CommandLine> {
    unsafe {
        let result = cef_command_line_create();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_command_line_get_global`] for more documentation.
pub fn command_line_get_global() -> Option<CommandLine> {
    unsafe {
        let result = cef_command_line_get_global();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_task_runner_get_for_current_thread`] for more documentation.
pub fn task_runner_get_for_current_thread() -> Option<TaskRunner> {
    unsafe {
        let result = cef_task_runner_get_for_current_thread();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_task_runner_get_for_thread`] for more documentation.
pub fn task_runner_get_for_thread(thread_id: ThreadId) -> Option<TaskRunner> {
    unsafe {
        let arg_thread_id = thread_id;
        let arg_thread_id = arg_thread_id.into_raw();
        let result = cef_task_runner_get_for_thread(arg_thread_id);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_currently_on`] for more documentation.
pub fn currently_on(thread_id: ThreadId) -> ::std::os::raw::c_int {
    unsafe {
        let arg_thread_id = thread_id;
        let arg_thread_id = arg_thread_id.into_raw();
        let result = cef_currently_on(arg_thread_id);
        result.wrap_result()
    }
}

/// See [`cef_post_task`] for more documentation.
pub fn post_task(thread_id: ThreadId, task: Option<&mut impl ImplTask>) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_thread_id, arg_task) = (thread_id, task);
        let arg_thread_id = arg_thread_id.into_raw();
        let arg_task = arg_task
            .map(|arg| {
                arg.add_ref();
                ImplTask::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_post_task(arg_thread_id, arg_task);
        result.wrap_result()
    }
}

/// See [`cef_post_delayed_task`] for more documentation.
pub fn post_delayed_task(
    thread_id: ThreadId,
    task: Option<&mut impl ImplTask>,
    delay_ms: i64,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_thread_id, arg_task, arg_delay_ms) = (thread_id, task, delay_ms);
        let arg_thread_id = arg_thread_id.into_raw();
        let arg_task = arg_task
            .map(|arg| {
                arg.add_ref();
                ImplTask::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_post_delayed_task(arg_thread_id, arg_task, arg_delay_ms);
        result.wrap_result()
    }
}

/// See [`cef_v8_context_get_current_context`] for more documentation.
pub fn v8_context_get_current_context() -> Option<V8Context> {
    unsafe {
        let result = cef_v8_context_get_current_context();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_context_get_entered_context`] for more documentation.
pub fn v8_context_get_entered_context() -> Option<V8Context> {
    unsafe {
        let result = cef_v8_context_get_entered_context();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_context_in_context`] for more documentation.
pub fn v8_context_in_context() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_v8_context_in_context();
        result.wrap_result()
    }
}

/// See [`cef_v8_value_create_undefined`] for more documentation.
pub fn v8_value_create_undefined() -> Option<V8Value> {
    unsafe {
        let result = cef_v8_value_create_undefined();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_null`] for more documentation.
pub fn v8_value_create_null() -> Option<V8Value> {
    unsafe {
        let result = cef_v8_value_create_null();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_bool`] for more documentation.
pub fn v8_value_create_bool(value: ::std::os::raw::c_int) -> Option<V8Value> {
    unsafe {
        let arg_value = value;
        let result = cef_v8_value_create_bool(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_int`] for more documentation.
pub fn v8_value_create_int(value: i32) -> Option<V8Value> {
    unsafe {
        let arg_value = value;
        let result = cef_v8_value_create_int(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_uint`] for more documentation.
pub fn v8_value_create_uint(value: u32) -> Option<V8Value> {
    unsafe {
        let arg_value = value;
        let result = cef_v8_value_create_uint(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_double`] for more documentation.
pub fn v8_value_create_double(value: f64) -> Option<V8Value> {
    unsafe {
        let arg_value = value;
        let result = cef_v8_value_create_double(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_date`] for more documentation.
pub fn v8_value_create_date(date: _cef_basetime_t) -> Option<V8Value> {
    unsafe {
        let arg_date = date;
        let result = cef_v8_value_create_date(arg_date);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_string`] for more documentation.
pub fn v8_value_create_string(value: Option<&CefString>) -> Option<V8Value> {
    unsafe {
        let arg_value = value;
        let arg_value = arg_value
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_v8_value_create_string(arg_value);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_object`] for more documentation.
pub fn v8_value_create_object(
    accessor: Option<&mut impl ImplV8Accessor>,
    interceptor: Option<&mut impl ImplV8Interceptor>,
) -> Option<V8Value> {
    unsafe {
        let (arg_accessor, arg_interceptor) = (accessor, interceptor);
        let arg_accessor = arg_accessor
            .map(|arg| {
                arg.add_ref();
                ImplV8Accessor::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_interceptor = arg_interceptor
            .map(|arg| {
                arg.add_ref();
                ImplV8Interceptor::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_v8_value_create_object(arg_accessor, arg_interceptor);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_array`] for more documentation.
pub fn v8_value_create_array(length: ::std::os::raw::c_int) -> Option<V8Value> {
    unsafe {
        let arg_length = length;
        let result = cef_v8_value_create_array(arg_length);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_array_buffer`] for more documentation.
pub fn v8_value_create_array_buffer(
    buffer: *mut u8,
    length: usize,
    release_callback: Option<&mut impl ImplV8ArrayBufferReleaseCallback>,
) -> Option<V8Value> {
    unsafe {
        let (arg_buffer, arg_length, arg_release_callback) = (buffer, length, release_callback);
        let arg_buffer = arg_buffer.cast();
        let arg_release_callback = arg_release_callback
            .map(|arg| {
                arg.add_ref();
                ImplV8ArrayBufferReleaseCallback::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_v8_value_create_array_buffer(arg_buffer, arg_length, arg_release_callback);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_array_buffer_with_copy`] for more documentation.
pub fn v8_value_create_array_buffer_with_copy(buffer: *mut u8, length: usize) -> Option<V8Value> {
    unsafe {
        let (arg_buffer, arg_length) = (buffer, length);
        let arg_buffer = arg_buffer.cast();
        let result = cef_v8_value_create_array_buffer_with_copy(arg_buffer, arg_length);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_function`] for more documentation.
pub fn v8_value_create_function(
    name: Option<&CefString>,
    handler: Option<&mut impl ImplV8Handler>,
) -> Option<V8Value> {
    unsafe {
        let (arg_name, arg_handler) = (name, handler);
        let arg_name = arg_name
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplV8Handler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_v8_value_create_function(arg_name, arg_handler);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_value_create_promise`] for more documentation.
pub fn v8_value_create_promise() -> Option<V8Value> {
    unsafe {
        let result = cef_v8_value_create_promise();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_v8_stack_trace_get_current`] for more documentation.
pub fn v8_stack_trace_get_current(frame_limit: ::std::os::raw::c_int) -> Option<V8StackTrace> {
    unsafe {
        let arg_frame_limit = frame_limit;
        let result = cef_v8_stack_trace_get_current(arg_frame_limit);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_register_extension`] for more documentation.
pub fn register_extension(
    extension_name: Option<&CefString>,
    javascript_code: Option<&CefString>,
    handler: Option<&mut impl ImplV8Handler>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_extension_name, arg_javascript_code, arg_handler) =
            (extension_name, javascript_code, handler);
        let arg_extension_name = arg_extension_name
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_javascript_code = arg_javascript_code
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_handler = arg_handler
            .map(|arg| {
                arg.add_ref();
                ImplV8Handler::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_register_extension(arg_extension_name, arg_javascript_code, arg_handler);
        result.wrap_result()
    }
}

/// See [`cef_register_scheme_handler_factory`] for more documentation.
pub fn register_scheme_handler_factory(
    scheme_name: Option<&CefString>,
    domain_name: Option<&CefString>,
    factory: Option<&mut impl ImplSchemeHandlerFactory>,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_scheme_name, arg_domain_name, arg_factory) = (scheme_name, domain_name, factory);
        let arg_scheme_name = arg_scheme_name
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_domain_name = arg_domain_name
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_factory = arg_factory
            .map(|arg| {
                arg.add_ref();
                ImplSchemeHandlerFactory::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result =
            cef_register_scheme_handler_factory(arg_scheme_name, arg_domain_name, arg_factory);
        result.wrap_result()
    }
}

/// See [`cef_clear_scheme_handler_factories`] for more documentation.
pub fn clear_scheme_handler_factories() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_clear_scheme_handler_factories();
        result.wrap_result()
    }
}

/// See [`cef_execute_process`] for more documentation.
pub fn execute_process(
    args: Option<&MainArgs>,
    application: Option<&mut impl ImplApp>,
    windows_sandbox_info: *mut u8,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_args, arg_application, arg_windows_sandbox_info) =
            (args, application, windows_sandbox_info);
        let arg_args = arg_args.cloned().map(|arg| arg.into());
        let arg_args = arg_args
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_application = arg_application
            .map(|arg| {
                arg.add_ref();
                ImplApp::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_windows_sandbox_info = arg_windows_sandbox_info.cast();
        let result = cef_execute_process(arg_args, arg_application, arg_windows_sandbox_info);
        result.wrap_result()
    }
}

/// See [`cef_initialize`] for more documentation.
pub fn initialize(
    args: Option<&MainArgs>,
    settings: Option<&Settings>,
    application: Option<&mut impl ImplApp>,
    windows_sandbox_info: *mut u8,
) -> ::std::os::raw::c_int {
    unsafe {
        let (arg_args, arg_settings, arg_application, arg_windows_sandbox_info) =
            (args, settings, application, windows_sandbox_info);
        let arg_args = arg_args.cloned().map(|arg| arg.into());
        let arg_args = arg_args
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_application = arg_application
            .map(|arg| {
                arg.add_ref();
                ImplApp::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_windows_sandbox_info = arg_windows_sandbox_info.cast();
        let result = cef_initialize(
            arg_args,
            arg_settings,
            arg_application,
            arg_windows_sandbox_info,
        );
        result.wrap_result()
    }
}

/// See [`cef_get_exit_code`] for more documentation.
pub fn get_exit_code() -> ::std::os::raw::c_int {
    unsafe {
        let result = cef_get_exit_code();
        result.wrap_result()
    }
}

/// See [`cef_shutdown`] for more documentation.
pub fn shutdown() {
    unsafe {
        cef_shutdown();
    }
}

/// See [`cef_do_message_loop_work`] for more documentation.
pub fn do_message_loop_work() {
    unsafe {
        cef_do_message_loop_work();
    }
}

/// See [`cef_run_message_loop`] for more documentation.
pub fn run_message_loop() {
    unsafe {
        cef_run_message_loop();
    }
}

/// See [`cef_quit_message_loop`] for more documentation.
pub fn quit_message_loop() {
    unsafe {
        cef_quit_message_loop();
    }
}

/// See [`cef_urlrequest_create`] for more documentation.
pub fn urlrequest_create(
    request: Option<&mut Request>,
    client: Option<&mut impl ImplUrlrequestClient>,
    request_context: Option<&mut RequestContext>,
) -> Option<Urlrequest> {
    unsafe {
        let (arg_request, arg_client, arg_request_context) = (request, client, request_context);
        let arg_request = arg_request
            .map(|arg| {
                arg.add_ref();
                ImplRequest::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_client = arg_client
            .map(|arg| {
                arg.add_ref();
                ImplUrlrequestClient::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_request_context = arg_request_context
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_urlrequest_create(arg_request, arg_client, arg_request_context);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_label_button_create`] for more documentation.
pub fn label_button_create(
    delegate: Option<&mut impl ImplButtonDelegate>,
    text: Option<&CefString>,
) -> Option<LabelButton> {
    unsafe {
        let (arg_delegate, arg_text) = (delegate, text);
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplButtonDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_text = arg_text
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_label_button_create(arg_delegate, arg_text);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_menu_button_create`] for more documentation.
pub fn menu_button_create(
    delegate: Option<&mut impl ImplMenuButtonDelegate>,
    text: Option<&CefString>,
) -> Option<MenuButton> {
    unsafe {
        let (arg_delegate, arg_text) = (delegate, text);
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplMenuButtonDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_text = arg_text
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let result = cef_menu_button_create(arg_delegate, arg_text);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_textfield_create`] for more documentation.
pub fn textfield_create(delegate: Option<&mut impl ImplTextfieldDelegate>) -> Option<Textfield> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplTextfieldDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_textfield_create(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_browser_view_create`] for more documentation.
pub fn browser_view_create(
    client: Option<&mut impl ImplClient>,
    url: Option<&CefString>,
    settings: Option<&BrowserSettings>,
    extra_info: Option<&mut DictionaryValue>,
    request_context: Option<&mut RequestContext>,
    delegate: Option<&mut impl ImplBrowserViewDelegate>,
) -> Option<BrowserView> {
    unsafe {
        let (arg_client, arg_url, arg_settings, arg_extra_info, arg_request_context, arg_delegate) =
            (client, url, settings, extra_info, request_context, delegate);
        let arg_client = arg_client
            .map(|arg| {
                arg.add_ref();
                ImplClient::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_url = arg_url
            .map(|arg| arg.into_raw())
            .unwrap_or(std::ptr::null());
        let arg_settings = arg_settings.cloned().map(|arg| arg.into());
        let arg_settings = arg_settings
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let arg_extra_info = arg_extra_info
            .map(|arg| {
                arg.add_ref();
                ImplDictionaryValue::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_request_context = arg_request_context
            .map(|arg| {
                arg.add_ref();
                ImplRequestContext::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplBrowserViewDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_browser_view_create(
            arg_client,
            arg_url,
            arg_settings,
            arg_extra_info,
            arg_request_context,
            arg_delegate,
        );
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_browser_view_get_for_browser`] for more documentation.
pub fn browser_view_get_for_browser(browser: Option<&mut Browser>) -> Option<BrowserView> {
    unsafe {
        let arg_browser = browser;
        let arg_browser = arg_browser
            .map(|arg| {
                arg.add_ref();
                ImplBrowser::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_browser_view_get_for_browser(arg_browser);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_scroll_view_create`] for more documentation.
pub fn scroll_view_create(delegate: Option<&mut impl ImplViewDelegate>) -> Option<ScrollView> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplViewDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_scroll_view_create(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_display_get_primary`] for more documentation.
pub fn display_get_primary() -> Option<Display> {
    unsafe {
        let result = cef_display_get_primary();
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_display_get_nearest_point`] for more documentation.
pub fn display_get_nearest_point(
    point: Option<&Point>,
    input_pixel_coords: ::std::os::raw::c_int,
) -> Option<Display> {
    unsafe {
        let (arg_point, arg_input_pixel_coords) = (point, input_pixel_coords);
        let arg_point = arg_point.cloned().map(|arg| arg.into());
        let arg_point = arg_point
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_get_nearest_point(arg_point, arg_input_pixel_coords);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_display_get_matching_bounds`] for more documentation.
pub fn display_get_matching_bounds(
    bounds: Option<&Rect>,
    input_pixel_coords: ::std::os::raw::c_int,
) -> Option<Display> {
    unsafe {
        let (arg_bounds, arg_input_pixel_coords) = (bounds, input_pixel_coords);
        let arg_bounds = arg_bounds.cloned().map(|arg| arg.into());
        let arg_bounds = arg_bounds
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_get_matching_bounds(arg_bounds, arg_input_pixel_coords);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_display_get_count`] for more documentation.
pub fn display_get_count() -> usize {
    unsafe {
        let result = cef_display_get_count();
        result.wrap_result()
    }
}

/// See [`cef_display_get_alls`] for more documentation.
pub fn display_get_alls(displays: Option<&mut Vec<Option<Display>>>) {
    unsafe {
        let arg_displays = displays;
        let mut out_displays_count = arg_displays
            .as_ref()
            .map(|arg| arg.len())
            .unwrap_or_default();
        let arg_displays_count = &mut out_displays_count;
        let out_displays = arg_displays;
        let mut vec_displays = out_displays
            .as_ref()
            .map(|arg| {
                arg.iter()
                    .map(|elem| {
                        elem.as_ref()
                            .map(|elem| {
                                elem.add_ref();
                                elem.get_raw()
                            })
                            .unwrap_or(std::ptr::null_mut())
                    })
                    .collect::<Vec<_>>()
            })
            .unwrap_or_default();
        let arg_displays = if vec_displays.is_empty() {
            std::ptr::null_mut()
        } else {
            vec_displays.as_mut_ptr()
        };
        cef_display_get_alls(arg_displays_count, arg_displays);
        if let Some(out_displays) = out_displays {
            *out_displays = vec_displays
                .into_iter()
                .take(out_displays_count)
                .map(|elem| {
                    if elem.is_null() {
                        None
                    } else {
                        Some(elem.wrap_result())
                    }
                })
                .collect();
        }
    }
}

/// See [`cef_display_convert_screen_point_to_pixels`] for more documentation.
pub fn display_convert_screen_point_to_pixels(point: Option<&Point>) -> Point {
    unsafe {
        let arg_point = point;
        let arg_point = arg_point.cloned().map(|arg| arg.into());
        let arg_point = arg_point
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_convert_screen_point_to_pixels(arg_point);
        result.wrap_result()
    }
}

/// See [`cef_display_convert_screen_point_from_pixels`] for more documentation.
pub fn display_convert_screen_point_from_pixels(point: Option<&Point>) -> Point {
    unsafe {
        let arg_point = point;
        let arg_point = arg_point.cloned().map(|arg| arg.into());
        let arg_point = arg_point
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_convert_screen_point_from_pixels(arg_point);
        result.wrap_result()
    }
}

/// See [`cef_display_convert_screen_rect_to_pixels`] for more documentation.
pub fn display_convert_screen_rect_to_pixels(rect: Option<&Rect>) -> Rect {
    unsafe {
        let arg_rect = rect;
        let arg_rect = arg_rect.cloned().map(|arg| arg.into());
        let arg_rect = arg_rect
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_convert_screen_rect_to_pixels(arg_rect);
        result.wrap_result()
    }
}

/// See [`cef_display_convert_screen_rect_from_pixels`] for more documentation.
pub fn display_convert_screen_rect_from_pixels(rect: Option<&Rect>) -> Rect {
    unsafe {
        let arg_rect = rect;
        let arg_rect = arg_rect.cloned().map(|arg| arg.into());
        let arg_rect = arg_rect
            .as_ref()
            .map(std::ptr::from_ref)
            .unwrap_or(std::ptr::null());
        let result = cef_display_convert_screen_rect_from_pixels(arg_rect);
        result.wrap_result()
    }
}

/// See [`cef_panel_create`] for more documentation.
pub fn panel_create(delegate: Option<&mut impl ImplPanelDelegate>) -> Option<Panel> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplPanelDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_panel_create(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}

/// See [`cef_window_create_top_level`] for more documentation.
pub fn window_create_top_level(delegate: Option<&mut impl ImplWindowDelegate>) -> Option<Window> {
    unsafe {
        let arg_delegate = delegate;
        let arg_delegate = arg_delegate
            .map(|arg| {
                arg.add_ref();
                ImplWindowDelegate::get_raw(arg)
            })
            .unwrap_or(std::ptr::null_mut());
        let result = cef_window_create_top_level(arg_delegate);
        if result.is_null() {
            None
        } else {
            Some(result.wrap_result())
        }
    }
}
